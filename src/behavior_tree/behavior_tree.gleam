/// Represents the input data needed for an entity to update.
pub type BehaviorInput(entity, additional_inputs) {
  /// Represents the input data needed for an entity to update.
  BehaviorInput(
    /// The entity being updated.
    entity: entity,
    /// Any additional inputs needed for the update.
    additional_inputs: additional_inputs,
  )
}

/// Represents the result of an entity update.
pub type BehaviorResult(entity, additional_outputs) {
  /// Represents the result of an entity update.
  BehaviorResult(
    /// Whether the action can continue.
    success: Bool,
    /// The updated entity.
    entity: entity,
    /// Any other outputs generated by the update.
    additional_outputs: additional_outputs,
  )
}

pub type BehaviorTree(entity, additional_inputs, additional_outputs) =
  fn(BehaviorInput(entity, additional_inputs)) ->
    BehaviorResult(entity, additional_outputs)

/// Creates a behavior tree that performs the given behavior tree but always succeeds.
pub fn true(
  bt: BehaviorTree(entity, additional_inputs, additional_outputs),
) -> BehaviorTree(entity, additional_inputs, additional_outputs) {
  fn(input) {
    let BehaviorResult(success: _, entity: e, additional_outputs: a) = bt(input)
    BehaviorResult(success: True, entity: e, additional_outputs: a)
  }
}

/// Creates a behavior tree that performs the given behavior tree but returns the opposite for success.
pub fn not(
  bt: BehaviorTree(entity, additional_inputs, additional_outputs),
) -> BehaviorTree(entity, additional_inputs, additional_outputs) {
  fn(input) {
    let BehaviorResult(success: s, entity: e, additional_outputs: a) = bt(input)
    BehaviorResult(success: !s, entity: e, additional_outputs: a)
  }
}

/// Creates a behavior tree that performs all the given behavior trees until one succeeds.
/// If none succeed, the last behavior tree's outputs are returned and the whole tree fails.
pub fn selector(
  btrees: List(BehaviorTree(entity, additional_inputs, additional_outputs)),
  default_output: additional_outputs,
  output_to_input: fn(additional_inputs, additional_outputs) ->
    additional_inputs,
  output_merge: fn(additional_outputs, additional_outputs) -> additional_outputs,
) -> BehaviorTree(entity, additional_inputs, additional_outputs) {
  case btrees {
    [] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      BehaviorResult(
        success: False,
        entity: input.entity,
        additional_outputs: default_output,
      )
    }
    [bt, ..rest] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      let BehaviorResult(
        success: success,
        entity: e,
        additional_outputs: first_behavior_outputs,
      ) = bt(input)

      case success {
        True ->
          BehaviorResult(
            success: True,
            entity: e,
            additional_outputs: first_behavior_outputs,
          )
        False -> {
          let next_input =
            BehaviorInput(
              entity: e,
              additional_inputs: output_to_input(
                input.additional_inputs,
                first_behavior_outputs,
              ),
            )
          let BehaviorResult(success, e, rest_outputs) =
            selector(rest, default_output, output_to_input, output_merge)(
              next_input,
            )
          let final_outputs = output_merge(first_behavior_outputs, rest_outputs)

          BehaviorResult(success, e, final_outputs)
        }
      }
    }
  }
}

/// Creates a behavior tree that performs all the given behavior trees until one fails.
/// If all succeed, the last behavior tree's outputs are returned and the whole tree succeeds.
pub fn sequence(
  btrees: List(BehaviorTree(entity, additional_inputs, additional_outputs)),
  default_output: additional_outputs,
  output_to_input: fn(additional_inputs, additional_outputs) ->
    additional_inputs,
  output_merge: fn(additional_outputs, additional_outputs) -> additional_outputs,
) -> BehaviorTree(entity, additional_inputs, additional_outputs) {
  case btrees {
    [] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      BehaviorResult(
        success: True,
        entity: input.entity,
        additional_outputs: default_output,
      )
    }
    [bt, ..rest] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      let BehaviorResult(
        success: success,
        entity: e,
        additional_outputs: first_behavior_outputs,
      ) = bt(input)

      case success {
        False ->
          BehaviorResult(
            success: False,
            entity: e,
            additional_outputs: output_merge(
              default_output,
              first_behavior_outputs,
            ),
          )
        True -> {
          let next_input =
            BehaviorInput(
              entity: e,
              additional_inputs: output_to_input(
                input.additional_inputs,
                first_behavior_outputs,
              ),
            )
          let BehaviorResult(success, e, rest_outputs) =
            sequence(rest, default_output, output_to_input, output_merge)(
              next_input,
            )
          let final_outputs = output_merge(first_behavior_outputs, rest_outputs)

          BehaviorResult(success, e, final_outputs)
        }
      }
    }
  }
}

/// Creates a behavior tree that performs all the given behavior trees and always succeeds.
pub fn all(
  btrees: List(BehaviorTree(entity, additional_inputs, additional_outputs)),
  default_output: additional_outputs,
  output_to_input: fn(additional_inputs, additional_outputs) ->
    additional_inputs,
  output_merge: fn(additional_outputs, additional_outputs) -> additional_outputs,
) -> BehaviorTree(entity, additional_inputs, additional_outputs) {
  case btrees {
    [] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      BehaviorResult(
        success: True,
        entity: input.entity,
        additional_outputs: default_output,
      )
    }
    [bt, ..rest] -> fn(input: BehaviorInput(entity, additional_inputs)) {
      let BehaviorResult(
        success: _,
        entity: e,
        additional_outputs: first_behavior_outputs,
      ) = bt(input)
      let next_input =
        BehaviorInput(
          entity: e,
          additional_inputs: output_to_input(
            input.additional_inputs,
            first_behavior_outputs,
          ),
        )
      let BehaviorResult(success, e, rest_outputs) =
        all(rest, default_output, output_to_input, output_merge)(next_input)
      let final_outputs = output_merge(first_behavior_outputs, rest_outputs)

      BehaviorResult(success, e, final_outputs)
    }
  }
}
