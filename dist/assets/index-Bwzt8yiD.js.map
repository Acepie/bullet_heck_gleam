{"version":3,"file":"index-Bwzt8yiD.js","names":["NonEmpty","length","#current","index","value","line","$CustomType","$CustomType","size","get","do_insert","value","$Empty","new$","fold_loop","fold","to_list","$Empty","listPrepend","map_loop","map","first","first$1","fold","stop","$int.compare","$order.Lt","$order.Eq","range","each","ceiling","float","floor","truncate","map","value","compare","$order.Eq","$order.Lt","$order.Gt","power","ceiling","do_power","round","js_round","$order.Eq","$order.Lt","$order.Gt","random","$float.random","to_float","max","$float.floor","$float.round","$CustomType","draw","on_tick","on_key_pressed","on_key_released","on_mouse_clicked","preload","$dict.new$","$dict.insert","$dict.get","$option.None","$option.Some","$CustomType","$Empty","map","$CustomType","$int.compare","stop","$order.Lt","$order.Eq","float","atan2","do_atan2","cos","do_cos","sin","do_sin","pi","do_pi","FILEPATH","$CustomType","$float.square_root","limit","$maths.atan2","$maths.pi","$maths.cos","$maths.sin","$CustomType","$vector.add","$utils.now_in_milliseconds","collides_with","$vector.distance","size","$vector.multiply","$vector.normalize","draw","$p5.circle","FILEPATH","$CustomType","Empty","size","listPrepend","$Empty","step","range","new_seed","new$","$int.random","FILEPATH","$CustomType","step","$yielder.unfold","seed","value","new_seed","$yielder.Next","$seed.random","$yielder.first","compare","one","$int.compare","$float.compare","$CustomType","damage","collides_with","$vector.distance","draw","$p5.stroke","$p5.fill","$p5.circle","$p5.line","$CustomType","size","draw","$p5.no_stroke","$p5.fill","$p5.circle","$CustomType","draw","$int.to_float","room_size","$p5.line","FILEPATH","$CustomType","$room.Left","$room.Right","$room.Top","$room.Bottom","$room.TopLeft","$room.TopRight","$room.BottomLeft","fc","fr","tc","tr","$room.BottomRight","$list.any","$vector.distance","$dict.fold","$room.is_navigable","$bool.guard","$dict.get","rooms","$room.inverse_direction","$room.set_navigable","$dict.insert","$room.initialize_unbounded_room","$dict.has_key","$random.float","$random.random_sample","rooms$1","$int.to_float","size","$vector.Vector","$random.int","draw","$yielder.range","$yielder.each","$result.map","$room.draw","$pit.draw","$list.each","$obstacle.draw","$float.truncate","$result.try$","$option.Some","listPrepend","$priorityq.is_empty","$priorityq.peek","$priorityq.pop","$list.reverse","$list.fold","worklist$2","seen_so_far$1","next","$priorityq.push","$option.None","$priorityq.new$","$float.compare","$dict.from_list","$vector.add","$obstacle.Obstacle","$list.range","$pit.Pit","obstacles","$dict.new$","FILEPATH","$CustomType","acceleration","max_speed","jump_power","dead_fill_color","$vector.add","$vector.Vector","apply_damage","$utils.now_in_milliseconds","damage","$vector.vector_2d","$vector.limit","apply_gravity","draw","$float.power","$float.max","$p5.ellipse","FILEPATH","$CustomType","$random.int","$random.random_sample","$room.Left","$room.Right","$room.Top","$room.Bottom","$room.TopLeft","$room.TopRight","$room.BottomLeft","$room.BottomRight","$dungeon.point_to_coordinate","$dungeon.next_room_indices","$dungeon.coordinate_to_point","$dungeon.can_move","$behavior_tree.BehaviorResult","$utils.now_in_milliseconds","$bool.guard","$vector.distance","$int.to_float","$dungeon.path_to","$list.take","$list.length","$vector.add","$vector.Vector","$vector.vector_2d","$vector.subtract","$vector.multiply","$vector.dot","$vector.from_angle2d","$vector.magnitude","damage","center","pi","$maths.pi","size","now","$bullet.spawn_bullet","$vector.normalize","$vector.rotate2d","$vector.heading2d","$float.absolute_value","$vector.magnitude_squared","$float.min","acceleration","$list.fold","is_jumping","acceleration$1","add","$vector.limit","$Empty","next","$list.filter_map","$dungeon.get_reflecting_point","$list.append","new$","sequence","$behavior_tree.sequence","selector","$behavior_tree.selector","$behavior_tree.all","$behavior_tree.not","draw","$float.power","$float.max","$p5.stroke","$p5.circle","$p5.line","$maths.cos","$maths.sin","$CustomType","$p5.load_font","$p5js_gleam.initialize_assets","$p5js_gleam.insert_font","$dungeon.total_size","$p5.text_width","$p5js_gleam.get_font","$p5.fill","$p5.rect","$p5.text_size","$p5.text_font","$p5.text","$enemy.draw","$bullet.draw","$p5.no_stroke","$int.to_float","$int.to_string","$list.map","$list.range","$dungeon.get_location_to_place_object","$enemy.new_enemy","$dungeon.generate_dungeon","$player.new_player","$vector.Vector","$player.jump","$player.accelerate_y","$player.accelerate_x","$player.stop_y","$player.stop_x","$bool.guard","$player.can_player_fire","$vector.vector_2d","$vector.subtract","$player.Player","$utils.now_in_milliseconds","listPrepend","$bullet.spawn_bullet","$player.move","$dungeon.can_move","$dungeon.is_over_pit","$player.update_velocity","$player.apply_gravity","$list.fold","$obstacle.collides_with","player","$player.is_player_invulnerable","$player.apply_damage","enemies$1","bullets$1","player$5","score$1","$2","$behavior_tree.BehaviorInput","$enemy.Inputs","$enemy.apply_gravity","bullets$2","$list.append","_block$1","$enemy.collides_with","player$6","enemy","$enemy.apply_damage","$enemy.is_enemy_dead","$list.filter","$bullet.is_still_alive","$bullet.advance_bullet","bullets$3","enemies$2","score$2","$bullet.collides_with","enemies$3","score$3","any_hit","acc","any_hit$1","$player.is_player_dead","$Empty","$p5js_gleam.create_sketch_with_preloading","$p5js_gleam.set_on_key_pressed","$p5js_gleam.set_on_key_released","$p5js_gleam.set_on_mouse_clicked","$p5js_gleam.set_on_tick","$p5.start_sketch"],"sources":["../../build/dev/javascript/gleam_stdlib/gleam/bool.mjs","../../build/dev/javascript/prelude.mjs","../../build/dev/javascript/gleam_stdlib/gleam/order.mjs","../../build/dev/javascript/gleam_stdlib/gleam/option.mjs","../../build/dev/javascript/gleam_stdlib/dict.mjs","../../build/dev/javascript/gleam_stdlib/gleam/dict.mjs","../../build/dev/javascript/gleam_stdlib/gleam/list.mjs","../../build/dev/javascript/gleam_stdlib/gleam_stdlib.mjs","../../build/dev/javascript/gleam_stdlib/gleam/float.mjs","../../build/dev/javascript/gleam_stdlib/gleam/int.mjs","../../build/dev/javascript/p5js_gleam/p5js_gleam.mjs","../../build/dev/javascript/p5js_gleam/p5js_ffi.mjs","../../build/dev/javascript/bullet_heck_gleam/behavior_tree/behavior_tree.mjs","../../build/dev/javascript/bullet_heck_gleam/ffi_utils.mjs","../../build/dev/javascript/gleam_stdlib/gleam/result.mjs","../../build/dev/javascript/gleam_yielder/gleam/yielder.mjs","../../build/dev/javascript/gleam_community_maths/maths.mjs","../../build/dev/javascript/gleam_community_maths/gleam_community/maths.mjs","../../build/dev/javascript/bullet_heck_gleam/vector.mjs","../../build/dev/javascript/bullet_heck_gleam/bullet.mjs","../../build/dev/javascript/priorityq/priorityq.mjs","../../build/dev/javascript/prng/prng_ffi.mjs","../../build/dev/javascript/prng/prng/seed.mjs","../../build/dev/javascript/prng/prng/random.mjs","../../build/dev/javascript/bullet_heck_gleam/obstacle.mjs","../../build/dev/javascript/bullet_heck_gleam/pit.mjs","../../build/dev/javascript/bullet_heck_gleam/room.mjs","../../build/dev/javascript/bullet_heck_gleam/dungeon.mjs","../../build/dev/javascript/bullet_heck_gleam/player.mjs","../../build/dev/javascript/bullet_heck_gleam/enemy.mjs","../../build/dev/javascript/bullet_heck_gleam/bullet_heck_gleam.mjs","../../index.html?html-proxy&index=0.js"],"sourcesContent":["//# sourceMappingURL=bool.mjs.map\n/**\n * Returns the and of two bools, but it evaluates both arguments.\n *\n * It's the function equivalent of the `&&` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * and(True, True)\n * // -> True\n * ```\n *\n * ```gleam\n * and(False, True)\n * // -> False\n * ```\n *\n * ```gleam\n * False |> and(True)\n * // -> False\n * ```\n */\nexport function and(a, b) {\n  return a && b;\n}\n\n/**\n * Returns the or of two bools, but it evaluates both arguments.\n *\n * It's the function equivalent of the `||` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * or(True, True)\n * // -> True\n * ```\n *\n * ```gleam\n * or(False, True)\n * // -> True\n * ```\n *\n * ```gleam\n * False |> or(True)\n * // -> True\n * ```\n */\nexport function or(a, b) {\n  return a || b;\n}\n\n/**\n * Returns the opposite bool value.\n *\n * This is the same as the `!` or `not` operators in some other languages.\n *\n * ## Examples\n *\n * ```gleam\n * negate(True)\n * // -> False\n * ```\n *\n * ```gleam\n * negate(False)\n * // -> True\n * ```\n */\nexport function negate(bool) {\n  return !bool;\n}\n\n/**\n * Returns the nor of two bools.\n *\n * ## Examples\n *\n * ```gleam\n * nor(False, False)\n * // -> True\n * ```\n *\n * ```gleam\n * nor(False, True)\n * // -> False\n * ```\n *\n * ```gleam\n * nor(True, False)\n * // -> False\n * ```\n *\n * ```gleam\n * nor(True, True)\n * // -> False\n * ```\n */\nexport function nor(a, b) {\n  return !(a || b);\n}\n\n/**\n * Returns the nand of two bools.\n *\n * ## Examples\n *\n * ```gleam\n * nand(False, False)\n * // -> True\n * ```\n *\n * ```gleam\n * nand(False, True)\n * // -> True\n * ```\n *\n * ```gleam\n * nand(True, False)\n * // -> True\n * ```\n *\n * ```gleam\n * nand(True, True)\n * // -> False\n * ```\n */\nexport function nand(a, b) {\n  return !(a && b);\n}\n\n/**\n * Returns the exclusive or of two bools.\n *\n * ## Examples\n *\n * ```gleam\n * exclusive_or(False, False)\n * // -> False\n * ```\n *\n * ```gleam\n * exclusive_or(False, True)\n * // -> True\n * ```\n *\n * ```gleam\n * exclusive_or(True, False)\n * // -> True\n * ```\n *\n * ```gleam\n * exclusive_or(True, True)\n * // -> False\n * ```\n */\nexport function exclusive_or(a, b) {\n  return a !== b;\n}\n\n/**\n * Returns the exclusive nor of two bools.\n *\n * ## Examples\n *\n * ```gleam\n * exclusive_nor(False, False)\n * // -> True\n * ```\n *\n * ```gleam\n * exclusive_nor(False, True)\n * // -> False\n * ```\n *\n * ```gleam\n * exclusive_nor(True, False)\n * // -> False\n * ```\n *\n * ```gleam\n * exclusive_nor(True, True)\n * // -> True\n * ```\n */\nexport function exclusive_nor(a, b) {\n  return a === b;\n}\n\n/**\n * Returns a string representation of the given bool.\n *\n * ## Examples\n *\n * ```gleam\n * to_string(True)\n * // -> \"True\"\n * ```\n *\n * ```gleam\n * to_string(False)\n * // -> \"False\"\n * ```\n */\nexport function to_string(bool) {\n  if (bool) {\n    return \"True\";\n  } else {\n    return \"False\";\n  }\n}\n\n/**\n * Run a callback function if the given bool is `False`, otherwise return a\n * default value.\n *\n * With a `use` expression this function can simulate the early-return pattern\n * found in some other programming languages.\n *\n * In a procedural language:\n *\n * ```js\n * if (predicate) return value;\n * // ...\n * ```\n *\n * In Gleam with a `use` expression:\n *\n * ```gleam\n * use <- guard(when: predicate, return: value)\n * // ...\n * ```\n *\n * Like everything in Gleam `use` is an expression, so it short circuits the\n * current block, not the entire function. As a result you can assign the value\n * to a variable:\n *\n * ```gleam\n * let x = {\n *   use <- guard(when: predicate, return: value)\n *   // ...\n * }\n * ```\n *\n * Note that unlike in procedural languages the `return` value is evaluated\n * even when the predicate is `False`, so it is advisable not to perform\n * expensive computation nor side-effects there.\n *\n *\n * ## Examples\n *\n * ```gleam\n * let name = \"\"\n * use <- guard(when: name == \"\", return: \"Welcome!\")\n * \"Hello, \" <> name\n * // -> \"Welcome!\"\n * ```\n *\n * ```gleam\n * let name = \"Kamaka\"\n * use <- guard(when: name == \"\", return: \"Welcome!\")\n * \"Hello, \" <> name\n * // -> \"Hello, Kamaka\"\n * ```\n */\nexport function guard(requirement, consequence, alternative) {\n  if (requirement) {\n    return consequence;\n  } else {\n    return alternative();\n  }\n}\n\n/**\n * Runs a callback function if the given bool is `True`, otherwise runs an\n * alternative callback function.\n *\n * Useful when further computation should be delayed regardless of the given\n * bool's value.\n *\n * See [`guard`](#guard) for more info.\n *\n * ## Examples\n *\n * ```gleam\n * let name = \"Kamaka\"\n * let inquiry = fn() { \"How may we address you?\" }\n * use <- lazy_guard(when: name == \"\", return: inquiry)\n * \"Hello, \" <> name\n * // -> \"Hello, Kamaka\"\n * ```\n *\n * ```gleam\n * import gleam/int\n *\n * let name = \"\"\n * let greeting = fn() { \"Hello, \" <> name }\n * use <- lazy_guard(when: name == \"\", otherwise: greeting)\n * let number = int.random(99)\n * let name = \"User \" <> int.to_string(number)\n * \"Welcome, \" <> name\n * // -> \"Welcome, User 54\"\n * ```\n */\nexport function lazy_guard(requirement, consequence, alternative) {\n  if (requirement) {\n    return consequence();\n  } else {\n    return alternative();\n  }\n}\n","export class CustomType {\n  withFields(fields) {\n    let properties = Object.keys(this).map((label) =>\n      label in fields ? fields[label] : this[label],\n    );\n    return new this.constructor(...properties);\n  }\n}\n\nexport class List {\n  static fromArray(array, tail) {\n    let t = tail || new Empty();\n    for (let i = array.length - 1; i >= 0; --i) {\n      t = new NonEmpty(array[i], t);\n    }\n    return t;\n  }\n\n  [Symbol.iterator]() {\n    return new ListIterator(this);\n  }\n\n  toArray() {\n    return [...this];\n  }\n\n  atLeastLength(desired) {\n    let current = this;\n    while (desired-- > 0 && current) current = current.tail;\n    return current !== undefined;\n  }\n\n  hasLength(desired) {\n    let current = this;\n    while (desired-- > 0 && current) current = current.tail;\n    return desired === -1 && current instanceof Empty;\n  }\n\n  countLength() {\n    let current = this;\n    let length = 0;\n    while (current) {\n      current = current.tail;\n      length++;\n    }\n    return length - 1;\n  }\n}\n\nexport function prepend(element, tail) {\n  return new NonEmpty(element, tail);\n}\n\nexport function toList(elements, tail) {\n  return List.fromArray(elements, tail);\n}\n\nclass ListIterator {\n  #current;\n\n  constructor(current) {\n    this.#current = current;\n  }\n\n  next() {\n    if (this.#current instanceof Empty) {\n      return { done: true };\n    } else {\n      let { head, tail } = this.#current;\n      this.#current = tail;\n      return { value: head, done: false };\n    }\n  }\n}\n\nexport class Empty extends List {}\nexport const List$Empty = () => new Empty();\nexport const List$isEmpty = (value) => value instanceof Empty;\n\nexport class NonEmpty extends List {\n  constructor(head, tail) {\n    super();\n    this.head = head;\n    this.tail = tail;\n  }\n}\nexport const List$NonEmpty = (head, tail) => new NonEmpty(head, tail);\nexport const List$isNonEmpty = (value) => value instanceof NonEmpty;\n\nexport const List$NonEmpty$first = (value) => value.head;\nexport const List$NonEmpty$rest = (value) => value.tail;\n\n/**\n * A bit array is a contiguous sequence of bits similar to Erlang's Binary type.\n */\nexport class BitArray {\n  /**\n   * The size in bits of this bit array's data.\n   *\n   * @type {number}\n   */\n  bitSize;\n\n  /**\n   * The size in bytes of this bit array's data. If this bit array doesn't store\n   * a whole number of bytes then this value is rounded up.\n   *\n   * @type {number}\n   */\n  byteSize;\n\n  /**\n   * The number of unused high bits in the first byte of this bit array's\n   * buffer prior to the start of its data. The value of any unused high bits is\n   * undefined.\n   *\n   * The bit offset will be in the range 0-7.\n   *\n   * @type {number}\n   */\n  bitOffset;\n\n  /**\n   * The raw bytes that hold this bit array's data.\n   *\n   * If `bitOffset` is not zero then there are unused high bits in the first\n   * byte of this buffer.\n   *\n   * If `bitOffset + bitSize` is not a multiple of 8 then there are unused low\n   * bits in the last byte of this buffer.\n   *\n   * @type {Uint8Array}\n   */\n  rawBuffer;\n\n  /**\n   * Constructs a new bit array from a `Uint8Array`, an optional size in\n   * bits, and an optional bit offset.\n   *\n   * If no bit size is specified it is taken as `buffer.length * 8`, i.e. all\n   * bytes in the buffer make up the new bit array's data.\n   *\n   * If no bit offset is specified it defaults to zero, i.e. there are no unused\n   * high bits in the first byte of the buffer.\n   *\n   * @param {Uint8Array} buffer\n   * @param {number} [bitSize]\n   * @param {number} [bitOffset]\n   */\n  constructor(buffer, bitSize, bitOffset) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw globalThis.Error(\n        \"BitArray can only be constructed from a Uint8Array\",\n      );\n    }\n\n    this.bitSize = bitSize ?? buffer.length * 8;\n    this.byteSize = Math.trunc((this.bitSize + 7) / 8);\n    this.bitOffset = bitOffset ?? 0;\n\n    // Validate the bit size\n    if (this.bitSize < 0) {\n      throw globalThis.Error(`BitArray bit size is invalid: ${this.bitSize}`);\n    }\n\n    // Validate the bit offset\n    if (this.bitOffset < 0 || this.bitOffset > 7) {\n      throw globalThis.Error(\n        `BitArray bit offset is invalid: ${this.bitOffset}`,\n      );\n    }\n\n    // Validate the length of the buffer\n    if (buffer.length !== Math.trunc((this.bitOffset + this.bitSize + 7) / 8)) {\n      throw globalThis.Error(\"BitArray buffer length is invalid\");\n    }\n\n    this.rawBuffer = buffer;\n  }\n\n  /**\n   * Returns a specific byte in this bit array. If the byte index is out of\n   * range then `undefined` is returned.\n   *\n   * When returning the final byte of a bit array with a bit size that's not a\n   * multiple of 8, the content of the unused low bits are undefined.\n   *\n   * @param {number} index\n   * @returns {number | undefined}\n   */\n  byteAt(index) {\n    if (index < 0 || index >= this.byteSize) {\n      return undefined;\n    }\n\n    return bitArrayByteAt(this.rawBuffer, this.bitOffset, index);\n  }\n\n  equals(other) {\n    if (this.bitSize !== other.bitSize) {\n      return false;\n    }\n\n    const wholeByteCount = Math.trunc(this.bitSize / 8);\n\n    // If both bit offsets are zero do a byte-aligned equality check which is\n    // faster\n    if (this.bitOffset === 0 && other.bitOffset === 0) {\n      // Compare any whole bytes\n      for (let i = 0; i < wholeByteCount; i++) {\n        if (this.rawBuffer[i] !== other.rawBuffer[i]) {\n          return false;\n        }\n      }\n\n      // Compare any trailing bits, excluding unused low bits\n      const trailingBitsCount = this.bitSize % 8;\n      if (trailingBitsCount) {\n        const unusedLowBitCount = 8 - trailingBitsCount;\n        if (\n          this.rawBuffer[wholeByteCount] >> unusedLowBitCount !==\n          other.rawBuffer[wholeByteCount] >> unusedLowBitCount\n        ) {\n          return false;\n        }\n      }\n    } else {\n      // Compare any whole bytes\n      for (let i = 0; i < wholeByteCount; i++) {\n        const a = bitArrayByteAt(this.rawBuffer, this.bitOffset, i);\n        const b = bitArrayByteAt(other.rawBuffer, other.bitOffset, i);\n\n        if (a !== b) {\n          return false;\n        }\n      }\n\n      // Compare any trailing bits\n      const trailingBitsCount = this.bitSize % 8;\n      if (trailingBitsCount) {\n        const a = bitArrayByteAt(\n          this.rawBuffer,\n          this.bitOffset,\n          wholeByteCount,\n        );\n        const b = bitArrayByteAt(\n          other.rawBuffer,\n          other.bitOffset,\n          wholeByteCount,\n        );\n\n        const unusedLowBitCount = 8 - trailingBitsCount;\n        if (a >> unusedLowBitCount !== b >> unusedLowBitCount) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns this bit array's internal buffer.\n   *\n   * @deprecated Use `BitArray.byteAt()` or `BitArray.rawBuffer` instead.\n   *\n   * @returns {Uint8Array}\n   */\n  get buffer() {\n    bitArrayPrintDeprecationWarning(\n      \"buffer\",\n      \"Use BitArray.byteAt() or BitArray.rawBuffer instead\",\n    );\n\n    if (this.bitOffset !== 0 || this.bitSize % 8 !== 0) {\n      throw new globalThis.Error(\n        \"BitArray.buffer does not support unaligned bit arrays\",\n      );\n    }\n\n    return this.rawBuffer;\n  }\n\n  /**\n   * Returns the length in bytes of this bit array's internal buffer.\n   *\n   * @deprecated Use `BitArray.bitSize` or `BitArray.byteSize` instead.\n   *\n   * @returns {number}\n   */\n  get length() {\n    bitArrayPrintDeprecationWarning(\n      \"length\",\n      \"Use BitArray.bitSize or BitArray.byteSize instead\",\n    );\n\n    if (this.bitOffset !== 0 || this.bitSize % 8 !== 0) {\n      throw new globalThis.Error(\n        \"BitArray.length does not support unaligned bit arrays\",\n      );\n    }\n\n    return this.rawBuffer.length;\n  }\n}\n\nexport const BitArray$BitArray = (buffer, bitSize, bitOffset) =>\n  new BitArray(buffer, bitSize, bitOffset);\n\n/**\n * Returns the nth byte in the given buffer, after applying the specified bit\n * offset. If the index is out of bounds then zero is returned.\n *\n * @param {Uint8Array} buffer\n * @param {number} bitOffset\n * @param {number} index\n * @returns {number}\n */\nfunction bitArrayByteAt(buffer, bitOffset, index) {\n  if (bitOffset === 0) {\n    return buffer[index] ?? 0;\n  } else {\n    const a = (buffer[index] << bitOffset) & 0xff;\n    const b = buffer[index + 1] >> (8 - bitOffset);\n\n    return a | b;\n  }\n}\n\nexport class UtfCodepoint {\n  constructor(value) {\n    this.value = value;\n  }\n}\n\nconst isBitArrayDeprecationMessagePrinted = {};\nfunction bitArrayPrintDeprecationWarning(name, message) {\n  if (isBitArrayDeprecationMessagePrinted[name]) {\n    return;\n  }\n\n  console.warn(\n    `Deprecated BitArray.${name} property used in JavaScript FFI code. ${message}.`,\n  );\n\n  isBitArrayDeprecationMessagePrinted[name] = true;\n}\n\n/**\n * Slices a bit array to produce a new bit array. If `end` is not supplied then\n * all bits from `start` onward are returned.\n *\n * If the slice is out of bounds then an exception is thrown.\n *\n * @param {BitArray} bitArray\n * @param {number} start\n * @param {number} [end]\n * @returns {BitArray}\n */\nexport function bitArraySlice(bitArray, start, end) {\n  end ??= bitArray.bitSize;\n\n  bitArrayValidateRange(bitArray, start, end);\n\n  // Handle zero-length slices\n  if (start === end) {\n    return new BitArray(new Uint8Array());\n  }\n\n  // Early return for slices that cover the whole bit array\n  if (start === 0 && end === bitArray.bitSize) {\n    return bitArray;\n  }\n\n  start += bitArray.bitOffset;\n  end += bitArray.bitOffset;\n\n  const startByteIndex = Math.trunc(start / 8);\n  const endByteIndex = Math.trunc((end + 7) / 8);\n  const byteLength = endByteIndex - startByteIndex;\n\n  // Avoid creating a new Uint8Array if the view of the underlying ArrayBuffer\n  // is the same. This can occur when slicing off just the first or last bit of\n  // a bit array, i.e. when only the bit offset or bit size need to be updated.\n  let buffer;\n  if (startByteIndex === 0 && byteLength === bitArray.rawBuffer.byteLength) {\n    buffer = bitArray.rawBuffer;\n  } else {\n    buffer = new Uint8Array(\n      bitArray.rawBuffer.buffer,\n      bitArray.rawBuffer.byteOffset + startByteIndex,\n      byteLength,\n    );\n  }\n\n  return new BitArray(buffer, end - start, start % 8);\n}\n\n/**\n * Interprets a slice of this bit array as a floating point number, either\n * 32-bit or 64-bit, with the specified endianness.\n *\n * The value of `end - start` must be exactly 32 or 64, otherwise an exception\n * will be thrown.\n *\n * @param {BitArray} bitArray\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @returns {number}\n */\nexport function bitArraySliceToFloat(bitArray, start, end, isBigEndian) {\n  bitArrayValidateRange(bitArray, start, end);\n\n  const floatSize = end - start;\n\n  // Check size is valid\n  if (floatSize !== 16 && floatSize !== 32 && floatSize !== 64) {\n    const msg =\n      `Sized floats must be 16-bit, 32-bit or 64-bit, got size of ` +\n      `${floatSize} bits`;\n    throw new globalThis.Error(msg);\n  }\n\n  start += bitArray.bitOffset;\n\n  const isStartByteAligned = start % 8 === 0;\n\n  // If the bit range is byte aligned then the float can be read directly out\n  // of the existing buffer\n  if (isStartByteAligned) {\n    const view = new DataView(\n      bitArray.rawBuffer.buffer,\n      bitArray.rawBuffer.byteOffset + start / 8,\n    );\n\n    if (floatSize === 64) {\n      return view.getFloat64(0, !isBigEndian);\n    } else if (floatSize === 32) {\n      return view.getFloat32(0, !isBigEndian);\n    } else if (floatSize === 16) {\n      return fp16UintToNumber(view.getUint16(0, !isBigEndian));\n    }\n  }\n\n  // Copy the unaligned bytes into an aligned array so a DataView can be used\n  const alignedBytes = new Uint8Array(floatSize / 8);\n  const byteOffset = Math.trunc(start / 8);\n  for (let i = 0; i < alignedBytes.length; i++) {\n    alignedBytes[i] = bitArrayByteAt(\n      bitArray.rawBuffer,\n      start % 8,\n      byteOffset + i,\n    );\n  }\n\n  // Read the float out of the aligned buffer\n  const view = new DataView(alignedBytes.buffer);\n  if (floatSize === 64) {\n    return view.getFloat64(0, !isBigEndian);\n  } else if (floatSize === 32) {\n    return view.getFloat32(0, !isBigEndian);\n  } else {\n    return fp16UintToNumber(view.getUint16(0, !isBigEndian));\n  }\n}\n\n/**\n * Interprets a slice of this bit array as a signed or unsigned integer with the\n * specified endianness.\n *\n * @param {BitArray} bitArray\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nexport function bitArraySliceToInt(\n  bitArray,\n  start,\n  end,\n  isBigEndian,\n  isSigned,\n) {\n  bitArrayValidateRange(bitArray, start, end);\n\n  if (start === end) {\n    return 0;\n  }\n\n  start += bitArray.bitOffset;\n  end += bitArray.bitOffset;\n\n  const isStartByteAligned = start % 8 === 0;\n  const isEndByteAligned = end % 8 === 0;\n\n  // If the slice is byte-aligned then there is no need to handle unaligned\n  // slices, meaning a simpler and faster implementation can be used instead\n  if (isStartByteAligned && isEndByteAligned) {\n    return intFromAlignedSlice(\n      bitArray,\n      start / 8,\n      end / 8,\n      isBigEndian,\n      isSigned,\n    );\n  }\n\n  const size = end - start;\n\n  const startByteIndex = Math.trunc(start / 8);\n  const endByteIndex = Math.trunc((end - 1) / 8);\n\n  // Handle the case of the slice being completely contained in a single byte\n  if (startByteIndex == endByteIndex) {\n    const mask = 0xff >> start % 8;\n    const unusedLowBitCount = (8 - (end % 8)) % 8;\n\n    let value =\n      (bitArray.rawBuffer[startByteIndex] & mask) >> unusedLowBitCount;\n\n    // For signed integers, if the high bit is set reinterpret as two's\n    // complement\n    if (isSigned) {\n      const highBit = 2 ** (size - 1);\n      if (value >= highBit) {\n        value -= highBit * 2;\n      }\n    }\n\n    return value;\n  }\n\n  // The integer value to be read is not aligned and crosses at least one byte\n  // boundary in the input array\n\n  if (size <= 53) {\n    return intFromUnalignedSliceUsingNumber(\n      bitArray.rawBuffer,\n      start,\n      end,\n      isBigEndian,\n      isSigned,\n    );\n  } else {\n    return intFromUnalignedSliceUsingBigInt(\n      bitArray.rawBuffer,\n      start,\n      end,\n      isBigEndian,\n      isSigned,\n    );\n  }\n}\n\n/**\n * Joins the given segments into a new bit array, tightly packing them together.\n * Each segment must be one of the following types:\n *\n * - A `number`: A single byte value in the range 0-255. Values outside this\n *   range will be wrapped.\n * - A `Uint8Array`: A sequence of byte values of any length.\n * - A `BitArray`: A sequence of bits of any length, which may not be byte\n *   aligned.\n *\n * The bit size of the returned bit array will be the sum of the size in bits\n * of the input segments.\n *\n * @param {(number | Uint8Array | BitArray)[]} segments\n * @returns {BitArray}\n */\nexport function toBitArray(segments) {\n  if (segments.length === 0) {\n    return new BitArray(new Uint8Array());\n  }\n\n  if (segments.length === 1) {\n    const segment = segments[0];\n\n    // When there is a single BitArray segment it can be returned as-is\n    if (segment instanceof BitArray) {\n      return segment;\n    }\n\n    // When there is a single Uint8Array segment, pass it directly to the bit\n    // array constructor to avoid a copy\n    if (segment instanceof Uint8Array) {\n      return new BitArray(segment);\n    }\n\n    return new BitArray(new Uint8Array(/** @type {number[]} */ (segments)));\n  }\n\n  // Count the total number of bits and check if all segments are numbers, i.e.\n  // single bytes\n  let bitSize = 0;\n  let areAllSegmentsNumbers = true;\n  for (const segment of segments) {\n    if (segment instanceof BitArray) {\n      bitSize += segment.bitSize;\n      areAllSegmentsNumbers = false;\n    } else if (segment instanceof Uint8Array) {\n      bitSize += segment.byteLength * 8;\n      areAllSegmentsNumbers = false;\n    } else {\n      bitSize += 8;\n    }\n  }\n\n  // If all segments are numbers then pass the segments array directly to the\n  // Uint8Array constructor\n  if (areAllSegmentsNumbers) {\n    return new BitArray(new Uint8Array(/** @type {number[]} */ (segments)));\n  }\n\n  // Pack the segments into a Uint8Array\n  const buffer = new Uint8Array(Math.trunc((bitSize + 7) / 8));\n\n  // The current write position in bits into the above array. Byte-aligned\n  // segments, i.e. when the cursor is a multiple of 8, are able to be processed\n  // faster due to being able to copy bytes directly.\n  let cursor = 0;\n\n  for (let segment of segments) {\n    const isCursorByteAligned = cursor % 8 === 0;\n\n    if (segment instanceof BitArray) {\n      if (isCursorByteAligned && segment.bitOffset === 0) {\n        buffer.set(segment.rawBuffer, cursor / 8);\n        cursor += segment.bitSize;\n\n        // Zero any unused bits in the last byte of the buffer. Their content is\n        // undefined and shouldn't be included in the output.\n        const trailingBitsCount = segment.bitSize % 8;\n        if (trailingBitsCount !== 0) {\n          const lastByteIndex = Math.trunc(cursor / 8);\n          buffer[lastByteIndex] >>= 8 - trailingBitsCount;\n          buffer[lastByteIndex] <<= 8 - trailingBitsCount;\n        }\n      } else {\n        appendUnalignedBits(\n          segment.rawBuffer,\n          segment.bitSize,\n          segment.bitOffset,\n        );\n      }\n    } else if (segment instanceof Uint8Array) {\n      if (isCursorByteAligned) {\n        buffer.set(segment, cursor / 8);\n        cursor += segment.byteLength * 8;\n      } else {\n        appendUnalignedBits(segment, segment.byteLength * 8, 0);\n      }\n    } else {\n      if (isCursorByteAligned) {\n        buffer[cursor / 8] = segment;\n        cursor += 8;\n      } else {\n        appendUnalignedBits(new Uint8Array([segment]), 8, 0);\n      }\n    }\n  }\n\n  function appendUnalignedBits(unalignedBits, size, offset) {\n    if (size === 0) {\n      return;\n    }\n\n    const byteSize = Math.trunc(size + 7 / 8);\n\n    const highBitsCount = cursor % 8;\n    const lowBitsCount = 8 - highBitsCount;\n\n    let byteIndex = Math.trunc(cursor / 8);\n\n    for (let i = 0; i < byteSize; i++) {\n      let byte = bitArrayByteAt(unalignedBits, offset, i);\n\n      // If this is a partial byte then zero out the trailing bits as their\n      // content is undefined and shouldn't be included in the output\n      if (size < 8) {\n        byte >>= 8 - size;\n        byte <<= 8 - size;\n      }\n\n      // Copy the high bits of the input byte to the low bits of the current\n      // output byte\n      buffer[byteIndex] |= byte >> highBitsCount;\n\n      let appendedBitsCount = size - Math.max(0, size - lowBitsCount);\n      size -= appendedBitsCount;\n      cursor += appendedBitsCount;\n\n      if (size === 0) {\n        break;\n      }\n\n      // Copy the low bits of the input byte to the high bits of the next output\n      // byte\n      buffer[++byteIndex] = byte << lowBitsCount;\n      appendedBitsCount = size - Math.max(0, size - highBitsCount);\n      size -= appendedBitsCount;\n      cursor += appendedBitsCount;\n    }\n  }\n\n  return new BitArray(buffer, bitSize);\n}\n\n/**\n * Encodes a floating point value into a `Uint8Array`. This is used to create\n * float segments that are part of bit array expressions.\n *\n * @param {number} value\n * @param {number} size\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nexport function sizedFloat(value, size, isBigEndian) {\n  if (size !== 16 && size !== 32 && size !== 64) {\n    const msg = `Sized floats must be 16-bit, 32-bit or 64-bit, got size of ${size} bits`;\n    throw new globalThis.Error(msg);\n  }\n\n  if (size === 16) {\n    return numberToFp16Uint(value, isBigEndian);\n  }\n\n  const buffer = new Uint8Array(size / 8);\n\n  const view = new DataView(buffer.buffer);\n\n  if (size == 64) {\n    view.setFloat64(0, value, !isBigEndian);\n  } else {\n    view.setFloat32(0, value, !isBigEndian);\n  }\n\n  return buffer;\n}\n\n/**\n * Encodes an integer value into a `Uint8Array`, or a `BitArray` if the size in\n * bits is not a multiple of 8. This is used to create integer segments used in\n * bit array expressions.\n *\n * @param {number} value\n * @param {number} size\n * @param {boolean} isBigEndian\n * @returns {Uint8Array | BitArray}\n */\nexport function sizedInt(value, size, isBigEndian) {\n  if (size <= 0) {\n    return new Uint8Array();\n  }\n\n  // Fast path when size is 8 bits. This relies on the rounding behavior of the\n  // Uint8Array constructor.\n  if (size === 8) {\n    return new Uint8Array([value]);\n  }\n\n  // Fast path when size is less than 8 bits: shift the value up to the high\n  // bits\n  if (size < 8) {\n    value <<= 8 - size;\n    return new BitArray(new Uint8Array([value]), size);\n  }\n\n  // Allocate output buffer\n  const buffer = new Uint8Array(Math.trunc((size + 7) / 8));\n\n  // The number of trailing bits in the final byte. Will be zero if the size is\n  // an exact number of bytes.\n  const trailingBitsCount = size % 8;\n\n  // The number of unused bits in the final byte of the buffer\n  const unusedBitsCount = 8 - trailingBitsCount;\n\n  // For output sizes not exceeding 32 bits the number type is used. For larger\n  // output sizes the BigInt type is needed.\n  //\n  // The code in each of these two paths must be kept in sync.\n  if (size <= 32) {\n    if (isBigEndian) {\n      let i = buffer.length - 1;\n\n      // Set the trailing bits at the end of the output buffer\n      if (trailingBitsCount) {\n        buffer[i--] = (value << unusedBitsCount) & 0xff;\n        value >>= trailingBitsCount;\n      }\n\n      for (; i >= 0; i--) {\n        buffer[i] = value;\n        value >>= 8;\n      }\n    } else {\n      let i = 0;\n\n      const wholeByteCount = Math.trunc(size / 8);\n      for (; i < wholeByteCount; i++) {\n        buffer[i] = value;\n        value >>= 8;\n      }\n\n      // Set the trailing bits at the end of the output buffer\n      if (trailingBitsCount) {\n        buffer[i] = value << unusedBitsCount;\n      }\n    }\n  } else {\n    const bigTrailingBitsCount = BigInt(trailingBitsCount);\n    const bigUnusedBitsCount = BigInt(unusedBitsCount);\n\n    let bigValue = BigInt(value);\n\n    if (isBigEndian) {\n      let i = buffer.length - 1;\n\n      // Set the trailing bits at the end of the output buffer\n      if (trailingBitsCount) {\n        buffer[i--] = Number(bigValue << bigUnusedBitsCount);\n        bigValue >>= bigTrailingBitsCount;\n      }\n\n      for (; i >= 0; i--) {\n        buffer[i] = Number(bigValue);\n        bigValue >>= 8n;\n      }\n    } else {\n      let i = 0;\n\n      const wholeByteCount = Math.trunc(size / 8);\n      for (; i < wholeByteCount; i++) {\n        buffer[i] = Number(bigValue);\n        bigValue >>= 8n;\n      }\n\n      // Set the trailing bits at the end of the output buffer\n      if (trailingBitsCount) {\n        buffer[i] = Number(bigValue << bigUnusedBitsCount);\n      }\n    }\n  }\n\n  // Integers that aren't a whole number of bytes are returned as a BitArray so\n  // their size in bits is tracked\n  if (trailingBitsCount) {\n    return new BitArray(buffer, size);\n  }\n\n  return buffer;\n}\n\n/**\n * Reads an aligned slice of any size as an integer.\n *\n * @param {BitArray} bitArray\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nfunction intFromAlignedSlice(bitArray, start, end, isBigEndian, isSigned) {\n  const byteSize = end - start;\n\n  if (byteSize <= 6) {\n    return intFromAlignedSliceUsingNumber(\n      bitArray.rawBuffer,\n      start,\n      end,\n      isBigEndian,\n      isSigned,\n    );\n  } else {\n    return intFromAlignedSliceUsingBigInt(\n      bitArray.rawBuffer,\n      start,\n      end,\n      isBigEndian,\n      isSigned,\n    );\n  }\n}\n\n/**\n * Reads an aligned slice up to 48 bits in size as an integer. Uses the\n * JavaScript `number` type internally.\n *\n * @param {Uint8Array} buffer\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nfunction intFromAlignedSliceUsingNumber(\n  buffer,\n  start,\n  end,\n  isBigEndian,\n  isSigned,\n) {\n  const byteSize = end - start;\n\n  let value = 0;\n\n  // Read bytes as an unsigned integer\n  if (isBigEndian) {\n    for (let i = start; i < end; i++) {\n      value *= 256;\n      value += buffer[i];\n    }\n  } else {\n    for (let i = end - 1; i >= start; i--) {\n      value *= 256;\n      value += buffer[i];\n    }\n  }\n\n  // For signed integers, if the high bit is set reinterpret as two's\n  // complement\n  if (isSigned) {\n    const highBit = 2 ** (byteSize * 8 - 1);\n    if (value >= highBit) {\n      value -= highBit * 2;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Reads an aligned slice of any size as an integer. Uses the JavaScript\n * `BigInt` type internally.\n *\n * @param {Uint8Array} buffer\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nfunction intFromAlignedSliceUsingBigInt(\n  buffer,\n  start,\n  end,\n  isBigEndian,\n  isSigned,\n) {\n  const byteSize = end - start;\n\n  let value = 0n;\n\n  // Read bytes as an unsigned integer value\n  if (isBigEndian) {\n    for (let i = start; i < end; i++) {\n      value *= 256n;\n      value += BigInt(buffer[i]);\n    }\n  } else {\n    for (let i = end - 1; i >= start; i--) {\n      value *= 256n;\n      value += BigInt(buffer[i]);\n    }\n  }\n\n  // For signed integers, if the high bit is set reinterpret as two's\n  // complement\n  if (isSigned) {\n    const highBit = 1n << BigInt(byteSize * 8 - 1);\n    if (value >= highBit) {\n      value -= highBit * 2n;\n    }\n  }\n\n  // Convert the result into a JS number. This may cause quantizing/error on\n  // values outside JavaScript's safe integer range.\n  return Number(value);\n}\n\n/**\n * Reads an unaligned slice up to 53 bits in size as an integer. Uses the\n * JavaScript `number` type internally.\n *\n * This function assumes that the slice crosses at least one byte boundary in\n * the input.\n *\n * @param {Uint8Array} buffer\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nfunction intFromUnalignedSliceUsingNumber(\n  buffer,\n  start,\n  end,\n  isBigEndian,\n  isSigned,\n) {\n  const isStartByteAligned = start % 8 === 0;\n\n  let size = end - start;\n  let byteIndex = Math.trunc(start / 8);\n\n  let value = 0;\n\n  if (isBigEndian) {\n    // Read any leading bits\n    if (!isStartByteAligned) {\n      const leadingBitsCount = 8 - (start % 8);\n      value = buffer[byteIndex++] & ((1 << leadingBitsCount) - 1);\n      size -= leadingBitsCount;\n    }\n\n    // Read any whole bytes\n    while (size >= 8) {\n      value *= 256;\n      value += buffer[byteIndex++];\n      size -= 8;\n    }\n\n    // Read any trailing bits\n    if (size > 0) {\n      value *= 2 ** size;\n      value += buffer[byteIndex] >> (8 - size);\n    }\n  } else {\n    // For little endian, if the start is aligned then whole bytes can be read\n    // directly out of the input array, with the trailing bits handled at the\n    // end\n    if (isStartByteAligned) {\n      let size = end - start;\n      let scale = 1;\n\n      // Read whole bytes\n      while (size >= 8) {\n        value += buffer[byteIndex++] * scale;\n        scale *= 256;\n        size -= 8;\n      }\n\n      // Read trailing bits\n      value += (buffer[byteIndex] >> (8 - size)) * scale;\n    } else {\n      // Read little endian data where the start is not byte-aligned. This is\n      // done by reading whole bytes that cross a byte boundary in the input\n      // data, then reading any trailing bits.\n\n      const highBitsCount = start % 8;\n      const lowBitsCount = 8 - highBitsCount;\n\n      let size = end - start;\n      let scale = 1;\n\n      // Extract whole bytes\n      while (size >= 8) {\n        const byte =\n          (buffer[byteIndex] << highBitsCount) |\n          (buffer[byteIndex + 1] >> lowBitsCount);\n\n        value += (byte & 0xff) * scale;\n\n        scale *= 256;\n        size -= 8;\n        byteIndex++;\n      }\n\n      // Read any trailing bits. These trailing bits may cross a byte boundary\n      // in the input buffer.\n      if (size > 0) {\n        const lowBitsUsed = size - Math.max(0, size - lowBitsCount);\n\n        let trailingByte =\n          (buffer[byteIndex] & ((1 << lowBitsCount) - 1)) >>\n          (lowBitsCount - lowBitsUsed);\n\n        size -= lowBitsUsed;\n\n        if (size > 0) {\n          trailingByte *= 2 ** size;\n          trailingByte += buffer[byteIndex + 1] >> (8 - size);\n        }\n\n        value += trailingByte * scale;\n      }\n    }\n  }\n\n  // For signed integers, if the high bit is set reinterpret as two's\n  // complement\n  if (isSigned) {\n    const highBit = 2 ** (end - start - 1);\n    if (value >= highBit) {\n      value -= highBit * 2;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Reads an unaligned slice of any size as an integer. Uses the JavaScript\n * `BigInt` type internally.\n *\n * This function assumes that the slice crosses at least one byte boundary in\n * the input.\n *\n * @param {Uint8Array} buffer\n * @param {number} start\n * @param {number} end\n * @param {boolean} isBigEndian\n * @param {boolean} isSigned\n * @returns {number}\n */\nfunction intFromUnalignedSliceUsingBigInt(\n  buffer,\n  start,\n  end,\n  isBigEndian,\n  isSigned,\n) {\n  const isStartByteAligned = start % 8 === 0;\n\n  let size = end - start;\n  let byteIndex = Math.trunc(start / 8);\n\n  let value = 0n;\n\n  if (isBigEndian) {\n    // Read any leading bits\n    if (!isStartByteAligned) {\n      const leadingBitsCount = 8 - (start % 8);\n      value = BigInt(buffer[byteIndex++] & ((1 << leadingBitsCount) - 1));\n      size -= leadingBitsCount;\n    }\n\n    // Read any whole bytes\n    while (size >= 8) {\n      value *= 256n;\n      value += BigInt(buffer[byteIndex++]);\n      size -= 8;\n    }\n\n    // Read any trailing bits\n    if (size > 0) {\n      value <<= BigInt(size);\n      value += BigInt(buffer[byteIndex] >> (8 - size));\n    }\n  } else {\n    // For little endian, if the start is aligned then whole bytes can be read\n    // directly out of the input array, with the trailing bits handled at the\n    // end\n    if (isStartByteAligned) {\n      let size = end - start;\n      let shift = 0n;\n\n      // Read whole bytes\n      while (size >= 8) {\n        value += BigInt(buffer[byteIndex++]) << shift;\n        shift += 8n;\n        size -= 8;\n      }\n\n      // Read trailing bits\n      value += BigInt(buffer[byteIndex] >> (8 - size)) << shift;\n    } else {\n      // Read little endian data where the start is not byte-aligned. This is\n      // done by reading whole bytes that cross a byte boundary in the input\n      // data, then reading any trailing bits.\n\n      const highBitsCount = start % 8;\n      const lowBitsCount = 8 - highBitsCount;\n\n      let size = end - start;\n      let shift = 0n;\n\n      // Extract whole bytes\n      while (size >= 8) {\n        const byte =\n          (buffer[byteIndex] << highBitsCount) |\n          (buffer[byteIndex + 1] >> lowBitsCount);\n\n        value += BigInt(byte & 0xff) << shift;\n\n        shift += 8n;\n        size -= 8;\n        byteIndex++;\n      }\n\n      // Read any trailing bits. These trailing bits may cross a byte boundary\n      // in the input buffer.\n      if (size > 0) {\n        const lowBitsUsed = size - Math.max(0, size - lowBitsCount);\n\n        let trailingByte =\n          (buffer[byteIndex] & ((1 << lowBitsCount) - 1)) >>\n          (lowBitsCount - lowBitsUsed);\n\n        size -= lowBitsUsed;\n\n        if (size > 0) {\n          trailingByte <<= size;\n          trailingByte += buffer[byteIndex + 1] >> (8 - size);\n        }\n\n        value += BigInt(trailingByte) << shift;\n      }\n    }\n  }\n\n  // For signed integers, if the high bit is set reinterpret as two's\n  // complement\n  if (isSigned) {\n    const highBit = 2n ** BigInt(end - start - 1);\n    if (value >= highBit) {\n      value -= highBit * 2n;\n    }\n  }\n\n  // Convert the result into a JS number. This may cause quantizing/error on\n  // values outside JavaScript's safe integer range.\n  return Number(value);\n}\n\n/**\n * Interprets a 16-bit unsigned integer value as a 16-bit floating point value.\n *\n * @param {number} intValue\n * @returns {number}\n */\nfunction fp16UintToNumber(intValue) {\n  const sign = intValue >= 0x8000 ? -1 : 1;\n  const exponent = (intValue & 0x7c00) >> 10;\n  const fraction = intValue & 0x03ff;\n\n  let value;\n  if (exponent === 0) {\n    value = 6.103515625e-5 * (fraction / 0x400);\n  } else if (exponent === 0x1f) {\n    value = fraction === 0 ? Infinity : NaN;\n  } else {\n    value = Math.pow(2, exponent - 15) * (1 + fraction / 0x400);\n  }\n\n  return sign * value;\n}\n\n/**\n * Converts a floating point number to bytes for a 16-bit floating point value.\n *\n * @param {number} intValue\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nfunction numberToFp16Uint(value, isBigEndian) {\n  const buffer = new Uint8Array(2);\n\n  if (isNaN(value)) {\n    buffer[1] = 0x7e;\n  } else if (value === Infinity) {\n    buffer[1] = 0x7c;\n  } else if (value === -Infinity) {\n    buffer[1] = 0xfc;\n  } else if (value === 0) {\n    // Both values are already zero\n  } else {\n    const sign = value < 0 ? 1 : 0;\n    value = Math.abs(value);\n\n    let exponent = Math.floor(Math.log2(value));\n    let fraction = value / Math.pow(2, exponent) - 1;\n\n    exponent += 15;\n\n    if (exponent <= 0) {\n      exponent = 0;\n      fraction = value / Math.pow(2, -14);\n    } else if (exponent >= 31) {\n      exponent = 31;\n      fraction = 0;\n    }\n\n    fraction = Math.round(fraction * 1024);\n\n    buffer[1] =\n      (sign << 7) | ((exponent & 0x1f) << 2) | ((fraction >> 8) & 0x03);\n    buffer[0] = fraction & 0xff;\n  }\n\n  if (isBigEndian) {\n    const a = buffer[0];\n    buffer[0] = buffer[1];\n    buffer[1] = a;\n  }\n\n  return buffer;\n}\n\n/**\n * Throws an exception if the given start and end values are out of bounds for\n * a bit array.\n *\n * @param {BitArray} bitArray\n * @param {number} start\n * @param {number} end\n */\nfunction bitArrayValidateRange(bitArray, start, end) {\n  if (\n    start < 0 ||\n    start > bitArray.bitSize ||\n    end < start ||\n    end > bitArray.bitSize\n  ) {\n    const msg =\n      `Invalid bit array slice: start = ${start}, end = ${end}, ` +\n      `bit size = ${bitArray.bitSize}`;\n    throw new globalThis.Error(msg);\n  }\n}\n\n/** @type {TextEncoder | undefined} */\nlet utf8Encoder;\n\n/**\n * Returns the UTF-8 bytes for a string.\n *\n * @param {string} string\n * @returns {Uint8Array}\n */\nexport function stringBits(string) {\n  utf8Encoder ??= new TextEncoder();\n  return utf8Encoder.encode(string);\n}\n\n/**\n * Returns the UTF-8 bytes for a single UTF codepoint.\n *\n * @param {UtfCodepoint} codepoint\n * @returns {Uint8Array}\n */\nexport function codepointBits(codepoint) {\n  return stringBits(String.fromCodePoint(codepoint.value));\n}\n\n/**\n * Returns the UTF-16 bytes for a string.\n *\n * @param {string} string\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nexport function stringToUtf16(string, isBigEndian) {\n  const buffer = new ArrayBuffer(string.length * 2);\n  const bufferView = new DataView(buffer);\n\n  for (let i = 0; i < string.length; i++) {\n    bufferView.setUint16(i * 2, string.charCodeAt(i), !isBigEndian);\n  }\n\n  return new Uint8Array(buffer);\n}\n\n/**\n * Returns the UTF-16 bytes for a single UTF codepoint.\n *\n * @param {UtfCodepoint} codepoint\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nexport function codepointToUtf16(codepoint, isBigEndian) {\n  return stringToUtf16(String.fromCodePoint(codepoint.value), isBigEndian);\n}\n\n/**\n * Returns the UTF-32 bytes for a string.\n *\n * @param {string} string\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nexport function stringToUtf32(string, isBigEndian) {\n  const buffer = new ArrayBuffer(string.length * 4);\n  const bufferView = new DataView(buffer);\n  let length = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    const codepoint = string.codePointAt(i);\n\n    bufferView.setUint32(length * 4, codepoint, !isBigEndian);\n    length++;\n\n    if (codepoint > 0xffff) {\n      i++;\n    }\n  }\n\n  return new Uint8Array(buffer.slice(0, length * 4));\n}\n\n/**\n * Returns the UTF-32 bytes for a single UTF codepoint.\n *\n * @param {UtfCodepoint} codepoint\n * @param {boolean} isBigEndian\n * @returns {Uint8Array}\n */\nexport function codepointToUtf32(codepoint, isBigEndian) {\n  return stringToUtf32(String.fromCodePoint(codepoint.value), isBigEndian);\n}\n\nexport class Result extends CustomType {\n  static isResult(data) {\n    return data instanceof Result;\n  }\n}\n\nexport class Ok extends Result {\n  constructor(value) {\n    super();\n    this[0] = value;\n  }\n\n  isOk() {\n    return true;\n  }\n}\nexport const Result$Ok = (value) => new Ok(value);\nexport const Result$isOk = (value) => value instanceof Ok;\nexport const Result$Ok$0 = (value) => value[0];\n\nexport class Error extends Result {\n  constructor(detail) {\n    super();\n    this[0] = detail;\n  }\n\n  isOk() {\n    return false;\n  }\n}\nexport const Result$Error = (detail) => new Error(detail);\nexport const Result$isError = (value) => value instanceof Error;\nexport const Result$Error$0 = (value) => value[0];\n\nexport function isEqual(x, y) {\n  let values = [x, y];\n\n  while (values.length) {\n    let a = values.pop();\n    let b = values.pop();\n    if (a === b) continue;\n\n    if (!isObject(a) || !isObject(b)) return false;\n    let unequal =\n      !structurallyCompatibleObjects(a, b) ||\n      unequalDates(a, b) ||\n      unequalBuffers(a, b) ||\n      unequalArrays(a, b) ||\n      unequalMaps(a, b) ||\n      unequalSets(a, b) ||\n      unequalRegExps(a, b);\n    if (unequal) return false;\n\n    const proto = Object.getPrototypeOf(a);\n    if (proto !== null && typeof proto.equals === \"function\") {\n      try {\n        if (a.equals(b)) continue;\n        else return false;\n      } catch {}\n    }\n\n    let [keys, get] = getters(a);\n    const ka = keys(a);\n    const kb = keys(b);\n    if (ka.length !== kb.length) return false;\n    for (let k of ka) {\n      values.push(get(a, k), get(b, k));\n    }\n  }\n\n  return true;\n}\n\nfunction getters(object) {\n  if (object instanceof Map) {\n    return [(x) => x.keys(), (x, y) => x.get(y)];\n  } else {\n    let extra = object instanceof globalThis.Error ? [\"message\"] : [];\n    return [(x) => [...extra, ...Object.keys(x)], (x, y) => x[y]];\n  }\n}\n\nfunction unequalDates(a, b) {\n  return a instanceof Date && (a > b || a < b);\n}\n\nfunction unequalBuffers(a, b) {\n  return (\n    !(a instanceof BitArray) &&\n    a.buffer instanceof ArrayBuffer &&\n    a.BYTES_PER_ELEMENT &&\n    !(a.byteLength === b.byteLength && a.every((n, i) => n === b[i]))\n  );\n}\n\nfunction unequalArrays(a, b) {\n  return Array.isArray(a) && a.length !== b.length;\n}\n\nfunction unequalMaps(a, b) {\n  return a instanceof Map && a.size !== b.size;\n}\n\nfunction unequalSets(a, b) {\n  return (\n    a instanceof Set && (a.size != b.size || [...a].some((e) => !b.has(e)))\n  );\n}\n\nfunction unequalRegExps(a, b) {\n  return a instanceof RegExp && (a.source !== b.source || a.flags !== b.flags);\n}\n\nfunction isObject(a) {\n  return typeof a === \"object\" && a !== null;\n}\n\nfunction structurallyCompatibleObjects(a, b) {\n  if (typeof a !== \"object\" && typeof b !== \"object\" && (!a || !b))\n    return false;\n\n  let nonstructural = [Promise, WeakSet, WeakMap, Function];\n  if (nonstructural.some((c) => a instanceof c)) return false;\n\n  return a.constructor === b.constructor;\n}\n\nexport function remainderInt(a, b) {\n  if (b === 0) {\n    return 0;\n  } else {\n    return a % b;\n  }\n}\n\nexport function divideInt(a, b) {\n  return Math.trunc(divideFloat(a, b));\n}\n\nexport function divideFloat(a, b) {\n  if (b === 0) {\n    return 0;\n  } else {\n    return a / b;\n  }\n}\n\nexport function makeError(variant, file, module, line, fn, message, extra) {\n  let error = new globalThis.Error(message);\n  error.gleam_error = variant;\n  error.file = file;\n  error.module = module;\n  error.line = line;\n  error.function = fn;\n  // TODO: Remove this with Gleam v2.0.0\n  error.fn = fn;\n  for (let k in extra) error[k] = extra[k];\n  return error;\n}\n","//# sourceMappingURL=order.mjs.map\nimport { CustomType as $CustomType, isEqual } from \"../gleam.mjs\";\n\nexport class Lt extends $CustomType {}\nexport const Order$Lt = () => new Lt();\nexport const Order$isLt = (value) => value instanceof Lt;\n\nexport class Eq extends $CustomType {}\nexport const Order$Eq = () => new Eq();\nexport const Order$isEq = (value) => value instanceof Eq;\n\nexport class Gt extends $CustomType {}\nexport const Order$Gt = () => new Gt();\nexport const Order$isGt = (value) => value instanceof Gt;\n\n/**\n * Inverts an order, so less-than becomes greater-than and greater-than\n * becomes less-than.\n *\n * ## Examples\n *\n * ```gleam\n * negate(Lt)\n * // -> Gt\n * ```\n *\n * ```gleam\n * negate(Eq)\n * // -> Eq\n * ```\n *\n * ```gleam\n * negate(Gt)\n * // -> Lt\n * ```\n */\nexport function negate(order) {\n  if (order instanceof Lt) {\n    return new Gt();\n  } else if (order instanceof Eq) {\n    return order;\n  } else {\n    return new Lt();\n  }\n}\n\n/**\n * Produces a numeric representation of the order.\n *\n * ## Examples\n *\n * ```gleam\n * to_int(Lt)\n * // -> -1\n * ```\n *\n * ```gleam\n * to_int(Eq)\n * // -> 0\n * ```\n *\n * ```gleam\n * to_int(Gt)\n * // -> 1\n * ```\n */\nexport function to_int(order) {\n  if (order instanceof Lt) {\n    return -1;\n  } else if (order instanceof Eq) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n/**\n * Compares two `Order` values to one another, producing a new `Order`.\n *\n * ## Examples\n *\n * ```gleam\n * compare(Eq, with: Lt)\n * // -> Gt\n * ```\n */\nexport function compare(a, b) {\n  let x = a;\n  let y = b;\n  if (isEqual(x, y)) {\n    return new Eq();\n  } else if (a instanceof Lt) {\n    return new Lt();\n  } else if (a instanceof Eq && b instanceof Gt) {\n    return new Lt();\n  } else {\n    return new Gt();\n  }\n}\n\n/**\n * Inverts an ordering function, so less-than becomes greater-than and greater-than\n * becomes less-than.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n * import gleam/list\n *\n * list.sort([1, 5, 4], by: reverse(int.compare))\n * // -> [5, 4, 1]\n * ```\n */\nexport function reverse(orderer) {\n  return (a, b) => { return orderer(b, a); };\n}\n\n/**\n * Return a fallback `Order` in case the first argument is `Eq`.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * break_tie(in: int.compare(1, 1), with: Lt)\n * // -> Lt\n * ```\n *\n * ```gleam\n * import gleam/int\n *\n * break_tie(in: int.compare(1, 0), with: Eq)\n * // -> Gt\n * ```\n */\nexport function break_tie(order, other) {\n  if (order instanceof Lt) {\n    return order;\n  } else if (order instanceof Eq) {\n    return other;\n  } else {\n    return order;\n  }\n}\n\n/**\n * Invokes a fallback function returning an `Order` in case the first argument\n * is `Eq`.\n *\n * This can be useful when the fallback comparison might be expensive and it\n * needs to be delayed until strictly necessary.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * lazy_break_tie(in: int.compare(1, 1), with: fn() { Lt })\n * // -> Lt\n * ```\n *\n * ```gleam\n * import gleam/int\n *\n * lazy_break_tie(in: int.compare(1, 0), with: fn() { Eq })\n * // -> Gt\n * ```\n */\nexport function lazy_break_tie(order, comparison) {\n  if (order instanceof Lt) {\n    return order;\n  } else if (order instanceof Eq) {\n    return comparison();\n  } else {\n    return order;\n  }\n}\n","//# sourceMappingURL=option.mjs.map\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n} from \"../gleam.mjs\";\n\nexport class Some extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\nexport const Option$Some = ($0) => new Some($0);\nexport const Option$isSome = (value) => value instanceof Some;\nexport const Option$Some$0 = (value) => value[0];\n\nexport class None extends $CustomType {}\nexport const Option$None = () => new None();\nexport const Option$isNone = (value) => value instanceof None;\n\nfunction reverse_and_prepend(loop$prefix, loop$suffix) {\n  while (true) {\n    let prefix = loop$prefix;\n    let suffix = loop$suffix;\n    if (prefix instanceof $Empty) {\n      return suffix;\n    } else {\n      let first = prefix.head;\n      let rest = prefix.tail;\n      loop$prefix = rest;\n      loop$suffix = listPrepend(first, suffix);\n    }\n  }\n}\n\nfunction reverse(list) {\n  return reverse_and_prepend(list, toList([]));\n}\n\nfunction all_loop(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return new Some(reverse(acc));\n    } else {\n      let $ = list.head;\n      if ($ instanceof Some) {\n        let rest = list.tail;\n        let first = $[0];\n        loop$list = rest;\n        loop$acc = listPrepend(first, acc);\n      } else {\n        return new None();\n      }\n    }\n  }\n}\n\n/**\n * Combines a list of `Option`s into a single `Option`.\n * If all elements in the list are `Some` then returns a `Some` holding the list of values.\n * If any element is `None` then returns`None`.\n *\n * ## Examples\n *\n * ```gleam\n * all([Some(1), Some(2)])\n * // -> Some([1, 2])\n * ```\n *\n * ```gleam\n * all([Some(1), None])\n * // -> None\n * ```\n */\nexport function all(list) {\n  return all_loop(list, toList([]));\n}\n\n/**\n * Checks whether the `Option` is a `Some` value.\n *\n * ## Examples\n *\n * ```gleam\n * is_some(Some(1))\n * // -> True\n * ```\n *\n * ```gleam\n * is_some(None)\n * // -> False\n * ```\n */\nexport function is_some(option) {\n  return !(option instanceof None);\n}\n\n/**\n * Checks whether the `Option` is a `None` value.\n *\n * ## Examples\n *\n * ```gleam\n * is_none(Some(1))\n * // -> False\n * ```\n *\n * ```gleam\n * is_none(None)\n * // -> True\n * ```\n */\nexport function is_none(option) {\n  return option instanceof None;\n}\n\n/**\n * Converts an `Option` type to a `Result` type.\n *\n * ## Examples\n *\n * ```gleam\n * to_result(Some(1), \"some_error\")\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * to_result(None, \"some_error\")\n * // -> Error(\"some_error\")\n * ```\n */\nexport function to_result(option, e) {\n  if (option instanceof Some) {\n    let a = option[0];\n    return new Ok(a);\n  } else {\n    return new Error(e);\n  }\n}\n\n/**\n * Converts a `Result` type to an `Option` type.\n *\n * ## Examples\n *\n * ```gleam\n * from_result(Ok(1))\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * from_result(Error(\"some_error\"))\n * // -> None\n * ```\n */\nexport function from_result(result) {\n  if (result instanceof Ok) {\n    let a = result[0];\n    return new Some(a);\n  } else {\n    return new None();\n  }\n}\n\n/**\n * Extracts the value from an `Option`, returning a default value if there is none.\n *\n * ## Examples\n *\n * ```gleam\n * unwrap(Some(1), 0)\n * // -> 1\n * ```\n *\n * ```gleam\n * unwrap(None, 0)\n * // -> 0\n * ```\n */\nexport function unwrap(option, default$) {\n  if (option instanceof Some) {\n    let x = option[0];\n    return x;\n  } else {\n    return default$;\n  }\n}\n\n/**\n * Extracts the value from an `Option`, evaluating the default function if the option is `None`.\n *\n * ## Examples\n *\n * ```gleam\n * lazy_unwrap(Some(1), fn() { 0 })\n * // -> 1\n * ```\n *\n * ```gleam\n * lazy_unwrap(None, fn() { 0 })\n * // -> 0\n * ```\n */\nexport function lazy_unwrap(option, default$) {\n  if (option instanceof Some) {\n    let x = option[0];\n    return x;\n  } else {\n    return default$();\n  }\n}\n\n/**\n * Updates a value held within the `Some` of an `Option` by calling a given function\n * on it.\n *\n * If the `Option` is a `None` rather than `Some`, the function is not called and the\n * `Option` stays the same.\n *\n * ## Examples\n *\n * ```gleam\n * map(over: Some(1), with: fn(x) { x + 1 })\n * // -> Some(2)\n * ```\n *\n * ```gleam\n * map(over: None, with: fn(x) { x + 1 })\n * // -> None\n * ```\n */\nexport function map(option, fun) {\n  if (option instanceof Some) {\n    let x = option[0];\n    return new Some(fun(x));\n  } else {\n    return option;\n  }\n}\n\n/**\n * Merges a nested `Option` into a single layer.\n *\n * ## Examples\n *\n * ```gleam\n * flatten(Some(Some(1)))\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * flatten(Some(None))\n * // -> None\n * ```\n *\n * ```gleam\n * flatten(None)\n * // -> None\n * ```\n */\nexport function flatten(option) {\n  if (option instanceof Some) {\n    let x = option[0];\n    return x;\n  } else {\n    return option;\n  }\n}\n\n/**\n * Updates a value held within the `Some` of an `Option` by calling a given function\n * on it, where the given function also returns an `Option`. The two options are\n * then merged together into one `Option`.\n *\n * If the `Option` is a `None` rather than `Some` the function is not called and the\n * option stays the same.\n *\n * This function is the equivalent of calling `map` followed by `flatten`, and\n * it is useful for chaining together multiple functions that return `Option`.\n *\n * ## Examples\n *\n * ```gleam\n * then(Some(1), fn(x) { Some(x + 1) })\n * // -> Some(2)\n * ```\n *\n * ```gleam\n * then(Some(1), fn(x) { Some(#(\"a\", x)) })\n * // -> Some(#(\"a\", 1))\n * ```\n *\n * ```gleam\n * then(Some(1), fn(_) { None })\n * // -> None\n * ```\n *\n * ```gleam\n * then(None, fn(x) { Some(x + 1) })\n * // -> None\n * ```\n */\nexport function then$(option, fun) {\n  if (option instanceof Some) {\n    let x = option[0];\n    return fun(x);\n  } else {\n    return option;\n  }\n}\n\n/**\n * Returns the first value if it is `Some`, otherwise returns the second value.\n *\n * ## Examples\n *\n * ```gleam\n * or(Some(1), Some(2))\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * or(Some(1), None)\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * or(None, Some(2))\n * // -> Some(2)\n * ```\n *\n * ```gleam\n * or(None, None)\n * // -> None\n * ```\n */\nexport function or(first, second) {\n  if (first instanceof Some) {\n    return first;\n  } else {\n    return second;\n  }\n}\n\n/**\n * Returns the first value if it is `Some`, otherwise evaluates the given function for a fallback value.\n *\n * ## Examples\n *\n * ```gleam\n * lazy_or(Some(1), fn() { Some(2) })\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * lazy_or(Some(1), fn() { None })\n * // -> Some(1)\n * ```\n *\n * ```gleam\n * lazy_or(None, fn() { Some(2) })\n * // -> Some(2)\n * ```\n *\n * ```gleam\n * lazy_or(None, fn() { None })\n * // -> None\n * ```\n */\nexport function lazy_or(first, second) {\n  if (first instanceof Some) {\n    return first;\n  } else {\n    return second();\n  }\n}\n\nfunction values_loop(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let $ = list.head;\n      if ($ instanceof Some) {\n        let rest = list.tail;\n        let first = $[0];\n        loop$list = rest;\n        loop$acc = listPrepend(first, acc);\n      } else {\n        let rest = list.tail;\n        loop$list = rest;\n        loop$acc = acc;\n      }\n    }\n  }\n}\n\n/**\n * Given a list of `Option`s,\n * returns only the values inside `Some`.\n *\n * ## Examples\n *\n * ```gleam\n * values([Some(1), None, Some(3)])\n * // -> [1, 3]\n * ```\n */\nexport function values(options) {\n  return values_loop(options, toList([]));\n}\n","/**\n * This file uses jsdoc to annotate types.\n * These types can be checked using the typescript compiler with \"checkjs\" option.\n */\n\nimport { isEqual } from \"./gleam.mjs\";\n\nconst referenceMap = /* @__PURE__ */ new WeakMap();\nconst tempDataView = /* @__PURE__ */ new DataView(\n  /* @__PURE__ */ new ArrayBuffer(8),\n);\nlet referenceUID = 0;\n/**\n * hash the object by reference using a weak map and incrementing uid\n * @param {any} o\n * @returns {number}\n */\nfunction hashByReference(o) {\n  const known = referenceMap.get(o);\n  if (known !== undefined) {\n    return known;\n  }\n  const hash = referenceUID++;\n  if (referenceUID === 0x7fffffff) {\n    referenceUID = 0;\n  }\n  referenceMap.set(o, hash);\n  return hash;\n}\n\n/**\n * merge two hashes in an order sensitive way\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction hashMerge(a, b) {\n  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0;\n}\n\n/**\n * standard string hash popularised by java\n * @param {string} s\n * @returns {number}\n */\nfunction hashString(s) {\n  let hash = 0;\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    hash = (Math.imul(31, hash) + s.charCodeAt(i)) | 0;\n  }\n  return hash;\n}\n\n/**\n * hash a number by converting to two integers and do some jumbling\n * @param {number} n\n * @returns {number}\n */\nfunction hashNumber(n) {\n  tempDataView.setFloat64(0, n);\n  const i = tempDataView.getInt32(0);\n  const j = tempDataView.getInt32(4);\n  return Math.imul(0x45d9f3b, (i >> 16) ^ i) ^ j;\n}\n\n/**\n * hash a BigInt by converting it to a string and hashing that\n * @param {BigInt} n\n * @returns {number}\n */\nfunction hashBigInt(n) {\n  return hashString(n.toString());\n}\n\n/**\n * hash any js object\n * @param {any} o\n * @returns {number}\n */\nfunction hashObject(o) {\n  const proto = Object.getPrototypeOf(o);\n  if (proto !== null && typeof proto.hashCode === \"function\") {\n    try {\n      const code = o.hashCode(o);\n      if (typeof code === \"number\") {\n        return code;\n      }\n    } catch {}\n  }\n  if (o instanceof Promise || o instanceof WeakSet || o instanceof WeakMap) {\n    return hashByReference(o);\n  }\n  if (o instanceof Date) {\n    return hashNumber(o.getTime());\n  }\n  let h = 0;\n  if (o instanceof ArrayBuffer) {\n    o = new Uint8Array(o);\n  }\n  if (Array.isArray(o) || o instanceof Uint8Array) {\n    for (let i = 0; i < o.length; i++) {\n      h = (Math.imul(31, h) + getHash(o[i])) | 0;\n    }\n  } else if (o instanceof Set) {\n    o.forEach((v) => {\n      h = (h + getHash(v)) | 0;\n    });\n  } else if (o instanceof Map) {\n    o.forEach((v, k) => {\n      h = (h + hashMerge(getHash(v), getHash(k))) | 0;\n    });\n  } else {\n    const keys = Object.keys(o);\n    for (let i = 0; i < keys.length; i++) {\n      const k = keys[i];\n      const v = o[k];\n      h = (h + hashMerge(getHash(v), hashString(k))) | 0;\n    }\n  }\n  return h;\n}\n\n/**\n * hash any js value\n * @param {any} u\n * @returns {number}\n */\nexport function getHash(u) {\n  if (u === null) return 0x42108422;\n  if (u === undefined) return 0x42108423;\n  if (u === true) return 0x42108421;\n  if (u === false) return 0x42108420;\n  switch (typeof u) {\n    case \"number\":\n      return hashNumber(u);\n    case \"string\":\n      return hashString(u);\n    case \"bigint\":\n      return hashBigInt(u);\n    case \"object\":\n      return hashObject(u);\n    case \"symbol\":\n      return hashByReference(u);\n    case \"function\":\n      return hashByReference(u);\n    default:\n      return 0; // should be unreachable\n  }\n}\n\n/**\n * @template K,V\n * @typedef {ArrayNode<K,V> | IndexNode<K,V> | CollisionNode<K,V>} Node\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof ENTRY, k: K, v: V }} Entry\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof ARRAY_NODE, size: number, array: (undefined | Entry<K,V> | Node<K,V>)[] }} ArrayNode\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof INDEX_NODE, bitmap: number, array: (Entry<K,V> | Node<K,V>)[] }} IndexNode\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof COLLISION_NODE, hash: number, array: Entry<K, V>[] }} CollisionNode\n */\n/**\n * @typedef {{ val: boolean }} Flag\n */\nconst SHIFT = 5; // number of bits you need to shift by to get the next bucket\nconst BUCKET_SIZE = Math.pow(2, SHIFT);\nconst MASK = BUCKET_SIZE - 1; // used to zero out all bits not in the bucket\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2; // when does index node grow into array node\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4; // when does array node shrink to index node\nconst ENTRY = 0;\nconst ARRAY_NODE = 1;\nconst INDEX_NODE = 2;\nconst COLLISION_NODE = 3;\n\n/** @type {IndexNode<any,any>} */\nconst EMPTY = {\n  type: INDEX_NODE,\n  bitmap: 0,\n  array: [],\n};\n/**\n * Mask the hash to get only the bucket corresponding to shift\n * @param {number} hash\n * @param {number} shift\n * @returns {number}\n */\nfunction mask(hash, shift) {\n  return (hash >>> shift) & MASK;\n}\n\n/**\n * Set only the Nth bit where N is the masked hash\n * @param {number} hash\n * @param {number} shift\n * @returns {number}\n */\nfunction bitpos(hash, shift) {\n  return 1 << mask(hash, shift);\n}\n\n/**\n * Count the number of 1 bits in a number\n * @param {number} x\n * @returns {number}\n */\nfunction bitcount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\n/**\n * Calculate the array index of an item in a bitmap index node\n * @param {number} bitmap\n * @param {number} bit\n * @returns {number}\n */\nfunction index(bitmap, bit) {\n  return bitcount(bitmap & (bit - 1));\n}\n\n/**\n * Efficiently copy an array and set one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @param {T} val\n * @returns {T[]}\n */\nfunction cloneAndSet(arr, at, val) {\n  const len = arr.length;\n  const out = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    out[i] = arr[i];\n  }\n  out[at] = val;\n  return out;\n}\n\n/**\n * Efficiently copy an array and insert one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @param {T} val\n * @returns {T[]}\n */\nfunction spliceIn(arr, at, val) {\n  const len = arr.length;\n  const out = new Array(len + 1);\n  let i = 0;\n  let g = 0;\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n  out[g++] = val;\n  while (i < len) {\n    out[g++] = arr[i++];\n  }\n  return out;\n}\n\n/**\n * Efficiently copy an array and remove one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @returns {T[]}\n */\nfunction spliceOut(arr, at) {\n  const len = arr.length;\n  const out = new Array(len - 1);\n  let i = 0;\n  let g = 0;\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n  ++i;\n  while (i < len) {\n    out[g++] = arr[i++];\n  }\n  return out;\n}\n\n/**\n * Create a new node containing two entries\n * @template K,V\n * @param {number} shift\n * @param {K} key1\n * @param {V} val1\n * @param {number} key2hash\n * @param {K} key2\n * @param {V} val2\n * @returns {Node<K,V>}\n */\nfunction createNode(shift, key1, val1, key2hash, key2, val2) {\n  const key1hash = getHash(key1);\n  if (key1hash === key2hash) {\n    return {\n      type: COLLISION_NODE,\n      hash: key1hash,\n      array: [\n        { type: ENTRY, k: key1, v: val1 },\n        { type: ENTRY, k: key2, v: val2 },\n      ],\n    };\n  }\n  const addedLeaf = { val: false };\n  return assoc(\n    assocIndex(EMPTY, shift, key1hash, key1, val1, addedLeaf),\n    shift,\n    key2hash,\n    key2,\n    val2,\n    addedLeaf,\n  );\n}\n\n/**\n * @template T,K,V\n * @callback AssocFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @param {V} val\n * @param {Flag} addedLeaf\n * @returns {Node<K,V>}\n */\n/**\n * Associate a node with a new entry, creating a new node\n * @template T,K,V\n * @type {AssocFunction<Node<K,V>,K,V>}\n */\nfunction assoc(root, shift, hash, key, val, addedLeaf) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return assocArray(root, shift, hash, key, val, addedLeaf);\n    case INDEX_NODE:\n      return assocIndex(root, shift, hash, key, val, addedLeaf);\n    case COLLISION_NODE:\n      return assocCollision(root, shift, hash, key, val, addedLeaf);\n  }\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<ArrayNode<K,V>,K,V>}\n */\nfunction assocArray(root, shift, hash, key, val, addedLeaf) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  // if the corresponding index is empty set the index to a newly created node\n  if (node === undefined) {\n    addedLeaf.val = true;\n    return {\n      type: ARRAY_NODE,\n      size: root.size + 1,\n      array: cloneAndSet(root.array, idx, { type: ENTRY, k: key, v: val }),\n    };\n  }\n  if (node.type === ENTRY) {\n    // if keys are equal replace the entry\n    if (isEqual(key, node.k)) {\n      if (val === node.v) {\n        return root;\n      }\n      return {\n        type: ARRAY_NODE,\n        size: root.size,\n        array: cloneAndSet(root.array, idx, {\n          type: ENTRY,\n          k: key,\n          v: val,\n        }),\n      };\n    }\n    // otherwise upgrade the entry to a node and insert\n    addedLeaf.val = true;\n    return {\n      type: ARRAY_NODE,\n      size: root.size,\n      array: cloneAndSet(\n        root.array,\n        idx,\n        createNode(shift + SHIFT, node.k, node.v, hash, key, val),\n      ),\n    };\n  }\n  // otherwise call assoc on the child node\n  const n = assoc(node, shift + SHIFT, hash, key, val, addedLeaf);\n  // if the child node hasn't changed just return the old root\n  if (n === node) {\n    return root;\n  }\n  // otherwise set the index to the new node\n  return {\n    type: ARRAY_NODE,\n    size: root.size,\n    array: cloneAndSet(root.array, idx, n),\n  };\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<IndexNode<K,V>,K,V>}\n */\nfunction assocIndex(root, shift, hash, key, val, addedLeaf) {\n  const bit = bitpos(hash, shift);\n  const idx = index(root.bitmap, bit);\n  // if there is already a item at this hash index..\n  if ((root.bitmap & bit) !== 0) {\n    // if there is a node at the index (not an entry), call assoc on the child node\n    const node = root.array[idx];\n    if (node.type !== ENTRY) {\n      const n = assoc(node, shift + SHIFT, hash, key, val, addedLeaf);\n      if (n === node) {\n        return root;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, n),\n      };\n    }\n    // otherwise there is an entry at the index\n    // if the keys are equal replace the entry with the updated value\n    const nodeKey = node.k;\n    if (isEqual(key, nodeKey)) {\n      if (val === node.v) {\n        return root;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, {\n          type: ENTRY,\n          k: key,\n          v: val,\n        }),\n      };\n    }\n    // if the keys are not equal, replace the entry with a new child node\n    addedLeaf.val = true;\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap,\n      array: cloneAndSet(\n        root.array,\n        idx,\n        createNode(shift + SHIFT, nodeKey, node.v, hash, key, val),\n      ),\n    };\n  } else {\n    // else there is currently no item at the hash index\n    const n = root.array.length;\n    // if the number of nodes is at the maximum, expand this node into an array node\n    if (n >= MAX_INDEX_NODE) {\n      // create a 32 length array for the new array node (one for each bit in the hash)\n      const nodes = new Array(32);\n      // create and insert a node for the new entry\n      const jdx = mask(hash, shift);\n      nodes[jdx] = assocIndex(EMPTY, shift + SHIFT, hash, key, val, addedLeaf);\n      let j = 0;\n      let bitmap = root.bitmap;\n      // place each item in the index node into the correct spot in the array node\n      // loop through all 32 bits / array positions\n      for (let i = 0; i < 32; i++) {\n        if ((bitmap & 1) !== 0) {\n          const node = root.array[j++];\n          nodes[i] = node;\n        }\n        // shift the bitmap to process the next bit\n        bitmap = bitmap >>> 1;\n      }\n      return {\n        type: ARRAY_NODE,\n        size: n + 1,\n        array: nodes,\n      };\n    } else {\n      // else there is still space in this index node\n      // simply insert a new entry at the hash index\n      const newArray = spliceIn(root.array, idx, {\n        type: ENTRY,\n        k: key,\n        v: val,\n      });\n      addedLeaf.val = true;\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap | bit,\n        array: newArray,\n      };\n    }\n  }\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<CollisionNode<K,V>,K,V>}\n */\nfunction assocCollision(root, shift, hash, key, val, addedLeaf) {\n  // if there is a hash collision\n  if (hash === root.hash) {\n    const idx = collisionIndexOf(root, key);\n    // if this key already exists replace the entry with the new value\n    if (idx !== -1) {\n      const entry = root.array[idx];\n      if (entry.v === val) {\n        return root;\n      }\n      return {\n        type: COLLISION_NODE,\n        hash: hash,\n        array: cloneAndSet(root.array, idx, { type: ENTRY, k: key, v: val }),\n      };\n    }\n    // otherwise insert the entry at the end of the array\n    const size = root.array.length;\n    addedLeaf.val = true;\n    return {\n      type: COLLISION_NODE,\n      hash: hash,\n      array: cloneAndSet(root.array, size, { type: ENTRY, k: key, v: val }),\n    };\n  }\n  // if there is no hash collision, upgrade to an index node\n  return assoc(\n    {\n      type: INDEX_NODE,\n      bitmap: bitpos(root.hash, shift),\n      array: [root],\n    },\n    shift,\n    hash,\n    key,\n    val,\n    addedLeaf,\n  );\n}\n/**\n * Find the index of a key in the collision node's array\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {number}\n */\nfunction collisionIndexOf(root, key) {\n  const size = root.array.length;\n  for (let i = 0; i < size; i++) {\n    if (isEqual(key, root.array[i].k)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * @template T,K,V\n * @callback FindFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @returns {undefined | Entry<K,V>}\n */\n/**\n * Return the found entry or undefined if not present in the root\n * @template K,V\n * @type {FindFunction<Node<K,V>,K,V>}\n */\nfunction find(root, shift, hash, key) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return findArray(root, shift, hash, key);\n    case INDEX_NODE:\n      return findIndex(root, shift, hash, key);\n    case COLLISION_NODE:\n      return findCollision(root, key);\n  }\n}\n/**\n * @template K,V\n * @type {FindFunction<ArrayNode<K,V>,K,V>}\n */\nfunction findArray(root, shift, hash, key) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  if (node === undefined) {\n    return undefined;\n  }\n  if (node.type !== ENTRY) {\n    return find(node, shift + SHIFT, hash, key);\n  }\n  if (isEqual(key, node.k)) {\n    return node;\n  }\n  return undefined;\n}\n/**\n * @template K,V\n * @type {FindFunction<IndexNode<K,V>,K,V>}\n */\nfunction findIndex(root, shift, hash, key) {\n  const bit = bitpos(hash, shift);\n  if ((root.bitmap & bit) === 0) {\n    return undefined;\n  }\n  const idx = index(root.bitmap, bit);\n  const node = root.array[idx];\n  if (node.type !== ENTRY) {\n    return find(node, shift + SHIFT, hash, key);\n  }\n  if (isEqual(key, node.k)) {\n    return node;\n  }\n  return undefined;\n}\n/**\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {undefined | Entry<K,V>}\n */\nfunction findCollision(root, key) {\n  const idx = collisionIndexOf(root, key);\n  if (idx < 0) {\n    return undefined;\n  }\n  return root.array[idx];\n}\n/**\n * @template T,K,V\n * @callback WithoutFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @returns {undefined | Node<K,V>}\n */\n/**\n * Remove an entry from the root, returning the updated root.\n * Returns undefined if the node should be removed from the parent.\n * @template K,V\n * @type {WithoutFunction<Node<K,V>,K,V>}\n * */\nfunction without(root, shift, hash, key) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return withoutArray(root, shift, hash, key);\n    case INDEX_NODE:\n      return withoutIndex(root, shift, hash, key);\n    case COLLISION_NODE:\n      return withoutCollision(root, key);\n  }\n}\n/**\n * @template K,V\n * @type {WithoutFunction<ArrayNode<K,V>,K,V>}\n */\nfunction withoutArray(root, shift, hash, key) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  if (node === undefined) {\n    return root; // already empty\n  }\n  let n = undefined;\n  // if node is an entry and the keys are not equal there is nothing to remove\n  // if node is not an entry do a recursive call\n  if (node.type === ENTRY) {\n    if (!isEqual(node.k, key)) {\n      return root; // no changes\n    }\n  } else {\n    n = without(node, shift + SHIFT, hash, key);\n    if (n === node) {\n      return root; // no changes\n    }\n  }\n  // if the recursive call returned undefined the node should be removed\n  if (n === undefined) {\n    // if the number of child nodes is at the minimum, pack into an index node\n    if (root.size <= MIN_ARRAY_NODE) {\n      const arr = root.array;\n      const out = new Array(root.size - 1);\n      let i = 0;\n      let j = 0;\n      let bitmap = 0;\n      while (i < idx) {\n        const nv = arr[i];\n        if (nv !== undefined) {\n          out[j] = nv;\n          bitmap |= 1 << i;\n          ++j;\n        }\n        ++i;\n      }\n      ++i; // skip copying the removed node\n      while (i < arr.length) {\n        const nv = arr[i];\n        if (nv !== undefined) {\n          out[j] = nv;\n          bitmap |= 1 << i;\n          ++j;\n        }\n        ++i;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: bitmap,\n        array: out,\n      };\n    }\n    return {\n      type: ARRAY_NODE,\n      size: root.size - 1,\n      array: cloneAndSet(root.array, idx, n),\n    };\n  }\n  return {\n    type: ARRAY_NODE,\n    size: root.size,\n    array: cloneAndSet(root.array, idx, n),\n  };\n}\n/**\n * @template K,V\n * @type {WithoutFunction<IndexNode<K,V>,K,V>}\n */\nfunction withoutIndex(root, shift, hash, key) {\n  const bit = bitpos(hash, shift);\n  if ((root.bitmap & bit) === 0) {\n    return root; // already empty\n  }\n  const idx = index(root.bitmap, bit);\n  const node = root.array[idx];\n  // if the item is not an entry\n  if (node.type !== ENTRY) {\n    const n = without(node, shift + SHIFT, hash, key);\n    if (n === node) {\n      return root; // no changes\n    }\n    // if not undefined, the child node still has items, so update it\n    if (n !== undefined) {\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, n),\n      };\n    }\n    // otherwise the child node should be removed\n    // if it was the only child node, remove this node from the parent\n    if (root.bitmap === bit) {\n      return undefined;\n    }\n    // otherwise just remove the child node\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap ^ bit,\n      array: spliceOut(root.array, idx),\n    };\n  }\n  // otherwise the item is an entry, remove it if the key matches\n  if (isEqual(key, node.k)) {\n    if (root.bitmap === bit) {\n      return undefined;\n    }\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap ^ bit,\n      array: spliceOut(root.array, idx),\n    };\n  }\n  return root;\n}\n/**\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {undefined | Node<K,V>}\n */\nfunction withoutCollision(root, key) {\n  const idx = collisionIndexOf(root, key);\n  // if the key not found, no changes\n  if (idx < 0) {\n    return root;\n  }\n  // otherwise the entry was found, remove it\n  // if it was the only entry in this node, remove the whole node\n  if (root.array.length === 1) {\n    return undefined;\n  }\n  // otherwise just remove the entry\n  return {\n    type: COLLISION_NODE,\n    hash: root.hash,\n    array: spliceOut(root.array, idx),\n  };\n}\n/**\n * @template K,V\n * @param {undefined | Node<K,V>} root\n * @param {(value:V,key:K)=>void} fn\n * @returns {void}\n */\nfunction forEach(root, fn) {\n  if (root === undefined) {\n    return;\n  }\n  const items = root.array;\n  const size = items.length;\n  for (let i = 0; i < size; i++) {\n    const item = items[i];\n    if (item === undefined) {\n      continue;\n    }\n    if (item.type === ENTRY) {\n      fn(item.v, item.k);\n      continue;\n    }\n    forEach(item, fn);\n  }\n}\n\n/**\n * Extra wrapper to keep track of Dict size and clean up the API\n * @template K,V\n */\nexport default class Dict {\n  /**\n   * @template V\n   * @param {Record<string,V>} o\n   * @returns {Dict<string,V>}\n   */\n  static fromObject(o) {\n    const keys = Object.keys(o);\n    /** @type Dict<string,V> */\n    let m = Dict.new();\n    for (let i = 0; i < keys.length; i++) {\n      const k = keys[i];\n      m = m.set(k, o[k]);\n    }\n    return m;\n  }\n\n  /**\n   * @template K,V\n   * @param {Map<K,V>} o\n   * @returns {Dict<K,V>}\n   */\n  static fromMap(o) {\n    /** @type Dict<K,V> */\n    let m = Dict.new();\n    o.forEach((v, k) => {\n      m = m.set(k, v);\n    });\n    return m;\n  }\n\n  static new() {\n    return new Dict(undefined, 0);\n  }\n\n  /**\n   * @param {undefined | Node<K,V>} root\n   * @param {number} size\n   */\n  constructor(root, size) {\n    this.root = root;\n    this.size = size;\n  }\n  /**\n   * @template NotFound\n   * @param {K} key\n   * @param {NotFound} notFound\n   * @returns {NotFound | V}\n   */\n  get(key, notFound) {\n    if (this.root === undefined) {\n      return notFound;\n    }\n    const found = find(this.root, 0, getHash(key), key);\n    if (found === undefined) {\n      return notFound;\n    }\n    return found.v;\n  }\n  /**\n   * @param {K} key\n   * @param {V} val\n   * @returns {Dict<K,V>}\n   */\n  set(key, val) {\n    const addedLeaf = { val: false };\n    const root = this.root === undefined ? EMPTY : this.root;\n    const newRoot = assoc(root, 0, getHash(key), key, val, addedLeaf);\n    if (newRoot === this.root) {\n      return this;\n    }\n    return new Dict(newRoot, addedLeaf.val ? this.size + 1 : this.size);\n  }\n  /**\n   * @param {K} key\n   * @returns {Dict<K,V>}\n   */\n  delete(key) {\n    if (this.root === undefined) {\n      return this;\n    }\n    const newRoot = without(this.root, 0, getHash(key), key);\n    if (newRoot === this.root) {\n      return this;\n    }\n    if (newRoot === undefined) {\n      return Dict.new();\n    }\n    return new Dict(newRoot, this.size - 1);\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    if (this.root === undefined) {\n      return false;\n    }\n    return find(this.root, 0, getHash(key), key) !== undefined;\n  }\n  /**\n   * @returns {[K,V][]}\n   */\n  entries() {\n    if (this.root === undefined) {\n      return [];\n    }\n    /** @type [K,V][] */\n    const result = [];\n    this.forEach((v, k) => result.push([k, v]));\n    return result;\n  }\n  /**\n   *\n   * @param {(val:V,key:K)=>void} fn\n   */\n  forEach(fn) {\n    forEach(this.root, fn);\n  }\n  hashCode() {\n    let h = 0;\n    this.forEach((v, k) => {\n      h = (h + hashMerge(getHash(v), getHash(k))) | 0;\n    });\n    return h;\n  }\n  /**\n   * @param {unknown} o\n   * @returns {boolean}\n   */\n  equals(o) {\n    if (!(o instanceof Dict) || this.size !== o.size) {\n      return false;\n    }\n\n    try {\n      this.forEach((v, k) => {\n        if (!isEqual(o.get(k, !v), v)) {\n          throw unequalDictSymbol;\n        }\n      });\n      return true;\n    } catch (e) {\n      if (e === unequalDictSymbol) {\n        return false;\n      }\n\n      throw e;\n    }\n  }\n}\n\n// This is thrown internally in Dict.equals() so that it returns false as soon\n// as a non-matching key is found\nconst unequalDictSymbol = /* @__PURE__ */ Symbol();\n","//# sourceMappingURL=dict.mjs.map\nimport { Ok, Error, toList, Empty as $Empty, prepend as listPrepend, isEqual } from \"../gleam.mjs\";\nimport * as $option from \"../gleam/option.mjs\";\nimport {\n  map_size as size,\n  map_to_list as to_list,\n  new_map as new$,\n  map_get as get,\n  map_insert as do_insert,\n  map_remove as do_delete,\n} from \"../gleam_stdlib.mjs\";\n\nexport { get, new$, size, to_list };\n\n/**\n * Determines whether or not the dict is empty.\n *\n * ## Examples\n *\n * ```gleam\n * new() |> is_empty\n * // -> True\n * ```\n *\n * ```gleam\n * new() |> insert(\"b\", 1) |> is_empty\n * // -> False\n * ```\n */\nexport function is_empty(dict) {\n  return size(dict) === 0;\n}\n\nfunction do_has_key(key, dict) {\n  return !isEqual(get(dict, key), new Error(undefined));\n}\n\n/**\n * Determines whether or not a value present in the dict for a given key.\n *\n * ## Examples\n *\n * ```gleam\n * new() |> insert(\"a\", 0) |> has_key(\"a\")\n * // -> True\n * ```\n *\n * ```gleam\n * new() |> insert(\"a\", 0) |> has_key(\"b\")\n * // -> False\n * ```\n */\nexport function has_key(dict, key) {\n  return do_has_key(key, dict);\n}\n\n/**\n * Inserts a value into the dict with the given key.\n *\n * If the dict already has a value for the given key then the value is\n * replaced with the new value.\n *\n * ## Examples\n *\n * ```gleam\n * new() |> insert(\"a\", 0)\n * // -> from_list([#(\"a\", 0)])\n * ```\n *\n * ```gleam\n * new() |> insert(\"a\", 0) |> insert(\"a\", 5)\n * // -> from_list([#(\"a\", 5)])\n * ```\n */\nexport function insert(dict, key, value) {\n  return do_insert(key, value, dict);\n}\n\nfunction from_list_loop(loop$list, loop$initial) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    if (list instanceof $Empty) {\n      return initial;\n    } else {\n      let rest = list.tail;\n      let key = list.head[0];\n      let value = list.head[1];\n      loop$list = rest;\n      loop$initial = insert(initial, key, value);\n    }\n  }\n}\n\n/**\n * Converts a list of 2-element tuples `#(key, value)` to a dict.\n *\n * If two tuples have the same key the last one in the list will be the one\n * that is present in the dict.\n */\nexport function from_list(list) {\n  return from_list_loop(list, new$());\n}\n\nfunction reverse_and_concat(loop$remaining, loop$accumulator) {\n  while (true) {\n    let remaining = loop$remaining;\n    let accumulator = loop$accumulator;\n    if (remaining instanceof $Empty) {\n      return accumulator;\n    } else {\n      let first = remaining.head;\n      let rest = remaining.tail;\n      loop$remaining = rest;\n      loop$accumulator = listPrepend(first, accumulator);\n    }\n  }\n}\n\nfunction do_keys_loop(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse_and_concat(acc, toList([]));\n    } else {\n      let rest = list.tail;\n      let key = list.head[0];\n      loop$list = rest;\n      loop$acc = listPrepend(key, acc);\n    }\n  }\n}\n\n/**\n * Gets a list of all keys in a given dict.\n *\n * Dicts are not ordered so the keys are not returned in any specific order. Do\n * not write code that relies on the order keys are returned by this function\n * as it may change in later versions of Gleam or Erlang.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> keys\n * // -> [\"a\", \"b\"]\n * ```\n */\nexport function keys(dict) {\n  return do_keys_loop(to_list(dict), toList([]));\n}\n\nfunction do_values_loop(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse_and_concat(acc, toList([]));\n    } else {\n      let rest = list.tail;\n      let value = list.head[1];\n      loop$list = rest;\n      loop$acc = listPrepend(value, acc);\n    }\n  }\n}\n\n/**\n * Gets a list of all values in a given dict.\n *\n * Dicts are not ordered so the values are not returned in any specific order. Do\n * not write code that relies on the order values are returned by this function\n * as it may change in later versions of Gleam or Erlang.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> values\n * // -> [0, 1]\n * ```\n */\nexport function values(dict) {\n  let list_of_pairs = to_list(dict);\n  return do_values_loop(list_of_pairs, toList([]));\n}\n\nfunction do_take_loop(loop$dict, loop$desired_keys, loop$acc) {\n  while (true) {\n    let dict = loop$dict;\n    let desired_keys = loop$desired_keys;\n    let acc = loop$acc;\n    let insert$1 = (taken, key) => {\n      let $ = get(dict, key);\n      if ($ instanceof Ok) {\n        let value = $[0];\n        return insert(taken, key, value);\n      } else {\n        return taken;\n      }\n    };\n    if (desired_keys instanceof $Empty) {\n      return acc;\n    } else {\n      let first = desired_keys.head;\n      let rest = desired_keys.tail;\n      loop$dict = dict;\n      loop$desired_keys = rest;\n      loop$acc = insert$1(acc, first);\n    }\n  }\n}\n\nfunction do_take(desired_keys, dict) {\n  return do_take_loop(dict, desired_keys, new$());\n}\n\n/**\n * Creates a new dict from a given dict, only including any entries for which the\n * keys are in a given list.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)])\n * |> take([\"b\"])\n * // -> from_list([#(\"b\", 1)])\n * ```\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)])\n * |> take([\"a\", \"b\", \"c\"])\n * // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n * ```\n */\nexport function take(dict, desired_keys) {\n  return do_take(desired_keys, dict);\n}\n\nfunction insert_pair(dict, pair) {\n  return insert(dict, pair[0], pair[1]);\n}\n\nfunction fold_inserts(loop$new_entries, loop$dict) {\n  while (true) {\n    let new_entries = loop$new_entries;\n    let dict = loop$dict;\n    if (new_entries instanceof $Empty) {\n      return dict;\n    } else {\n      let first = new_entries.head;\n      let rest = new_entries.tail;\n      loop$new_entries = rest;\n      loop$dict = insert_pair(dict, first);\n    }\n  }\n}\n\n/**\n * Creates a new dict from a pair of given dicts by combining their entries.\n *\n * If there are entries with the same keys in both dicts the entry from the\n * second dict takes precedence.\n *\n * ## Examples\n *\n * ```gleam\n * let a = from_list([#(\"a\", 0), #(\"b\", 1)])\n * let b = from_list([#(\"b\", 2), #(\"c\", 3)])\n * merge(a, b)\n * // -> from_list([#(\"a\", 0), #(\"b\", 2), #(\"c\", 3)])\n * ```\n */\nexport function merge(dict, new_entries) {\n  let _pipe = new_entries;\n  let _pipe$1 = to_list(_pipe);\n  return fold_inserts(_pipe$1, dict);\n}\n\n/**\n * Creates a new dict from a given dict with all the same entries except for the\n * one with a given key, if it exists.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> delete(\"a\")\n * // -> from_list([#(\"b\", 1)])\n * ```\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> delete(\"c\")\n * // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n * ```\n */\nexport function delete$(dict, key) {\n  return do_delete(key, dict);\n}\n\n/**\n * Creates a new dict from a given dict with all the same entries except any with\n * keys found in a given list.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"a\"])\n * // -> from_list([#(\"b\", 1)])\n * ```\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"c\"])\n * // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n * ```\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"a\", \"b\", \"c\"])\n * // -> from_list([])\n * ```\n */\nexport function drop(loop$dict, loop$disallowed_keys) {\n  while (true) {\n    let dict = loop$dict;\n    let disallowed_keys = loop$disallowed_keys;\n    if (disallowed_keys instanceof $Empty) {\n      return dict;\n    } else {\n      let first = disallowed_keys.head;\n      let rest = disallowed_keys.tail;\n      loop$dict = delete$(dict, first);\n      loop$disallowed_keys = rest;\n    }\n  }\n}\n\n/**\n * Creates a new dict with one entry inserted or updated using a given function.\n *\n * If there was not an entry in the dict for the given key then the function\n * gets `None` as its argument, otherwise it gets `Some(value)`.\n *\n * ## Example\n *\n * ```gleam\n * let dict = from_list([#(\"a\", 0)])\n * let increment = fn(x) {\n *   case x {\n *     Some(i) -> i + 1\n *     None -> 0\n *   }\n * }\n *\n * upsert(dict, \"a\", increment)\n * // -> from_list([#(\"a\", 1)])\n *\n * upsert(dict, \"b\", increment)\n * // -> from_list([#(\"a\", 0), #(\"b\", 0)])\n * ```\n */\nexport function upsert(dict, key, fun) {\n  let $ = get(dict, key);\n  if ($ instanceof Ok) {\n    let value = $[0];\n    return insert(dict, key, fun(new $option.Some(value)));\n  } else {\n    return insert(dict, key, fun(new $option.None()));\n  }\n}\n\nfunction fold_loop(loop$list, loop$initial, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return initial;\n    } else {\n      let rest = list.tail;\n      let k = list.head[0];\n      let v = list.head[1];\n      loop$list = rest;\n      loop$initial = fun(initial, k, v);\n      loop$fun = fun;\n    }\n  }\n}\n\n/**\n * Combines all entries into a single value by calling a given function on each\n * one.\n *\n * Dicts are not ordered so the values are not returned in any specific order. Do\n * not write code that relies on the order entries are used by this function\n * as it may change in later versions of Gleam or Erlang.\n *\n * # Examples\n *\n * ```gleam\n * let dict = from_list([#(\"a\", 1), #(\"b\", 3), #(\"c\", 9)])\n * fold(dict, 0, fn(accumulator, key, value) { accumulator + value })\n * // -> 13\n * ```\n *\n * ```gleam\n * import gleam/string\n *\n * let dict = from_list([#(\"a\", 1), #(\"b\", 3), #(\"c\", 9)])\n * fold(dict, \"\", fn(accumulator, key, value) {\n *   string.append(accumulator, key)\n * })\n * // -> \"abc\"\n * ```\n */\nexport function fold(dict, initial, fun) {\n  return fold_loop(to_list(dict), initial, fun);\n}\n\nfunction do_map_values(f, dict) {\n  let f$1 = (dict, k, v) => { return insert(dict, k, f(k, v)); };\n  return fold(dict, new$(), f$1);\n}\n\n/**\n * Updates all values in a given dict by calling a given function on each key\n * and value.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(3, 3), #(2, 4)])\n * |> map_values(fn(key, value) { key * value })\n * // -> from_list([#(3, 9), #(2, 8)])\n * ```\n */\nexport function map_values(dict, fun) {\n  return do_map_values(fun, dict);\n}\n\nfunction do_filter(f, dict) {\n  let insert$1 = (dict, k, v) => {\n    let $ = f(k, v);\n    if ($) {\n      return insert(dict, k, v);\n    } else {\n      return dict;\n    }\n  };\n  return fold(dict, new$(), insert$1);\n}\n\n/**\n * Creates a new dict from a given dict, minus any entries that a given function\n * returns `False` for.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)])\n * |> filter(fn(key, value) { value != 0 })\n * // -> from_list([#(\"b\", 1)])\n * ```\n *\n * ```gleam\n * from_list([#(\"a\", 0), #(\"b\", 1)])\n * |> filter(fn(key, value) { True })\n * // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n * ```\n */\nexport function filter(dict, predicate) {\n  return do_filter(predicate, dict);\n}\n\n/**\n * Calls a function for each key and value in a dict, discarding the return\n * value.\n *\n * Useful for producing a side effect for every item of a dict.\n *\n * ```gleam\n * import gleam/io\n *\n * let dict = from_list([#(\"a\", \"apple\"), #(\"b\", \"banana\"), #(\"c\", \"cherry\")])\n *\n * each(dict, fn(k, v) {\n *   io.println(key <> \" => \" <> value)\n * })\n * // -> Nil\n * // a => apple\n * // b => banana\n * // c => cherry\n * ```\n *\n * The order of elements in the iteration is an implementation detail that\n * should not be relied upon.\n */\nexport function each(dict, fun) {\n  return fold(\n    dict,\n    undefined,\n    (nil, k, v) => {\n      fun(k, v);\n      return nil;\n    },\n  );\n}\n\n/**\n * Creates a new dict from a pair of given dicts by combining their entries.\n *\n * If there are entries with the same keys in both dicts the given function is\n * used to determine the new value to use in the resulting dict.\n *\n * ## Examples\n *\n * ```gleam\n * let a = from_list([#(\"a\", 0), #(\"b\", 1)])\n * let b = from_list([#(\"a\", 2), #(\"c\", 3)])\n * combine(a, b, fn(one, other) { one + other })\n * // -> from_list([#(\"a\", 2), #(\"b\", 1), #(\"c\", 3)])\n * ```\n */\nexport function combine(dict, other, fun) {\n  return fold(\n    dict,\n    other,\n    (acc, key, value) => {\n      let $ = get(acc, key);\n      if ($ instanceof Ok) {\n        let other_value = $[0];\n        return insert(acc, key, fun(value, other_value));\n      } else {\n        return insert(acc, key, value);\n      }\n    },\n  );\n}\n","//# sourceMappingURL=list.mjs.map\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  makeError,\n  divideFloat,\n  isEqual,\n} from \"../gleam.mjs\";\nimport * as $dict from \"../gleam/dict.mjs\";\nimport * as $float from \"../gleam/float.mjs\";\nimport * as $int from \"../gleam/int.mjs\";\nimport * as $order from \"../gleam/order.mjs\";\n\nconst FILEPATH = \"src/gleam/list.gleam\";\n\nexport class Continue extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\nexport const ContinueOrStop$Continue = ($0) => new Continue($0);\nexport const ContinueOrStop$isContinue = (value) => value instanceof Continue;\nexport const ContinueOrStop$Continue$0 = (value) => value[0];\n\nexport class Stop extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\nexport const ContinueOrStop$Stop = ($0) => new Stop($0);\nexport const ContinueOrStop$isStop = (value) => value instanceof Stop;\nexport const ContinueOrStop$Stop$0 = (value) => value[0];\n\nclass Ascending extends $CustomType {}\n\nclass Descending extends $CustomType {}\n\nconst min_positive = 2.2250738585072014e-308;\n\nfunction length_loop(loop$list, loop$count) {\n  while (true) {\n    let list = loop$list;\n    let count = loop$count;\n    if (list instanceof $Empty) {\n      return count;\n    } else {\n      let list$1 = list.tail;\n      loop$list = list$1;\n      loop$count = count + 1;\n    }\n  }\n}\n\n/**\n * Counts the number of elements in a given list.\n *\n * This function has to traverse the list to determine the number of elements,\n * so it runs in linear time.\n *\n * This function is natively implemented by the virtual machine and is highly\n * optimised.\n *\n * ## Examples\n *\n * ```gleam\n * length([])\n * // -> 0\n * ```\n *\n * ```gleam\n * length([1])\n * // -> 1\n * ```\n *\n * ```gleam\n * length([1, 2])\n * // -> 2\n * ```\n */\nexport function length(list) {\n  return length_loop(list, 0);\n}\n\nfunction count_loop(loop$list, loop$predicate, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return acc;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n        loop$acc = acc + 1;\n      } else {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n        loop$acc = acc;\n      }\n    }\n  }\n}\n\n/**\n * Counts the number of elements in a given list satisfying a given predicate.\n *\n * This function has to traverse the list to determine the number of elements,\n * so it runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * count([], fn(a) { a > 0 })\n * // -> 0\n * ```\n *\n * ```gleam\n * count([1], fn(a) { a > 0 })\n * // -> 1\n * ```\n *\n * ```gleam\n * count([1, 2, 3], int.is_odd)\n * // -> 2\n * ```\n */\nexport function count(list, predicate) {\n  return count_loop(list, predicate, 0);\n}\n\n/**\n * Reverses a list and prepends it to another list.\n * This function runs in linear time, proportional to the length of the list\n * to prepend.\n * \n * @ignore\n */\nfunction reverse_and_prepend(loop$prefix, loop$suffix) {\n  while (true) {\n    let prefix = loop$prefix;\n    let suffix = loop$suffix;\n    if (prefix instanceof $Empty) {\n      return suffix;\n    } else {\n      let first$1 = prefix.head;\n      let rest$1 = prefix.tail;\n      loop$prefix = rest$1;\n      loop$suffix = listPrepend(first$1, suffix);\n    }\n  }\n}\n\n/**\n * Creates a new list from a given list containing the same elements but in the\n * opposite order.\n *\n * This function has to traverse the list to create the new reversed list, so\n * it runs in linear time.\n *\n * This function is natively implemented by the virtual machine and is highly\n * optimised.\n *\n * ## Examples\n *\n * ```gleam\n * reverse([])\n * // -> []\n * ```\n *\n * ```gleam\n * reverse([1])\n * // -> [1]\n * ```\n *\n * ```gleam\n * reverse([1, 2])\n * // -> [2, 1]\n * ```\n */\nexport function reverse(list) {\n  return reverse_and_prepend(list, toList([]));\n}\n\n/**\n * Determines whether or not the list is empty.\n *\n * This function runs in constant time.\n *\n * ## Examples\n *\n * ```gleam\n * is_empty([])\n * // -> True\n * ```\n *\n * ```gleam\n * is_empty([1])\n * // -> False\n * ```\n *\n * ```gleam\n * is_empty([1, 1])\n * // -> False\n * ```\n */\nexport function is_empty(list) {\n  return isEqual(list, toList([]));\n}\n\n/**\n * Determines whether or not a given element exists within a given list.\n *\n * This function traverses the list to find the element, so it runs in linear\n * time.\n *\n * ## Examples\n *\n * ```gleam\n * [] |> contains(any: 0)\n * // -> False\n * ```\n *\n * ```gleam\n * [0] |> contains(any: 0)\n * // -> True\n * ```\n *\n * ```gleam\n * [1] |> contains(any: 0)\n * // -> False\n * ```\n *\n * ```gleam\n * [1, 1] |> contains(any: 0)\n * // -> False\n * ```\n *\n * ```gleam\n * [1, 0] |> contains(any: 0)\n * // -> True\n * ```\n */\nexport function contains(loop$list, loop$elem) {\n  while (true) {\n    let list = loop$list;\n    let elem = loop$elem;\n    if (list instanceof $Empty) {\n      return false;\n    } else {\n      let first$1 = list.head;\n      if (isEqual(first$1, elem)) {\n        return true;\n      } else {\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$elem = elem;\n      }\n    }\n  }\n}\n\n/**\n * Gets the first element from the start of the list, if there is one.\n *\n * ## Examples\n *\n * ```gleam\n * first([])\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * first([0])\n * // -> Ok(0)\n * ```\n *\n * ```gleam\n * first([1, 2])\n * // -> Ok(1)\n * ```\n */\nexport function first(list) {\n  if (list instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let first$1 = list.head;\n    return new Ok(first$1);\n  }\n}\n\n/**\n * Returns the list minus the first element. If the list is empty, `Error(Nil)` is\n * returned.\n *\n * This function runs in constant time and does not make a copy of the list.\n *\n * ## Examples\n *\n * ```gleam\n * rest([])\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * rest([0])\n * // -> Ok([])\n * ```\n *\n * ```gleam\n * rest([1, 2])\n * // -> Ok([2])\n * ```\n */\nexport function rest(list) {\n  if (list instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let rest$1 = list.tail;\n    return new Ok(rest$1);\n  }\n}\n\nfunction group_loop(loop$list, loop$to_key, loop$groups) {\n  while (true) {\n    let list = loop$list;\n    let to_key = loop$to_key;\n    let groups = loop$groups;\n    if (list instanceof $Empty) {\n      return groups;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let key = to_key(first$1);\n      let _block;\n      let $ = $dict.get(groups, key);\n      if ($ instanceof Ok) {\n        let existing = $[0];\n        _block = $dict.insert(groups, key, listPrepend(first$1, existing));\n      } else {\n        _block = $dict.insert(groups, key, toList([first$1]));\n      }\n      let groups$1 = _block;\n      loop$list = rest$1;\n      loop$to_key = to_key;\n      loop$groups = groups$1;\n    }\n  }\n}\n\n/**\n * Groups the elements from the given list by the given key function.\n *\n * Does not preserve the initial value order.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/dict\n *\n * [Ok(3), Error(\"Wrong\"), Ok(200), Ok(73)]\n * |> group(by: fn(i) {\n *   case i {\n *     Ok(_) -> \"Successful\"\n *     Error(_) -> \"Failed\"\n *   }\n * })\n * |> dict.to_list\n * // -> [\n * //   #(\"Failed\", [Error(\"Wrong\")]),\n * //   #(\"Successful\", [Ok(73), Ok(200), Ok(3)])\n * // ]\n * ```\n *\n * ```gleam\n * import gleam/dict\n *\n * group([1,2,3,4,5], by: fn(i) { i - i / 3 * 3 })\n * |> dict.to_list\n * // -> [#(0, [3]), #(1, [4, 1]), #(2, [5, 2])]\n * ```\n */\nexport function group(list, key) {\n  return group_loop(list, key, $dict.new$());\n}\n\nfunction filter_loop(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let _block;\n      let $ = fun(first$1);\n      if ($) {\n        _block = listPrepend(first$1, acc);\n      } else {\n        _block = acc;\n      }\n      let new_acc = _block;\n      loop$list = rest$1;\n      loop$fun = fun;\n      loop$acc = new_acc;\n    }\n  }\n}\n\n/**\n * Returns a new list containing only the elements from the first list for\n * which the given functions returns `True`.\n *\n * ## Examples\n *\n * ```gleam\n * filter([2, 4, 6, 1], fn(x) { x > 2 })\n * // -> [4, 6]\n * ```\n *\n * ```gleam\n * filter([2, 4, 6, 1], fn(x) { x > 6 })\n * // -> []\n * ```\n */\nexport function filter(list, predicate) {\n  return filter_loop(list, predicate, toList([]));\n}\n\nfunction filter_map_loop(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let _block;\n      let $ = fun(first$1);\n      if ($ instanceof Ok) {\n        let first$2 = $[0];\n        _block = listPrepend(first$2, acc);\n      } else {\n        _block = acc;\n      }\n      let new_acc = _block;\n      loop$list = rest$1;\n      loop$fun = fun;\n      loop$acc = new_acc;\n    }\n  }\n}\n\n/**\n * Returns a new list containing only the elements from the first list for\n * which the given functions returns `Ok(_)`.\n *\n * ## Examples\n *\n * ```gleam\n * filter_map([2, 4, 6, 1], Error)\n * // -> []\n * ```\n *\n * ```gleam\n * filter_map([2, 4, 6, 1], fn(x) { Ok(x + 1) })\n * // -> [3, 5, 7, 2]\n * ```\n */\nexport function filter_map(list, fun) {\n  return filter_map_loop(list, fun, toList([]));\n}\n\nfunction map_loop(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$fun = fun;\n      loop$acc = listPrepend(fun(first$1), acc);\n    }\n  }\n}\n\n/**\n * Returns a new list containing the results of applying the supplied function to each element.\n *\n * ## Examples\n *\n * ```gleam\n * map([2, 4, 6], fn(x) { x * 2 })\n * // -> [4, 8, 12]\n * ```\n */\nexport function map(list, fun) {\n  return map_loop(list, fun, toList([]));\n}\n\nfunction map2_loop(loop$list1, loop$list2, loop$fun, loop$acc) {\n  while (true) {\n    let list1 = loop$list1;\n    let list2 = loop$list2;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list1 instanceof $Empty) {\n      return reverse(acc);\n    } else if (list2 instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let a = list1.head;\n      let as_ = list1.tail;\n      let b = list2.head;\n      let bs = list2.tail;\n      loop$list1 = as_;\n      loop$list2 = bs;\n      loop$fun = fun;\n      loop$acc = listPrepend(fun(a, b), acc);\n    }\n  }\n}\n\n/**\n * Combines two lists into a single list using the given function.\n *\n * If a list is longer than the other the extra elements are dropped.\n *\n * ## Examples\n *\n * ```gleam\n * map2([1, 2, 3], [4, 5, 6], fn(x, y) { x + y })\n * // -> [5, 7, 9]\n * ```\n *\n * ```gleam\n * map2([1, 2], [\"a\", \"b\", \"c\"], fn(i, x) { #(i, x) })\n * // -> [#(1, \"a\"), #(2, \"b\")]\n * ```\n */\nexport function map2(list1, list2, fun) {\n  return map2_loop(list1, list2, fun, toList([]));\n}\n\nfunction map_fold_loop(loop$list, loop$fun, loop$acc, loop$list_acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    let list_acc = loop$list_acc;\n    if (list instanceof $Empty) {\n      return [acc, reverse(list_acc)];\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(acc, first$1);\n      let acc$1;\n      let first$2;\n      acc$1 = $[0];\n      first$2 = $[1];\n      loop$list = rest$1;\n      loop$fun = fun;\n      loop$acc = acc$1;\n      loop$list_acc = listPrepend(first$2, list_acc);\n    }\n  }\n}\n\n/**\n * Similar to `map` but also lets you pass around an accumulated value.\n *\n * ## Examples\n *\n * ```gleam\n * map_fold(\n *   over: [1, 2, 3],\n *   from: 100,\n *   with: fn(memo, i) { #(memo + i, i * 2) }\n * )\n * // -> #(106, [2, 4, 6])\n * ```\n */\nexport function map_fold(list, initial, fun) {\n  return map_fold_loop(list, fun, initial, toList([]));\n}\n\nfunction index_map_loop(loop$list, loop$fun, loop$index, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let index = loop$index;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let acc$1 = listPrepend(fun(first$1, index), acc);\n      loop$list = rest$1;\n      loop$fun = fun;\n      loop$index = index + 1;\n      loop$acc = acc$1;\n    }\n  }\n}\n\n/**\n * Similar to `map`, but the supplied function will also be passed the index\n * of the element being mapped as an additional argument.\n *\n * The index starts at 0, so the first element is 0, the second is 1, and so\n * on.\n *\n * ## Examples\n *\n * ```gleam\n * index_map([\"a\", \"b\"], fn(x, i) { #(i, x) })\n * // -> [#(0, \"a\"), #(1, \"b\")]\n * ```\n */\nexport function index_map(list, fun) {\n  return index_map_loop(list, fun, 0, toList([]));\n}\n\nfunction try_map_loop(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return new Ok(reverse(acc));\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(first$1);\n      if ($ instanceof Ok) {\n        let first$2 = $[0];\n        loop$list = rest$1;\n        loop$fun = fun;\n        loop$acc = listPrepend(first$2, acc);\n      } else {\n        return $;\n      }\n    }\n  }\n}\n\n/**\n * Takes a function that returns a `Result` and applies it to each element in a\n * given list in turn.\n *\n * If the function returns `Ok(new_value)` for all elements in the list then a\n * list of the new values is returned.\n *\n * If the function returns `Error(reason)` for any of the elements then it is\n * returned immediately. None of the elements in the list are processed after\n * one returns an `Error`.\n *\n * ## Examples\n *\n * ```gleam\n * try_map([1, 2, 3], fn(x) { Ok(x + 2) })\n * // -> Ok([3, 4, 5])\n * ```\n *\n * ```gleam\n * try_map([1, 2, 3], fn(_) { Error(0) })\n * // -> Error(0)\n * ```\n *\n * ```gleam\n * try_map([[1], [2, 3]], first)\n * // -> Ok([1, 2])\n * ```\n *\n * ```gleam\n * try_map([[1], [], [2]], first)\n * // -> Error(Nil)\n * ```\n */\nexport function try_map(list, fun) {\n  return try_map_loop(list, fun, toList([]));\n}\n\n/**\n * Returns a list that is the given list with up to the given number of\n * elements removed from the front of the list.\n *\n * If the element has less than the number of elements an empty list is\n * returned.\n *\n * This function runs in linear time but does not copy the list.\n *\n * ## Examples\n *\n * ```gleam\n * drop([1, 2, 3, 4], 2)\n * // -> [3, 4]\n * ```\n *\n * ```gleam\n * drop([1, 2, 3, 4], 9)\n * // -> []\n * ```\n */\nexport function drop(loop$list, loop$n) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let $ = n <= 0;\n    if ($) {\n      return list;\n    } else {\n      if (list instanceof $Empty) {\n        return list;\n      } else {\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$n = n - 1;\n      }\n    }\n  }\n}\n\nfunction take_loop(loop$list, loop$n, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let acc = loop$acc;\n    let $ = n <= 0;\n    if ($) {\n      return reverse(acc);\n    } else {\n      if (list instanceof $Empty) {\n        return reverse(acc);\n      } else {\n        let first$1 = list.head;\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$n = n - 1;\n        loop$acc = listPrepend(first$1, acc);\n      }\n    }\n  }\n}\n\n/**\n * Returns a list containing the first given number of elements from the given\n * list.\n *\n * If the element has less than the number of elements then the full list is\n * returned.\n *\n * This function runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * take([1, 2, 3, 4], 2)\n * // -> [1, 2]\n * ```\n *\n * ```gleam\n * take([1, 2, 3, 4], 9)\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function take(list, n) {\n  return take_loop(list, n, toList([]));\n}\n\n/**\n * Returns a new empty list.\n *\n * ## Examples\n *\n * ```gleam\n * new()\n * // -> []\n * ```\n */\nexport function new$() {\n  return toList([]);\n}\n\n/**\n * Returns the given item wrapped in a list.\n *\n * ## Examples\n *\n * ```gleam\n * wrap(1)\n * // -> [1]\n *\n * wrap([\"a\", \"b\", \"c\"])\n * // -> [[\"a\", \"b\", \"c\"]]\n *\n * wrap([[]])\n * // -> [[[]]]\n * ```\n */\nexport function wrap(item) {\n  return toList([item]);\n}\n\nfunction append_loop(loop$first, loop$second) {\n  while (true) {\n    let first = loop$first;\n    let second = loop$second;\n    if (first instanceof $Empty) {\n      return second;\n    } else {\n      let first$1 = first.head;\n      let rest$1 = first.tail;\n      loop$first = rest$1;\n      loop$second = listPrepend(first$1, second);\n    }\n  }\n}\n\n/**\n * Joins one list onto the end of another.\n *\n * This function runs in linear time, and it traverses and copies the first\n * list.\n *\n * ## Examples\n *\n * ```gleam\n * append([1, 2], [3])\n * // -> [1, 2, 3]\n * ```\n */\nexport function append(first, second) {\n  return append_loop(reverse(first), second);\n}\n\n/**\n * Prefixes an item to a list. This can also be done using the dedicated\n * syntax instead\n *\n * ```gleam\n * let existing_list = [2, 3, 4]\n *\n * [1, ..existing_list]\n * // -> [1, 2, 3, 4]\n *\n * prepend(to: existing_list, this: 1)\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function prepend(list, item) {\n  return listPrepend(item, list);\n}\n\nfunction flatten_loop(loop$lists, loop$acc) {\n  while (true) {\n    let lists = loop$lists;\n    let acc = loop$acc;\n    if (lists instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let list = lists.head;\n      let further_lists = lists.tail;\n      loop$lists = further_lists;\n      loop$acc = reverse_and_prepend(list, acc);\n    }\n  }\n}\n\n/**\n * Joins a list of lists into a single list.\n *\n * This function traverses all elements twice on the JavaScript target.\n * This function traverses all elements once on the Erlang target.\n *\n * ## Examples\n *\n * ```gleam\n * flatten([[1], [2, 3], []])\n * // -> [1, 2, 3]\n * ```\n */\nexport function flatten(lists) {\n  return flatten_loop(lists, toList([]));\n}\n\n/**\n * Maps the list with the given function into a list of lists, and then flattens it.\n *\n * ## Examples\n *\n * ```gleam\n * flat_map([2, 4, 6], fn(x) { [x, x + 1] })\n * // -> [2, 3, 4, 5, 6, 7]\n * ```\n */\nexport function flat_map(list, fun) {\n  return flatten(map(list, fun));\n}\n\n/**\n * Reduces a list of elements into a single value by calling a given function\n * on each element, going from left to right.\n *\n * `fold([1, 2, 3], 0, add)` is the equivalent of\n * `add(add(add(0, 1), 2), 3)`.\n *\n * This function runs in linear time.\n */\nexport function fold(loop$list, loop$initial, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return initial;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$initial = fun(initial, first$1);\n      loop$fun = fun;\n    }\n  }\n}\n\n/**\n * Reduces a list of elements into a single value by calling a given function\n * on each element, going from right to left.\n *\n * `fold_right([1, 2, 3], 0, add)` is the equivalent of\n * `add(add(add(0, 3), 2), 1)`.\n *\n * This function runs in linear time.\n *\n * Unlike `fold` this function is not tail recursive. Where possible use\n * `fold` instead as it will use less memory.\n */\nexport function fold_right(list, initial, fun) {\n  if (list instanceof $Empty) {\n    return initial;\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return fun(fold_right(rest$1, initial, fun), first$1);\n  }\n}\n\nfunction index_fold_loop(loop$over, loop$acc, loop$with, loop$index) {\n  while (true) {\n    let over = loop$over;\n    let acc = loop$acc;\n    let with$ = loop$with;\n    let index = loop$index;\n    if (over instanceof $Empty) {\n      return acc;\n    } else {\n      let first$1 = over.head;\n      let rest$1 = over.tail;\n      loop$over = rest$1;\n      loop$acc = with$(acc, first$1, index);\n      loop$with = with$;\n      loop$index = index + 1;\n    }\n  }\n}\n\n/**\n * Like fold but the folding function also receives the index of the current element.\n *\n * ## Examples\n *\n * ```gleam\n * [\"a\", \"b\", \"c\"]\n * |> index_fold(\"\", fn(acc, item, index) {\n *    acc <> int.to_string(index) <> \":\" <> item <> \" \"\n * })\n * // -> \"0:a 1:b 2:c\"\n * ```\n *\n * ```gleam\n * [10, 20, 30]\n * |> index_fold(0, fn(acc, item, index) { acc + item * index })\n * // -> 80\n * ```\n */\nexport function index_fold(list, initial, fun) {\n  return index_fold_loop(list, initial, fun, 0);\n}\n\n/**\n * A variant of fold that might fail.\n *\n * The folding function should return `Result(accumulator, error)`.\n * If the returned value is `Ok(accumulator)` try_fold will try the next value in the list.\n * If the returned value is `Error(error)` try_fold will stop and return that error.\n *\n * ## Examples\n *\n * ```gleam\n * [1, 2, 3, 4]\n * |> try_fold(0, fn(acc, i) {\n *   case i < 3 {\n *     True -> Ok(acc + i)\n *     False -> Error(Nil)\n *   }\n * })\n * // -> Error(Nil)\n * ```\n */\nexport function try_fold(loop$list, loop$initial, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return new Ok(initial);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(initial, first$1);\n      if ($ instanceof Ok) {\n        let result = $[0];\n        loop$list = rest$1;\n        loop$initial = result;\n        loop$fun = fun;\n      } else {\n        return $;\n      }\n    }\n  }\n}\n\n/**\n * A variant of fold that allows to stop folding earlier.\n *\n * The folding function should return `ContinueOrStop(accumulator)`.\n * If the returned value is `Continue(accumulator)` fold_until will try the next value in the list.\n * If the returned value is `Stop(accumulator)` fold_until will stop and return that accumulator.\n *\n * ## Examples\n *\n * ```gleam\n * [1, 2, 3, 4]\n * |> fold_until(0, fn(acc, i) {\n *   case i < 3 {\n *     True -> Continue(acc + i)\n *     False -> Stop(acc)\n *   }\n * })\n * // -> 3\n * ```\n */\nexport function fold_until(loop$list, loop$initial, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return initial;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(initial, first$1);\n      if ($ instanceof Continue) {\n        let next_accumulator = $[0];\n        loop$list = rest$1;\n        loop$initial = next_accumulator;\n        loop$fun = fun;\n      } else {\n        let b = $[0];\n        return b;\n      }\n    }\n  }\n}\n\n/**\n * Finds the first element in a given list for which the given function returns\n * `True`.\n *\n * Returns `Error(Nil)` if no such element is found.\n *\n * ## Examples\n *\n * ```gleam\n * find([1, 2, 3], fn(x) { x > 2 })\n * // -> Ok(3)\n * ```\n *\n * ```gleam\n * find([1, 2, 3], fn(x) { x > 4 })\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * find([], fn(_) { True })\n * // -> Error(Nil)\n * ```\n */\nexport function find(loop$list, loop$is_desired) {\n  while (true) {\n    let list = loop$list;\n    let is_desired = loop$is_desired;\n    if (list instanceof $Empty) {\n      return new Error(undefined);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = is_desired(first$1);\n      if ($) {\n        return new Ok(first$1);\n      } else {\n        loop$list = rest$1;\n        loop$is_desired = is_desired;\n      }\n    }\n  }\n}\n\n/**\n * Finds the first element in a given list for which the given function returns\n * `Ok(new_value)`, then returns the wrapped `new_value`.\n *\n * Returns `Error(Nil)` if no such element is found.\n *\n * ## Examples\n *\n * ```gleam\n * find_map([[], [2], [3]], first)\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * find_map([[], []], first)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * find_map([], first)\n * // -> Error(Nil)\n * ```\n */\nexport function find_map(loop$list, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return new Error(undefined);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(first$1);\n      if ($ instanceof Ok) {\n        return $;\n      } else {\n        loop$list = rest$1;\n        loop$fun = fun;\n      }\n    }\n  }\n}\n\n/**\n * Returns `True` if the given function returns `True` for all the elements in\n * the given list. If the function returns `False` for any of the elements it\n * immediately returns `False` without checking the rest of the list.\n *\n * ## Examples\n *\n * ```gleam\n * all([], fn(x) { x > 3 })\n * // -> True\n * ```\n *\n * ```gleam\n * all([4, 5], fn(x) { x > 3 })\n * // -> True\n * ```\n *\n * ```gleam\n * all([4, 3], fn(x) { x > 3 })\n * // -> False\n * ```\n */\nexport function all(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list instanceof $Empty) {\n      return true;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n      } else {\n        return $;\n      }\n    }\n  }\n}\n\n/**\n * Returns `True` if the given function returns `True` for any the elements in\n * the given list. If the function returns `True` for any of the elements it\n * immediately returns `True` without checking the rest of the list.\n *\n * ## Examples\n *\n * ```gleam\n * any([], fn(x) { x > 3 })\n * // -> False\n * ```\n *\n * ```gleam\n * any([4, 5], fn(x) { x > 3 })\n * // -> True\n * ```\n *\n * ```gleam\n * any([4, 3], fn(x) { x > 4 })\n * // -> False\n * ```\n *\n * ```gleam\n * any([3, 4], fn(x) { x > 3 })\n * // -> True\n * ```\n */\nexport function any(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list instanceof $Empty) {\n      return false;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        return $;\n      } else {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n      }\n    }\n  }\n}\n\nfunction zip_loop(loop$one, loop$other, loop$acc) {\n  while (true) {\n    let one = loop$one;\n    let other = loop$other;\n    let acc = loop$acc;\n    if (one instanceof $Empty) {\n      return reverse(acc);\n    } else if (other instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first_one = one.head;\n      let rest_one = one.tail;\n      let first_other = other.head;\n      let rest_other = other.tail;\n      loop$one = rest_one;\n      loop$other = rest_other;\n      loop$acc = listPrepend([first_one, first_other], acc);\n    }\n  }\n}\n\n/**\n * Takes two lists and returns a single list of 2-element tuples.\n *\n * If one of the lists is longer than the other, the remaining elements from\n * the longer list are not used.\n *\n * ## Examples\n *\n * ```gleam\n * zip([], [])\n * // -> []\n * ```\n *\n * ```gleam\n * zip([1, 2], [3])\n * // -> [#(1, 3)]\n * ```\n *\n * ```gleam\n * zip([1], [3, 4])\n * // -> [#(1, 3)]\n * ```\n *\n * ```gleam\n * zip([1, 2], [3, 4])\n * // -> [#(1, 3), #(2, 4)]\n * ```\n */\nexport function zip(list, other) {\n  return zip_loop(list, other, toList([]));\n}\n\nfunction strict_zip_loop(loop$one, loop$other, loop$acc) {\n  while (true) {\n    let one = loop$one;\n    let other = loop$other;\n    let acc = loop$acc;\n    if (one instanceof $Empty) {\n      if (other instanceof $Empty) {\n        return new Ok(reverse(acc));\n      } else {\n        return new Error(undefined);\n      }\n    } else if (other instanceof $Empty) {\n      return new Error(undefined);\n    } else {\n      let first_one = one.head;\n      let rest_one = one.tail;\n      let first_other = other.head;\n      let rest_other = other.tail;\n      loop$one = rest_one;\n      loop$other = rest_other;\n      loop$acc = listPrepend([first_one, first_other], acc);\n    }\n  }\n}\n\n/**\n * Takes two lists and returns a single list of 2-element tuples.\n *\n * If one of the lists is longer than the other, an `Error` is returned.\n *\n * ## Examples\n *\n * ```gleam\n * strict_zip([], [])\n * // -> Ok([])\n * ```\n *\n * ```gleam\n * strict_zip([1, 2], [3])\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * strict_zip([1], [3, 4])\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * strict_zip([1, 2], [3, 4])\n * // -> Ok([#(1, 3), #(2, 4)])\n * ```\n */\nexport function strict_zip(list, other) {\n  return strict_zip_loop(list, other, toList([]));\n}\n\nfunction unzip_loop(loop$input, loop$one, loop$other) {\n  while (true) {\n    let input = loop$input;\n    let one = loop$one;\n    let other = loop$other;\n    if (input instanceof $Empty) {\n      return [reverse(one), reverse(other)];\n    } else {\n      let rest$1 = input.tail;\n      let first_one = input.head[0];\n      let first_other = input.head[1];\n      loop$input = rest$1;\n      loop$one = listPrepend(first_one, one);\n      loop$other = listPrepend(first_other, other);\n    }\n  }\n}\n\n/**\n * Takes a single list of 2-element tuples and returns two lists.\n *\n * ## Examples\n *\n * ```gleam\n * unzip([#(1, 2), #(3, 4)])\n * // -> #([1, 3], [2, 4])\n * ```\n *\n * ```gleam\n * unzip([])\n * // -> #([], [])\n * ```\n */\nexport function unzip(input) {\n  return unzip_loop(input, toList([]), toList([]));\n}\n\nfunction intersperse_loop(loop$list, loop$separator, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let separator = loop$separator;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$separator = separator;\n      loop$acc = listPrepend(first$1, listPrepend(separator, acc));\n    }\n  }\n}\n\n/**\n * Inserts a given value between each existing element in a given list.\n *\n * This function runs in linear time and copies the list.\n *\n * ## Examples\n *\n * ```gleam\n * intersperse([1, 1, 1], 2)\n * // -> [1, 2, 1, 2, 1]\n * ```\n *\n * ```gleam\n * intersperse([], 2)\n * // -> []\n * ```\n */\nexport function intersperse(list, elem) {\n  if (list instanceof $Empty) {\n    return list;\n  } else {\n    let $ = list.tail;\n    if ($ instanceof $Empty) {\n      return list;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = $;\n      return intersperse_loop(rest$1, elem, toList([first$1]));\n    }\n  }\n}\n\nfunction unique_loop(loop$list, loop$seen, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let seen = loop$seen;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = $dict.has_key(seen, first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$seen = seen;\n        loop$acc = acc;\n      } else {\n        loop$list = rest$1;\n        loop$seen = $dict.insert(seen, first$1, undefined);\n        loop$acc = listPrepend(first$1, acc);\n      }\n    }\n  }\n}\n\n/**\n * Removes any duplicate elements from a given list.\n *\n * This function returns in loglinear time.\n *\n * ## Examples\n *\n * ```gleam\n * unique([1, 1, 1, 4, 7, 3, 3, 4])\n * // -> [1, 4, 7, 3]\n * ```\n */\nexport function unique(list) {\n  return unique_loop(list, $dict.new$(), toList([]));\n}\n\n/**\n * Given a list it returns slices of it that are locally sorted in ascending\n * order.\n *\n * Imagine you have this list:\n *\n * ```\n *   [1, 2, 3, 2, 1, 0]\n *    ^^^^^^^  ^^^^^^^ This is a slice in descending order\n *    |\n *    | This is a slice that is sorted in ascending order\n * ```\n *\n * So the produced result will contain these two slices, each one sorted in\n * ascending order: `[[1, 2, 3], [0, 1, 2]]`.\n *\n * - `growing` is an accumulator with the current slice being grown\n * - `direction` is the growing direction of the slice being grown, it could\n *   either be ascending or strictly descending\n * - `prev` is the previous element that needs to be added to the growing slice\n *   it is carried around to check whether we have to keep growing the current\n *   slice or not\n * - `acc` is the accumulator containing the slices sorted in ascending order\n * \n * @ignore\n */\nfunction sequences(\n  loop$list,\n  loop$compare,\n  loop$growing,\n  loop$direction,\n  loop$prev,\n  loop$acc\n) {\n  while (true) {\n    let list = loop$list;\n    let compare = loop$compare;\n    let growing = loop$growing;\n    let direction = loop$direction;\n    let prev = loop$prev;\n    let acc = loop$acc;\n    let growing$1 = listPrepend(prev, growing);\n    if (list instanceof $Empty) {\n      if (direction instanceof Ascending) {\n        return listPrepend(reverse(growing$1), acc);\n      } else {\n        return listPrepend(growing$1, acc);\n      }\n    } else {\n      let new$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = compare(prev, new$1);\n      if (direction instanceof Ascending) {\n        if ($ instanceof $order.Lt) {\n          loop$list = rest$1;\n          loop$compare = compare;\n          loop$growing = growing$1;\n          loop$direction = direction;\n          loop$prev = new$1;\n          loop$acc = acc;\n        } else if ($ instanceof $order.Eq) {\n          loop$list = rest$1;\n          loop$compare = compare;\n          loop$growing = growing$1;\n          loop$direction = direction;\n          loop$prev = new$1;\n          loop$acc = acc;\n        } else {\n          let _block;\n          if (direction instanceof Ascending) {\n            _block = listPrepend(reverse(growing$1), acc);\n          } else {\n            _block = listPrepend(growing$1, acc);\n          }\n          let acc$1 = _block;\n          if (rest$1 instanceof $Empty) {\n            return listPrepend(toList([new$1]), acc$1);\n          } else {\n            let next = rest$1.head;\n            let rest$2 = rest$1.tail;\n            let _block$1;\n            let $1 = compare(new$1, next);\n            if ($1 instanceof $order.Lt) {\n              _block$1 = new Ascending();\n            } else if ($1 instanceof $order.Eq) {\n              _block$1 = new Ascending();\n            } else {\n              _block$1 = new Descending();\n            }\n            let direction$1 = _block$1;\n            loop$list = rest$2;\n            loop$compare = compare;\n            loop$growing = toList([new$1]);\n            loop$direction = direction$1;\n            loop$prev = next;\n            loop$acc = acc$1;\n          }\n        }\n      } else if ($ instanceof $order.Lt) {\n        let _block;\n        if (direction instanceof Ascending) {\n          _block = listPrepend(reverse(growing$1), acc);\n        } else {\n          _block = listPrepend(growing$1, acc);\n        }\n        let acc$1 = _block;\n        if (rest$1 instanceof $Empty) {\n          return listPrepend(toList([new$1]), acc$1);\n        } else {\n          let next = rest$1.head;\n          let rest$2 = rest$1.tail;\n          let _block$1;\n          let $1 = compare(new$1, next);\n          if ($1 instanceof $order.Lt) {\n            _block$1 = new Ascending();\n          } else if ($1 instanceof $order.Eq) {\n            _block$1 = new Ascending();\n          } else {\n            _block$1 = new Descending();\n          }\n          let direction$1 = _block$1;\n          loop$list = rest$2;\n          loop$compare = compare;\n          loop$growing = toList([new$1]);\n          loop$direction = direction$1;\n          loop$prev = next;\n          loop$acc = acc$1;\n        }\n      } else if ($ instanceof $order.Eq) {\n        let _block;\n        if (direction instanceof Ascending) {\n          _block = listPrepend(reverse(growing$1), acc);\n        } else {\n          _block = listPrepend(growing$1, acc);\n        }\n        let acc$1 = _block;\n        if (rest$1 instanceof $Empty) {\n          return listPrepend(toList([new$1]), acc$1);\n        } else {\n          let next = rest$1.head;\n          let rest$2 = rest$1.tail;\n          let _block$1;\n          let $1 = compare(new$1, next);\n          if ($1 instanceof $order.Lt) {\n            _block$1 = new Ascending();\n          } else if ($1 instanceof $order.Eq) {\n            _block$1 = new Ascending();\n          } else {\n            _block$1 = new Descending();\n          }\n          let direction$1 = _block$1;\n          loop$list = rest$2;\n          loop$compare = compare;\n          loop$growing = toList([new$1]);\n          loop$direction = direction$1;\n          loop$prev = next;\n          loop$acc = acc$1;\n        }\n      } else {\n        loop$list = rest$1;\n        loop$compare = compare;\n        loop$growing = growing$1;\n        loop$direction = direction;\n        loop$prev = new$1;\n        loop$acc = acc;\n      }\n    }\n  }\n}\n\n/**\n * Merges two lists sorted in ascending order into a single list sorted in\n * descending order according to the given comparator function.\n *\n * This reversing of the sort order is not avoidable if we want to implement\n * merge as a tail recursive function. We could reverse the accumulator before\n * returning it but that would end up being less efficient; so the merging\n * algorithm has to play around this.\n * \n * @ignore\n */\nfunction merge_ascendings(loop$list1, loop$list2, loop$compare, loop$acc) {\n  while (true) {\n    let list1 = loop$list1;\n    let list2 = loop$list2;\n    let compare = loop$compare;\n    let acc = loop$acc;\n    if (list1 instanceof $Empty) {\n      let list = list2;\n      return reverse_and_prepend(list, acc);\n    } else if (list2 instanceof $Empty) {\n      let list = list1;\n      return reverse_and_prepend(list, acc);\n    } else {\n      let first1 = list1.head;\n      let rest1 = list1.tail;\n      let first2 = list2.head;\n      let rest2 = list2.tail;\n      let $ = compare(first1, first2);\n      if ($ instanceof $order.Lt) {\n        loop$list1 = rest1;\n        loop$list2 = list2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first1, acc);\n      } else if ($ instanceof $order.Eq) {\n        loop$list1 = list1;\n        loop$list2 = rest2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first2, acc);\n      } else {\n        loop$list1 = list1;\n        loop$list2 = rest2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first2, acc);\n      }\n    }\n  }\n}\n\n/**\n * Given a list of ascending lists, it merges adjacent pairs into a single\n * descending list, halving their number.\n * It returns a list of the remaining descending lists.\n * \n * @ignore\n */\nfunction merge_ascending_pairs(loop$sequences, loop$compare, loop$acc) {\n  while (true) {\n    let sequences = loop$sequences;\n    let compare = loop$compare;\n    let acc = loop$acc;\n    if (sequences instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let $ = sequences.tail;\n      if ($ instanceof $Empty) {\n        let sequence = sequences.head;\n        return reverse(listPrepend(reverse(sequence), acc));\n      } else {\n        let ascending1 = sequences.head;\n        let ascending2 = $.head;\n        let rest$1 = $.tail;\n        let descending = merge_ascendings(\n          ascending1,\n          ascending2,\n          compare,\n          toList([]),\n        );\n        loop$sequences = rest$1;\n        loop$compare = compare;\n        loop$acc = listPrepend(descending, acc);\n      }\n    }\n  }\n}\n\n/**\n * This is exactly the same as merge_ascendings but mirrored: it merges two\n * lists sorted in descending order into a single list sorted in ascending\n * order according to the given comparator function.\n *\n * This reversing of the sort order is not avoidable if we want to implement\n * merge as a tail recursive function. We could reverse the accumulator before\n * returning it but that would end up being less efficient; so the merging\n * algorithm has to play around this.\n * \n * @ignore\n */\nfunction merge_descendings(loop$list1, loop$list2, loop$compare, loop$acc) {\n  while (true) {\n    let list1 = loop$list1;\n    let list2 = loop$list2;\n    let compare = loop$compare;\n    let acc = loop$acc;\n    if (list1 instanceof $Empty) {\n      let list = list2;\n      return reverse_and_prepend(list, acc);\n    } else if (list2 instanceof $Empty) {\n      let list = list1;\n      return reverse_and_prepend(list, acc);\n    } else {\n      let first1 = list1.head;\n      let rest1 = list1.tail;\n      let first2 = list2.head;\n      let rest2 = list2.tail;\n      let $ = compare(first1, first2);\n      if ($ instanceof $order.Lt) {\n        loop$list1 = list1;\n        loop$list2 = rest2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first2, acc);\n      } else if ($ instanceof $order.Eq) {\n        loop$list1 = rest1;\n        loop$list2 = list2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first1, acc);\n      } else {\n        loop$list1 = rest1;\n        loop$list2 = list2;\n        loop$compare = compare;\n        loop$acc = listPrepend(first1, acc);\n      }\n    }\n  }\n}\n\n/**\n * This is the same as merge_ascending_pairs but flipped for descending lists.\n * \n * @ignore\n */\nfunction merge_descending_pairs(loop$sequences, loop$compare, loop$acc) {\n  while (true) {\n    let sequences = loop$sequences;\n    let compare = loop$compare;\n    let acc = loop$acc;\n    if (sequences instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let $ = sequences.tail;\n      if ($ instanceof $Empty) {\n        let sequence = sequences.head;\n        return reverse(listPrepend(reverse(sequence), acc));\n      } else {\n        let descending1 = sequences.head;\n        let descending2 = $.head;\n        let rest$1 = $.tail;\n        let ascending = merge_descendings(\n          descending1,\n          descending2,\n          compare,\n          toList([]),\n        );\n        loop$sequences = rest$1;\n        loop$compare = compare;\n        loop$acc = listPrepend(ascending, acc);\n      }\n    }\n  }\n}\n\n/**\n * Given some some sorted sequences (assumed to be sorted in `direction`) it\n * merges them all together until we're left with just a list sorted in\n * ascending order.\n * \n * @ignore\n */\nfunction merge_all(loop$sequences, loop$direction, loop$compare) {\n  while (true) {\n    let sequences = loop$sequences;\n    let direction = loop$direction;\n    let compare = loop$compare;\n    if (sequences instanceof $Empty) {\n      return sequences;\n    } else if (direction instanceof Ascending) {\n      let $ = sequences.tail;\n      if ($ instanceof $Empty) {\n        let sequence = sequences.head;\n        return sequence;\n      } else {\n        let sequences$1 = merge_ascending_pairs(sequences, compare, toList([]));\n        loop$sequences = sequences$1;\n        loop$direction = new Descending();\n        loop$compare = compare;\n      }\n    } else {\n      let $ = sequences.tail;\n      if ($ instanceof $Empty) {\n        let sequence = sequences.head;\n        return reverse(sequence);\n      } else {\n        let sequences$1 = merge_descending_pairs(sequences, compare, toList([]));\n        loop$sequences = sequences$1;\n        loop$direction = new Ascending();\n        loop$compare = compare;\n      }\n    }\n  }\n}\n\n/**\n * Sorts from smallest to largest based upon the ordering specified by a given\n * function.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * sort([4, 3, 6, 5, 4, 1, 2], by: int.compare)\n * // -> [1, 2, 3, 4, 4, 5, 6]\n * ```\n */\nexport function sort(list, compare) {\n  if (list instanceof $Empty) {\n    return list;\n  } else {\n    let $ = list.tail;\n    if ($ instanceof $Empty) {\n      return list;\n    } else {\n      let x = list.head;\n      let y = $.head;\n      let rest$1 = $.tail;\n      let _block;\n      let $1 = compare(x, y);\n      if ($1 instanceof $order.Lt) {\n        _block = new Ascending();\n      } else if ($1 instanceof $order.Eq) {\n        _block = new Ascending();\n      } else {\n        _block = new Descending();\n      }\n      let direction = _block;\n      let sequences$1 = sequences(\n        rest$1,\n        compare,\n        toList([x]),\n        direction,\n        y,\n        toList([]),\n      );\n      return merge_all(sequences$1, new Ascending(), compare);\n    }\n  }\n}\n\nfunction range_loop(loop$start, loop$stop, loop$acc) {\n  while (true) {\n    let start = loop$start;\n    let stop = loop$stop;\n    let acc = loop$acc;\n    let $ = $int.compare(start, stop);\n    if ($ instanceof $order.Lt) {\n      loop$start = start;\n      loop$stop = stop - 1;\n      loop$acc = listPrepend(stop, acc);\n    } else if ($ instanceof $order.Eq) {\n      return listPrepend(stop, acc);\n    } else {\n      loop$start = start;\n      loop$stop = stop + 1;\n      loop$acc = listPrepend(stop, acc);\n    }\n  }\n}\n\n/**\n * Creates a list of ints ranging from a given start and finish.\n *\n * ## Examples\n *\n * ```gleam\n * range(0, 0)\n * // -> [0]\n * ```\n *\n * ```gleam\n * range(0, 5)\n * // -> [0, 1, 2, 3, 4, 5]\n * ```\n *\n * ```gleam\n * range(1, -5)\n * // -> [1, 0, -1, -2, -3, -4, -5]\n * ```\n */\nexport function range(start, stop) {\n  return range_loop(start, stop, toList([]));\n}\n\nfunction repeat_loop(loop$item, loop$times, loop$acc) {\n  while (true) {\n    let item = loop$item;\n    let times = loop$times;\n    let acc = loop$acc;\n    let $ = times <= 0;\n    if ($) {\n      return acc;\n    } else {\n      loop$item = item;\n      loop$times = times - 1;\n      loop$acc = listPrepend(item, acc);\n    }\n  }\n}\n\n/**\n * Builds a list of a given value a given number of times.\n *\n * ## Examples\n *\n * ```gleam\n * repeat(\"a\", times: 0)\n * // -> []\n * ```\n *\n * ```gleam\n * repeat(\"a\", times: 5)\n * // -> [\"a\", \"a\", \"a\", \"a\", \"a\"]\n * ```\n */\nexport function repeat(a, times) {\n  return repeat_loop(a, times, toList([]));\n}\n\nfunction split_loop(loop$list, loop$n, loop$taken) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let taken = loop$taken;\n    let $ = n <= 0;\n    if ($) {\n      return [reverse(taken), list];\n    } else {\n      if (list instanceof $Empty) {\n        return [reverse(taken), toList([])];\n      } else {\n        let first$1 = list.head;\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$n = n - 1;\n        loop$taken = listPrepend(first$1, taken);\n      }\n    }\n  }\n}\n\n/**\n * Splits a list in two before the given index.\n *\n * If the list is not long enough to have the given index the before list will\n * be the input list, and the after list will be empty.\n *\n * ## Examples\n *\n * ```gleam\n * split([6, 7, 8, 9], 0)\n * // -> #([], [6, 7, 8, 9])\n * ```\n *\n * ```gleam\n * split([6, 7, 8, 9], 2)\n * // -> #([6, 7], [8, 9])\n * ```\n *\n * ```gleam\n * split([6, 7, 8, 9], 4)\n * // -> #([6, 7, 8, 9], [])\n * ```\n */\nexport function split(list, index) {\n  return split_loop(list, index, toList([]));\n}\n\nfunction split_while_loop(loop$list, loop$f, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return [reverse(acc), toList([])];\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = f(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$f = f;\n        loop$acc = listPrepend(first$1, acc);\n      } else {\n        return [reverse(acc), list];\n      }\n    }\n  }\n}\n\n/**\n * Splits a list in two before the first element that a given function returns\n * `False` for.\n *\n * If the function returns `True` for all elements the first list will be the\n * input list, and the second list will be empty.\n *\n * ## Examples\n *\n * ```gleam\n * split_while([1, 2, 3, 4, 5], fn(x) { x <= 3 })\n * // -> #([1, 2, 3], [4, 5])\n * ```\n *\n * ```gleam\n * split_while([1, 2, 3, 4, 5], fn(x) { x <= 5 })\n * // -> #([1, 2, 3, 4, 5], [])\n * ```\n */\nexport function split_while(list, predicate) {\n  return split_while_loop(list, predicate, toList([]));\n}\n\n/**\n * Given a list of 2-element tuples, finds the first tuple that has a given\n * key as the first element and returns the second element.\n *\n * If no tuple is found with the given key then `Error(Nil)` is returned.\n *\n * This function may be useful for interacting with Erlang code where lists of\n * tuples are common.\n *\n * ## Examples\n *\n * ```gleam\n * key_find([#(\"a\", 0), #(\"b\", 1)], \"a\")\n * // -> Ok(0)\n * ```\n *\n * ```gleam\n * key_find([#(\"a\", 0), #(\"b\", 1)], \"b\")\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * key_find([#(\"a\", 0), #(\"b\", 1)], \"c\")\n * // -> Error(Nil)\n * ```\n */\nexport function key_find(keyword_list, desired_key) {\n  return find_map(\n    keyword_list,\n    (keyword) => {\n      let key;\n      let value;\n      key = keyword[0];\n      value = keyword[1];\n      let $ = isEqual(key, desired_key);\n      if ($) {\n        return new Ok(value);\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\n/**\n * Given a list of 2-element tuples, finds all tuples that have a given\n * key as the first element and returns the second element.\n *\n * This function may be useful for interacting with Erlang code where lists of\n * tuples are common.\n *\n * ## Examples\n *\n * ```gleam\n * key_filter([#(\"a\", 0), #(\"b\", 1), #(\"a\", 2)], \"a\")\n * // -> [0, 2]\n * ```\n *\n * ```gleam\n * key_filter([#(\"a\", 0), #(\"b\", 1)], \"c\")\n * // -> []\n * ```\n */\nexport function key_filter(keyword_list, desired_key) {\n  return filter_map(\n    keyword_list,\n    (keyword) => {\n      let key;\n      let value;\n      key = keyword[0];\n      value = keyword[1];\n      let $ = isEqual(key, desired_key);\n      if ($) {\n        return new Ok(value);\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\nfunction key_pop_loop(loop$list, loop$key, loop$checked) {\n  while (true) {\n    let list = loop$list;\n    let key = loop$key;\n    let checked = loop$checked;\n    if (list instanceof $Empty) {\n      return new Error(undefined);\n    } else {\n      let k = list.head[0];\n      if (isEqual(k, key)) {\n        let rest$1 = list.tail;\n        let v = list.head[1];\n        return new Ok([v, reverse_and_prepend(checked, rest$1)]);\n      } else {\n        let first$1 = list.head;\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$key = key;\n        loop$checked = listPrepend(first$1, checked);\n      }\n    }\n  }\n}\n\n/**\n * Given a list of 2-element tuples, finds the first tuple that has a given\n * key as the first element. This function will return the second element\n * of the found tuple and list with tuple removed.\n *\n * If no tuple is found with the given key then `Error(Nil)` is returned.\n *\n * ## Examples\n *\n * ```gleam\n * key_pop([#(\"a\", 0), #(\"b\", 1)], \"a\")\n * // -> Ok(#(0, [#(\"b\", 1)]))\n * ```\n *\n * ```gleam\n * key_pop([#(\"a\", 0), #(\"b\", 1)], \"b\")\n * // -> Ok(#(1, [#(\"a\", 0)]))\n * ```\n *\n * ```gleam\n * key_pop([#(\"a\", 0), #(\"b\", 1)], \"c\")\n * // -> Error(Nil)\n * ```\n */\nexport function key_pop(list, key) {\n  return key_pop_loop(list, key, toList([]));\n}\n\nfunction key_set_loop(loop$list, loop$key, loop$value, loop$inspected) {\n  while (true) {\n    let list = loop$list;\n    let key = loop$key;\n    let value = loop$value;\n    let inspected = loop$inspected;\n    if (list instanceof $Empty) {\n      return reverse(listPrepend([key, value], inspected));\n    } else {\n      let k = list.head[0];\n      if (isEqual(k, key)) {\n        let rest$1 = list.tail;\n        return reverse_and_prepend(inspected, listPrepend([k, value], rest$1));\n      } else {\n        let first$1 = list.head;\n        let rest$1 = list.tail;\n        loop$list = rest$1;\n        loop$key = key;\n        loop$value = value;\n        loop$inspected = listPrepend(first$1, inspected);\n      }\n    }\n  }\n}\n\n/**\n * Given a list of 2-element tuples, inserts a key and value into the list.\n *\n * If there was already a tuple with the key then it is replaced, otherwise it\n * is added to the end of the list.\n *\n * ## Examples\n *\n * ```gleam\n * key_set([#(5, 0), #(4, 1)], 4, 100)\n * // -> [#(5, 0), #(4, 100)]\n * ```\n *\n * ```gleam\n * key_set([#(5, 0), #(4, 1)], 1, 100)\n * // -> [#(5, 0), #(4, 1), #(1, 100)]\n * ```\n */\nexport function key_set(list, key, value) {\n  return key_set_loop(list, key, value, toList([]));\n}\n\n/**\n * Calls a function for each element in a list, discarding the return value.\n *\n * Useful for calling a side effect for every item of a list.\n *\n * ```gleam\n * import gleam/io\n *\n * each([\"1\", \"2\", \"3\"], io.println)\n * // -> Nil\n * // 1\n * // 2\n * // 3\n * ```\n */\nexport function each(loop$list, loop$f) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    if (list instanceof $Empty) {\n      return undefined;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      f(first$1);\n      loop$list = rest$1;\n      loop$f = f;\n    }\n  }\n}\n\n/**\n * Calls a `Result` returning function for each element in a list, discarding\n * the return value. If the function returns `Error` then the iteration is\n * stopped and the error is returned.\n *\n * Useful for calling a side effect for every item of a list.\n *\n * ## Examples\n *\n * ```gleam\n * try_each(\n *   over: [1, 2, 3],\n *   with: function_that_might_fail,\n * )\n * // -> Ok(Nil)\n * ```\n */\nexport function try_each(loop$list, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return new Ok(undefined);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = fun(first$1);\n      if ($ instanceof Ok) {\n        loop$list = rest$1;\n        loop$fun = fun;\n      } else {\n        return $;\n      }\n    }\n  }\n}\n\nfunction partition_loop(loop$list, loop$categorise, loop$trues, loop$falses) {\n  while (true) {\n    let list = loop$list;\n    let categorise = loop$categorise;\n    let trues = loop$trues;\n    let falses = loop$falses;\n    if (list instanceof $Empty) {\n      return [reverse(trues), reverse(falses)];\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = categorise(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$categorise = categorise;\n        loop$trues = listPrepend(first$1, trues);\n        loop$falses = falses;\n      } else {\n        loop$list = rest$1;\n        loop$categorise = categorise;\n        loop$trues = trues;\n        loop$falses = listPrepend(first$1, falses);\n      }\n    }\n  }\n}\n\n/**\n * Partitions a list into a tuple/pair of lists\n * by a given categorisation function.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * [1, 2, 3, 4, 5] |> partition(int.is_odd)\n * // -> #([1, 3, 5], [2, 4])\n * ```\n */\nexport function partition(list, categorise) {\n  return partition_loop(list, categorise, toList([]), toList([]));\n}\n\nfunction window_loop(loop$acc, loop$list, loop$n) {\n  while (true) {\n    let acc = loop$acc;\n    let list = loop$list;\n    let n = loop$n;\n    let window$1 = take(list, n);\n    let $ = length(window$1) === n;\n    if ($) {\n      loop$acc = listPrepend(window$1, acc);\n      loop$list = drop(list, 1);\n      loop$n = n;\n    } else {\n      return reverse(acc);\n    }\n  }\n}\n\n/**\n * Returns a list of sliding windows.\n *\n * ## Examples\n *\n * ```gleam\n * window([1,2,3,4,5], 3)\n * // -> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n * ```\n *\n * ```gleam\n * window([1, 2], 4)\n * // -> []\n * ```\n */\nexport function window(list, n) {\n  let $ = n <= 0;\n  if ($) {\n    return toList([]);\n  } else {\n    return window_loop(toList([]), list, n);\n  }\n}\n\n/**\n * Returns a list of tuples containing two contiguous elements.\n *\n * ## Examples\n *\n * ```gleam\n * window_by_2([1,2,3,4])\n * // -> [#(1, 2), #(2, 3), #(3, 4)]\n * ```\n *\n * ```gleam\n * window_by_2([1])\n * // -> []\n * ```\n */\nexport function window_by_2(list) {\n  return zip(list, drop(list, 1));\n}\n\n/**\n * Drops the first elements in a given list for which the predicate function returns `True`.\n *\n * ## Examples\n *\n * ```gleam\n * drop_while([1, 2, 3, 4], fn (x) { x < 3 })\n * // -> [3, 4]\n * ```\n */\nexport function drop_while(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list instanceof $Empty) {\n      return list;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n      } else {\n        return listPrepend(first$1, rest$1);\n      }\n    }\n  }\n}\n\nfunction take_while_loop(loop$list, loop$predicate, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n        loop$acc = listPrepend(first$1, acc);\n      } else {\n        return reverse(acc);\n      }\n    }\n  }\n}\n\n/**\n * Takes the first elements in a given list for which the predicate function returns `True`.\n *\n * ## Examples\n *\n * ```gleam\n * take_while([1, 2, 3, 2, 4], fn (x) { x < 3 })\n * // -> [1, 2]\n * ```\n */\nexport function take_while(list, predicate) {\n  return take_while_loop(list, predicate, toList([]));\n}\n\nfunction chunk_loop(\n  loop$list,\n  loop$f,\n  loop$previous_key,\n  loop$current_chunk,\n  loop$acc\n) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    let previous_key = loop$previous_key;\n    let current_chunk = loop$current_chunk;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return reverse(listPrepend(reverse(current_chunk), acc));\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let key = f(first$1);\n      let $ = isEqual(key, previous_key);\n      if ($) {\n        loop$list = rest$1;\n        loop$f = f;\n        loop$previous_key = key;\n        loop$current_chunk = listPrepend(first$1, current_chunk);\n        loop$acc = acc;\n      } else {\n        let new_acc = listPrepend(reverse(current_chunk), acc);\n        loop$list = rest$1;\n        loop$f = f;\n        loop$previous_key = key;\n        loop$current_chunk = toList([first$1]);\n        loop$acc = new_acc;\n      }\n    }\n  }\n}\n\n/**\n * Returns a list of chunks in which\n * the return value of calling `f` on each element is the same.\n *\n * ## Examples\n *\n * ```gleam\n * [1, 2, 2, 3, 4, 4, 6, 7, 7] |> chunk(by: fn(n) { n % 2 })\n * // -> [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n * ```\n */\nexport function chunk(list, f) {\n  if (list instanceof $Empty) {\n    return list;\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return chunk_loop(rest$1, f, f(first$1), toList([first$1]), toList([]));\n  }\n}\n\nfunction sized_chunk_loop(\n  loop$list,\n  loop$count,\n  loop$left,\n  loop$current_chunk,\n  loop$acc\n) {\n  while (true) {\n    let list = loop$list;\n    let count = loop$count;\n    let left = loop$left;\n    let current_chunk = loop$current_chunk;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      if (current_chunk instanceof $Empty) {\n        return reverse(acc);\n      } else {\n        let remaining = current_chunk;\n        return reverse(listPrepend(reverse(remaining), acc));\n      }\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let chunk$1 = listPrepend(first$1, current_chunk);\n      let $ = left > 1;\n      if ($) {\n        loop$list = rest$1;\n        loop$count = count;\n        loop$left = left - 1;\n        loop$current_chunk = chunk$1;\n        loop$acc = acc;\n      } else {\n        loop$list = rest$1;\n        loop$count = count;\n        loop$left = count;\n        loop$current_chunk = toList([]);\n        loop$acc = listPrepend(reverse(chunk$1), acc);\n      }\n    }\n  }\n}\n\n/**\n * Returns a list of chunks containing `count` elements each.\n *\n * If the last chunk does not have `count` elements, it is instead\n * a partial chunk, with less than `count` elements.\n *\n * For any `count` less than 1 this function behaves as if it was set to 1.\n *\n * ## Examples\n *\n * ```gleam\n * [1, 2, 3, 4, 5, 6] |> sized_chunk(into: 2)\n * // -> [[1, 2], [3, 4], [5, 6]]\n * ```\n *\n * ```gleam\n * [1, 2, 3, 4, 5, 6, 7, 8] |> sized_chunk(into: 3)\n * // -> [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function sized_chunk(list, count) {\n  return sized_chunk_loop(list, count, count, toList([]), toList([]));\n}\n\n/**\n * This function acts similar to fold, but does not take an initial state.\n * Instead, it starts from the first element in the list\n * and combines it with each subsequent element in turn using the given\n * function. The function is called as `fun(accumulator, current_element)`.\n *\n * Returns `Ok` to indicate a successful run, and `Error` if called on an\n * empty list.\n *\n * ## Examples\n *\n * ```gleam\n * [] |> reduce(fn(acc, x) { acc + x })\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * [1, 2, 3, 4, 5] |> reduce(fn(acc, x) { acc + x })\n * // -> Ok(15)\n * ```\n */\nexport function reduce(list, fun) {\n  if (list instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return new Ok(fold(rest$1, first$1, fun));\n  }\n}\n\nfunction scan_loop(loop$list, loop$accumulator, loop$accumulated, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let accumulator = loop$accumulator;\n    let accumulated = loop$accumulated;\n    let fun = loop$fun;\n    if (list instanceof $Empty) {\n      return reverse(accumulated);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let next = fun(accumulator, first$1);\n      loop$list = rest$1;\n      loop$accumulator = next;\n      loop$accumulated = listPrepend(next, accumulated);\n      loop$fun = fun;\n    }\n  }\n}\n\n/**\n * Similar to `fold`, but yields the state of the accumulator at each stage.\n *\n * ## Examples\n *\n * ```gleam\n * scan(over: [1, 2, 3], from: 100, with: fn(acc, i) { acc + i })\n * // -> [101, 103, 106]\n * ```\n */\nexport function scan(list, initial, fun) {\n  return scan_loop(list, initial, toList([]), fun);\n}\n\n/**\n * Returns the last element in the given list.\n *\n * Returns `Error(Nil)` if the list is empty.\n *\n * This function runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * last([])\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * last([1, 2, 3, 4, 5])\n * // -> Ok(5)\n * ```\n */\nexport function last(loop$list) {\n  while (true) {\n    let list = loop$list;\n    if (list instanceof $Empty) {\n      return new Error(undefined);\n    } else {\n      let $ = list.tail;\n      if ($ instanceof $Empty) {\n        let last$1 = list.head;\n        return new Ok(last$1);\n      } else {\n        let rest$1 = $;\n        loop$list = rest$1;\n      }\n    }\n  }\n}\n\n/**\n * Return unique combinations of elements in the list.\n *\n * ## Examples\n *\n * ```gleam\n * combinations([1, 2, 3], 2)\n * // -> [[1, 2], [1, 3], [2, 3]]\n * ```\n *\n * ```gleam\n * combinations([1, 2, 3, 4], 3)\n * // -> [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n * ```\n */\nexport function combinations(items, n) {\n  if (n === 0) {\n    return toList([toList([])]);\n  } else if (items instanceof $Empty) {\n    return items;\n  } else {\n    let first$1 = items.head;\n    let rest$1 = items.tail;\n    let _pipe = rest$1;\n    let _pipe$1 = combinations(_pipe, n - 1);\n    let _pipe$2 = map(\n      _pipe$1,\n      (combination) => { return listPrepend(first$1, combination); },\n    );\n    let _pipe$3 = reverse(_pipe$2);\n    return fold(\n      _pipe$3,\n      combinations(rest$1, n),\n      (acc, c) => { return listPrepend(c, acc); },\n    );\n  }\n}\n\nfunction combination_pairs_loop(loop$items, loop$acc) {\n  while (true) {\n    let items = loop$items;\n    let acc = loop$acc;\n    if (items instanceof $Empty) {\n      return reverse(acc);\n    } else {\n      let first$1 = items.head;\n      let rest$1 = items.tail;\n      let first_combinations = map(\n        rest$1,\n        (other) => { return [first$1, other]; },\n      );\n      let acc$1 = reverse_and_prepend(first_combinations, acc);\n      loop$items = rest$1;\n      loop$acc = acc$1;\n    }\n  }\n}\n\n/**\n * Return unique pair combinations of elements in the list.\n *\n * ## Examples\n *\n * ```gleam\n * combination_pairs([1, 2, 3])\n * // -> [#(1, 2), #(1, 3), #(2, 3)]\n * ```\n */\nexport function combination_pairs(items) {\n  return combination_pairs_loop(items, toList([]));\n}\n\nfunction take_firsts(loop$rows, loop$column, loop$remaining_rows) {\n  while (true) {\n    let rows = loop$rows;\n    let column = loop$column;\n    let remaining_rows = loop$remaining_rows;\n    if (rows instanceof $Empty) {\n      return [reverse(column), reverse(remaining_rows)];\n    } else {\n      let $ = rows.head;\n      if ($ instanceof $Empty) {\n        let rest$1 = rows.tail;\n        loop$rows = rest$1;\n        loop$column = column;\n        loop$remaining_rows = remaining_rows;\n      } else {\n        let rest_rows = rows.tail;\n        let first$1 = $.head;\n        let remaining_row = $.tail;\n        let remaining_rows$1 = listPrepend(remaining_row, remaining_rows);\n        loop$rows = rest_rows;\n        loop$column = listPrepend(first$1, column);\n        loop$remaining_rows = remaining_rows$1;\n      }\n    }\n  }\n}\n\nfunction transpose_loop(loop$rows, loop$columns) {\n  while (true) {\n    let rows = loop$rows;\n    let columns = loop$columns;\n    if (rows instanceof $Empty) {\n      return reverse(columns);\n    } else {\n      let $ = take_firsts(rows, toList([]), toList([]));\n      let column;\n      let rest$1;\n      column = $[0];\n      rest$1 = $[1];\n      if (column instanceof $Empty) {\n        loop$rows = rest$1;\n        loop$columns = columns;\n      } else {\n        loop$rows = rest$1;\n        loop$columns = listPrepend(column, columns);\n      }\n    }\n  }\n}\n\n/**\n * Transpose rows and columns of the list of lists.\n *\n * Notice: This function is not tail recursive,\n * and thus may exceed stack size if called,\n * with large lists (on the JavaScript target).\n *\n * ## Examples\n *\n * ```gleam\n * transpose([[1, 2, 3], [101, 102, 103]])\n * // -> [[1, 101], [2, 102], [3, 103]]\n * ```\n */\nexport function transpose(list_of_lists) {\n  return transpose_loop(list_of_lists, toList([]));\n}\n\n/**\n * Make a list alternating the elements from the given lists\n *\n * ## Examples\n *\n * ```gleam\n * interleave([[1, 2], [101, 102], [201, 202]])\n * // -> [1, 101, 201, 2, 102, 202]\n * ```\n */\nexport function interleave(list) {\n  let _pipe = list;\n  let _pipe$1 = transpose(_pipe);\n  return flatten(_pipe$1);\n}\n\nfunction shuffle_pair_unwrap_loop(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list instanceof $Empty) {\n      return acc;\n    } else {\n      let elem_pair = list.head;\n      let enumerable = list.tail;\n      loop$list = enumerable;\n      loop$acc = listPrepend(elem_pair[1], acc);\n    }\n  }\n}\n\nfunction do_shuffle_by_pair_indexes(list_of_pairs) {\n  return sort(\n    list_of_pairs,\n    (a_pair, b_pair) => { return $float.compare(a_pair[0], b_pair[0]); },\n  );\n}\n\n/**\n * Takes a list, randomly sorts all items and returns the shuffled list.\n *\n * This function uses `float.random` to decide the order of the elements.\n *\n * ## Example\n *\n * ```gleam\n * range(1, 10) |> shuffle()\n * // -> [1, 6, 9, 10, 3, 8, 4, 2, 7, 5]\n * ```\n */\nexport function shuffle(list) {\n  let _pipe = list;\n  let _pipe$1 = fold(\n    _pipe,\n    toList([]),\n    (acc, a) => { return listPrepend([$float.random(), a], acc); },\n  );\n  let _pipe$2 = do_shuffle_by_pair_indexes(_pipe$1);\n  return shuffle_pair_unwrap_loop(_pipe$2, toList([]));\n}\n\nfunction max_loop(loop$list, loop$compare, loop$max) {\n  while (true) {\n    let list = loop$list;\n    let compare = loop$compare;\n    let max = loop$max;\n    if (list instanceof $Empty) {\n      return max;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = compare(first$1, max);\n      if ($ instanceof $order.Lt) {\n        loop$list = rest$1;\n        loop$compare = compare;\n        loop$max = max;\n      } else if ($ instanceof $order.Eq) {\n        loop$list = rest$1;\n        loop$compare = compare;\n        loop$max = max;\n      } else {\n        loop$list = rest$1;\n        loop$compare = compare;\n        loop$max = first$1;\n      }\n    }\n  }\n}\n\n/**\n * Takes a list and a comparator, and returns the maximum element in the list\n *\n *\n * ## Example\n *\n * ```gleam\n * range(1, 10) |> list.max(int.compare)\n * // -> Ok(10)\n * ```\n *\n * ```gleam\n * [\"a\", \"c\", \"b\"] |> list.max(string.compare)\n * // -> Ok(\"c\")\n * ```\n */\nexport function max(list, compare) {\n  if (list instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return new Ok(max_loop(rest$1, compare, first$1));\n  }\n}\n\nfunction build_reservoir_loop(loop$list, loop$size, loop$reservoir) {\n  while (true) {\n    let list = loop$list;\n    let size = loop$size;\n    let reservoir = loop$reservoir;\n    let reservoir_size = $dict.size(reservoir);\n    let $ = reservoir_size >= size;\n    if ($) {\n      return [reservoir, list];\n    } else {\n      if (list instanceof $Empty) {\n        return [reservoir, toList([])];\n      } else {\n        let first$1 = list.head;\n        let rest$1 = list.tail;\n        let reservoir$1 = $dict.insert(reservoir, reservoir_size, first$1);\n        loop$list = rest$1;\n        loop$size = size;\n        loop$reservoir = reservoir$1;\n      }\n    }\n  }\n}\n\n/**\n * Builds the initial reservoir used by Algorithm L.\n * This is a dictionary with keys ranging from `0` up to `n - 1` where each\n * value is the corresponding element at that position in `list`.\n *\n * This also returns the remaining elements of `list` that didn't end up in\n * the reservoir.\n * \n * @ignore\n */\nfunction build_reservoir(list, n) {\n  return build_reservoir_loop(list, n, $dict.new$());\n}\n\nfunction log_random() {\n  let $ = $float.logarithm($float.random() + min_positive);\n  let random;\n  if ($ instanceof Ok) {\n    random = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam/list\",\n      2390,\n      \"log_random\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 56050,\n        end: 56121,\n        pattern_start: 56061,\n        pattern_end: 56071\n      }\n    )\n  }\n  return random;\n}\n\nfunction sample_loop(loop$list, loop$reservoir, loop$n, loop$w) {\n  while (true) {\n    let list = loop$list;\n    let reservoir = loop$reservoir;\n    let n = loop$n;\n    let w = loop$w;\n    let _block;\n    {\n      let $ = $float.logarithm(1.0 - w);\n      let log;\n      if ($ instanceof Ok) {\n        log = $[0];\n      } else {\n        throw makeError(\n          \"let_assert\",\n          FILEPATH,\n          \"gleam/list\",\n          2373,\n          \"sample_loop\",\n          \"Pattern match failed, no pattern matched the value.\",\n          {\n            value: $,\n            start: 55611,\n            end: 55657,\n            pattern_start: 55622,\n            pattern_end: 55629\n          }\n        )\n      }\n      _block = $float.round($float.floor(divideFloat(log_random(), log)));\n    }\n    let skip = _block;\n    let $ = drop(list, skip);\n    if ($ instanceof $Empty) {\n      return reservoir;\n    } else {\n      let first$1 = $.head;\n      let rest$1 = $.tail;\n      let reservoir$1 = $dict.insert(reservoir, $int.random(n), first$1);\n      let w$1 = w * $float.exponential(\n        divideFloat(log_random(), $int.to_float(n)),\n      );\n      loop$list = rest$1;\n      loop$reservoir = reservoir$1;\n      loop$n = n;\n      loop$w = w$1;\n    }\n  }\n}\n\n/**\n * Returns a random sample of up to n elements from a list using reservoir\n * sampling via [Algorithm L](https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L).\n * Returns an empty list if the sample size is less than or equal to 0.\n *\n * Order is not random, only selection is.\n *\n * ## Examples\n *\n * ```gleam\n * reservoir_sample([1, 2, 3, 4, 5], 3)\n * // -> [2, 4, 5]  // A random sample of 3 items\n * ```\n */\nexport function sample(list, n) {\n  let $ = build_reservoir(list, n);\n  let reservoir;\n  let rest$1;\n  reservoir = $[0];\n  rest$1 = $[1];\n  let $1 = $dict.is_empty(reservoir);\n  if ($1) {\n    return toList([]);\n  } else {\n    let w = $float.exponential(divideFloat(log_random(), $int.to_float(n)));\n    return $dict.values(sample_loop(rest$1, reservoir, n, w));\n  }\n}\n\nfunction permutation_zip(list, rest, acc) {\n  if (list instanceof $Empty) {\n    return reverse(acc);\n  } else {\n    let head = list.head;\n    let tail = list.tail;\n    return permutation_prepend(\n      head,\n      permutations(reverse_and_prepend(rest, tail)),\n      tail,\n      listPrepend(head, rest),\n      acc,\n    );\n  }\n}\n\n/**\n * Returns all the permutations of a list.\n *\n * ## Examples\n *\n * ```gleam\n * permutations([1, 2])\n * // -> [[1, 2], [2, 1]]\n * ```\n */\nexport function permutations(list) {\n  if (list instanceof $Empty) {\n    return toList([toList([])]);\n  } else {\n    let l = list;\n    return permutation_zip(l, toList([]), toList([]));\n  }\n}\n\nfunction permutation_prepend(\n  loop$el,\n  loop$permutations,\n  loop$list_1,\n  loop$list_2,\n  loop$acc\n) {\n  while (true) {\n    let el = loop$el;\n    let permutations = loop$permutations;\n    let list_1 = loop$list_1;\n    let list_2 = loop$list_2;\n    let acc = loop$acc;\n    if (permutations instanceof $Empty) {\n      return permutation_zip(list_1, list_2, acc);\n    } else {\n      let head = permutations.head;\n      let tail = permutations.tail;\n      loop$el = el;\n      loop$permutations = tail;\n      loop$list_1 = list_1;\n      loop$list_2 = list_2;\n      loop$acc = listPrepend(listPrepend(el, head), acc);\n    }\n  }\n}\n","import {\n  BitArray,\n  Error,\n  List,\n  Ok,\n  Result,\n  UtfCodepoint,\n  stringBits,\n  toBitArray,\n  bitArraySlice,\n  NonEmpty,\n  Empty,\n  CustomType,\n} from \"./gleam.mjs\";\nimport { Some, None } from \"./gleam/option.mjs\";\nimport Dict from \"./dict.mjs\";\nimport { classify } from \"./gleam/dynamic.mjs\";\nimport { DecodeError } from \"./gleam/dynamic/decode.mjs\";\n\nconst Nil = undefined;\nconst NOT_FOUND = {};\n\nexport function identity(x) {\n  return x;\n}\n\nexport function parse_int(value) {\n  if (/^[-+]?(\\d+)$/.test(value)) {\n    return new Ok(parseInt(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function parse_float(value) {\n  if (/^[-+]?(\\d+)\\.(\\d+)([eE][-+]?\\d+)?$/.test(value)) {\n    return new Ok(parseFloat(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function to_string(term) {\n  return term.toString();\n}\n\nexport function int_to_base_string(int, base) {\n  return int.toString(base).toUpperCase();\n}\n\nconst int_base_patterns = {\n  2: /[^0-1]/,\n  3: /[^0-2]/,\n  4: /[^0-3]/,\n  5: /[^0-4]/,\n  6: /[^0-5]/,\n  7: /[^0-6]/,\n  8: /[^0-7]/,\n  9: /[^0-8]/,\n  10: /[^0-9]/,\n  11: /[^0-9a]/,\n  12: /[^0-9a-b]/,\n  13: /[^0-9a-c]/,\n  14: /[^0-9a-d]/,\n  15: /[^0-9a-e]/,\n  16: /[^0-9a-f]/,\n  17: /[^0-9a-g]/,\n  18: /[^0-9a-h]/,\n  19: /[^0-9a-i]/,\n  20: /[^0-9a-j]/,\n  21: /[^0-9a-k]/,\n  22: /[^0-9a-l]/,\n  23: /[^0-9a-m]/,\n  24: /[^0-9a-n]/,\n  25: /[^0-9a-o]/,\n  26: /[^0-9a-p]/,\n  27: /[^0-9a-q]/,\n  28: /[^0-9a-r]/,\n  29: /[^0-9a-s]/,\n  30: /[^0-9a-t]/,\n  31: /[^0-9a-u]/,\n  32: /[^0-9a-v]/,\n  33: /[^0-9a-w]/,\n  34: /[^0-9a-x]/,\n  35: /[^0-9a-y]/,\n  36: /[^0-9a-z]/,\n};\n\nexport function int_from_base_string(string, base) {\n  if (int_base_patterns[base].test(string.replace(/^-/, \"\").toLowerCase())) {\n    return new Error(Nil);\n  }\n\n  const result = parseInt(string, base);\n\n  if (isNaN(result)) {\n    return new Error(Nil);\n  }\n\n  return new Ok(result);\n}\n\nexport function string_replace(string, target, substitute) {\n  return string.replaceAll(target, substitute);\n}\n\nexport function string_reverse(string) {\n  return [...string].reverse().join(\"\");\n}\n\nexport function string_length(string) {\n  if (string === \"\") {\n    return 0;\n  }\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    let i = 0;\n    for (const _ of iterator) {\n      i++;\n    }\n    return i;\n  } else {\n    return string.match(/./gsu).length;\n  }\n}\n\nexport function graphemes(string) {\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    return List.fromArray(Array.from(iterator).map((item) => item.segment));\n  } else {\n    return List.fromArray(string.match(/./gsu));\n  }\n}\n\nlet segmenter = undefined;\n\nfunction graphemes_iterator(string) {\n  if (globalThis.Intl && Intl.Segmenter) {\n    segmenter ||= new Intl.Segmenter();\n    return segmenter.segment(string)[Symbol.iterator]();\n  }\n}\n\nexport function pop_grapheme(string) {\n  let first;\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    first = iterator.next().value?.segment;\n  } else {\n    first = string.match(/./su)?.[0];\n  }\n  if (first) {\n    return new Ok([first, string.slice(first.length)]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function pop_codeunit(str) {\n  return [str.charCodeAt(0) | 0, str.slice(1)];\n}\n\nexport function lowercase(string) {\n  return string.toLowerCase();\n}\n\nexport function uppercase(string) {\n  return string.toUpperCase();\n}\n\nexport function less_than(a, b) {\n  return a < b;\n}\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function split(xs, pattern) {\n  return List.fromArray(xs.split(pattern));\n}\n\nexport function concat(xs) {\n  let result = \"\";\n  for (const x of xs) {\n    result = result + x;\n  }\n  return result;\n}\n\nexport function length(data) {\n  return data.length;\n}\n\nexport function string_byte_slice(string, index, length) {\n  return string.slice(index, index + length);\n}\n\nexport function string_grapheme_slice(string, idx, len) {\n  if (len <= 0 || idx >= string.length) {\n    return \"\";\n  }\n\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    while (idx-- > 0) {\n      iterator.next();\n    }\n\n    let result = \"\";\n\n    while (len-- > 0) {\n      const v = iterator.next().value;\n      if (v === undefined) {\n        break;\n      }\n\n      result += v.segment;\n    }\n\n    return result;\n  } else {\n    return string\n      .match(/./gsu)\n      .slice(idx, idx + len)\n      .join(\"\");\n  }\n}\n\nexport function string_codeunit_slice(str, from, length) {\n  return str.slice(from, from + length);\n}\nexport function crop_string(string, substring) {\n  return string.substring(string.indexOf(substring));\n}\n\nexport function contains_string(haystack, needle) {\n  return haystack.indexOf(needle) >= 0;\n}\n\nexport function starts_with(haystack, needle) {\n  return haystack.startsWith(needle);\n}\n\nexport function ends_with(haystack, needle) {\n  return haystack.endsWith(needle);\n}\n\nexport function split_once(haystack, needle) {\n  const index = haystack.indexOf(needle);\n  if (index >= 0) {\n    const before = haystack.slice(0, index);\n    const after = haystack.slice(index + needle.length);\n    return new Ok([before, after]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nconst unicode_whitespaces = [\n  \"\\u0020\", // Space\n  \"\\u0009\", // Horizontal tab\n  \"\\u000A\", // Line feed\n  \"\\u000B\", // Vertical tab\n  \"\\u000C\", // Form feed\n  \"\\u000D\", // Carriage return\n  \"\\u0085\", // Next line\n  \"\\u2028\", // Line separator\n  \"\\u2029\", // Paragraph separator\n].join(\"\");\n\nconst trim_start_regex = /* @__PURE__ */ new RegExp(\n  `^[${unicode_whitespaces}]*`,\n);\nconst trim_end_regex = /* @__PURE__ */ new RegExp(`[${unicode_whitespaces}]*$`);\n\nexport function trim_start(string) {\n  return string.replace(trim_start_regex, \"\");\n}\n\nexport function trim_end(string) {\n  return string.replace(trim_end_regex, \"\");\n}\n\nexport function bit_array_from_string(string) {\n  return toBitArray([stringBits(string)]);\n}\n\nexport function bit_array_bit_size(bit_array) {\n  return bit_array.bitSize;\n}\n\nexport function bit_array_byte_size(bit_array) {\n  return bit_array.byteSize;\n}\n\nexport function bit_array_pad_to_bytes(bit_array) {\n  const trailingBitsCount = bit_array.bitSize % 8;\n\n  // If the bit array is a whole number of bytes it can be returned unchanged\n  if (trailingBitsCount === 0) {\n    return bit_array;\n  }\n\n  const finalByte = bit_array.byteAt(bit_array.byteSize - 1);\n\n  // The required final byte has its unused trailing bits set to zero\n  const unusedBitsCount = 8 - trailingBitsCount;\n  const correctFinalByte = (finalByte >> unusedBitsCount) << unusedBitsCount;\n\n  // If the unused bits in the final byte are already set to zero then the\n  // existing buffer can be re-used, avoiding a copy\n  if (finalByte === correctFinalByte) {\n    return new BitArray(\n      bit_array.rawBuffer,\n      bit_array.byteSize * 8,\n      bit_array.bitOffset,\n    );\n  }\n\n  // Copy the bit array into a new aligned buffer and set the correct final byte\n  const buffer = new Uint8Array(bit_array.byteSize);\n  for (let i = 0; i < buffer.length - 1; i++) {\n    buffer[i] = bit_array.byteAt(i);\n  }\n  buffer[buffer.length - 1] = correctFinalByte;\n\n  return new BitArray(buffer);\n}\n\nexport function bit_array_concat(bit_arrays) {\n  return toBitArray(bit_arrays.toArray());\n}\n\nexport function console_log(term) {\n  console.log(term);\n}\n\nexport function console_error(term) {\n  console.error(term);\n}\n\nexport function crash(message) {\n  throw new globalThis.Error(message);\n}\n\nexport function bit_array_to_string(bit_array) {\n  // If the bit array isn't a whole number of bytes then return an error\n  if (bit_array.bitSize % 8 !== 0) {\n    return new Error(Nil);\n  }\n\n  try {\n    const decoder = new TextDecoder(\"utf-8\", { fatal: true });\n\n    if (bit_array.bitOffset === 0) {\n      return new Ok(decoder.decode(bit_array.rawBuffer));\n    } else {\n      // The input data isn't aligned, so copy it into a new aligned buffer so\n      // that TextDecoder can be used\n      const buffer = new Uint8Array(bit_array.byteSize);\n      for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = bit_array.byteAt(i);\n      }\n      return new Ok(decoder.decode(buffer));\n    }\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function print(string) {\n  if (typeof process === \"object\" && process.stdout?.write) {\n    process.stdout.write(string); // We can write without a trailing newline\n  } else if (typeof Deno === \"object\") {\n    Deno.stdout.writeSync(new TextEncoder().encode(string)); // We can write without a trailing newline\n  } else {\n    console.log(string); // We're in a browser. Newlines are mandated\n  }\n}\n\nexport function print_error(string) {\n  if (typeof process === \"object\" && process.stderr?.write) {\n    process.stderr.write(string); // We can write without a trailing newline\n  } else if (typeof Deno === \"object\") {\n    Deno.stderr.writeSync(new TextEncoder().encode(string)); // We can write without a trailing newline\n  } else {\n    console.error(string); // We're in a browser. Newlines are mandated\n  }\n}\n\nexport function print_debug(string) {\n  if (typeof process === \"object\" && process.stderr?.write) {\n    process.stderr.write(string + \"\\n\"); // If we're in Node.js, use `stderr`\n  } else if (typeof Deno === \"object\") {\n    Deno.stderr.writeSync(new TextEncoder().encode(string + \"\\n\")); // If we're in Deno, use `stderr`\n  } else {\n    console.log(string); // Otherwise, use `console.log` (so that it doesn't look like an error)\n  }\n}\n\nexport function ceiling(float) {\n  return Math.ceil(float);\n}\n\nexport function floor(float) {\n  return Math.floor(float);\n}\n\nexport function round(float) {\n  return Math.round(float);\n}\n\nexport function truncate(float) {\n  return Math.trunc(float);\n}\n\nexport function power(base, exponent) {\n  // It is checked in Gleam that:\n  // - The base is non-negative and that the exponent is not fractional.\n  // - The base is non-zero and the exponent is non-negative (otherwise\n  //   the result will essentially be division by zero).\n  // It can thus be assumed that valid input is passed to the Math.pow\n  // function and a NaN or Infinity value will not be produced.\n  return Math.pow(base, exponent);\n}\n\nexport function random_uniform() {\n  const random_uniform_result = Math.random();\n  // With round-to-nearest-even behavior, the ranges claimed for the functions below\n  // (excluding the one for Math.random() itself) aren't exact.\n  // If extremely large bounds are chosen (2^53 or higher),\n  // it's possible in extremely rare cases to calculate the usually-excluded upper bound.\n  // Note that as numbers in JavaScript are IEEE 754 floating point numbers\n  // See: <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random>\n  // Because of this, we just loop 'until' we get a valid result where 0.0 <= x < 1.0:\n  if (random_uniform_result === 1.0) {\n    return random_uniform();\n  }\n  return random_uniform_result;\n}\n\nexport function bit_array_slice(bits, position, length) {\n  const start = Math.min(position, position + length);\n  const end = Math.max(position, position + length);\n\n  if (start < 0 || end * 8 > bits.bitSize) {\n    return new Error(Nil);\n  }\n\n  return new Ok(bitArraySlice(bits, start * 8, end * 8));\n}\n\nexport function codepoint(int) {\n  return new UtfCodepoint(int);\n}\n\nexport function string_to_codepoint_integer_list(string) {\n  return List.fromArray(Array.from(string).map((item) => item.codePointAt(0)));\n}\n\nexport function utf_codepoint_list_to_string(utf_codepoint_integer_list) {\n  return utf_codepoint_integer_list\n    .toArray()\n    .map((x) => String.fromCodePoint(x.value))\n    .join(\"\");\n}\n\nexport function utf_codepoint_to_int(utf_codepoint) {\n  return utf_codepoint.value;\n}\n\nexport function new_map() {\n  return Dict.new();\n}\n\nexport function map_size(map) {\n  return map.size;\n}\n\nexport function map_to_list(map) {\n  return List.fromArray(map.entries());\n}\n\nexport function map_remove(key, map) {\n  return map.delete(key);\n}\n\nexport function map_get(map, key) {\n  const value = map.get(key, NOT_FOUND);\n  if (value === NOT_FOUND) {\n    return new Error(Nil);\n  }\n  return new Ok(value);\n}\n\nexport function map_insert(key, value, map) {\n  return map.set(key, value);\n}\n\nfunction unsafe_percent_decode(string) {\n  return decodeURIComponent(string || \"\");\n}\n\nfunction unsafe_percent_decode_query(string) {\n  return decodeURIComponent((string || \"\").replace(\"+\", \" \"));\n}\n\nexport function percent_decode(string) {\n  try {\n    return new Ok(unsafe_percent_decode(string));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function percent_encode(string) {\n  return encodeURIComponent(string).replace(\"%2B\", \"+\");\n}\n\nexport function parse_query(query) {\n  try {\n    const pairs = [];\n    for (const section of query.split(\"&\")) {\n      const [key, value] = section.split(\"=\");\n      if (!key) continue;\n\n      const decodedKey = unsafe_percent_decode_query(key);\n      const decodedValue = unsafe_percent_decode_query(value);\n      pairs.push([decodedKey, decodedValue]);\n    }\n    return new Ok(List.fromArray(pairs));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nconst b64EncodeLookup = [\n  65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n  84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\n  107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n  122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47,\n];\n\nlet b64TextDecoder;\n\n// Implementation based on https://github.com/mitschabaude/fast-base64/blob/main/js.js\nexport function base64_encode(bit_array, padding) {\n  b64TextDecoder ??= new TextDecoder();\n\n  bit_array = bit_array_pad_to_bytes(bit_array);\n\n  const m = bit_array.byteSize;\n  const k = m % 3;\n  const n = Math.floor(m / 3) * 4 + (k && k + 1);\n  const N = Math.ceil(m / 3) * 4;\n  const encoded = new Uint8Array(N);\n\n  for (let i = 0, j = 0; j < m; i += 4, j += 3) {\n    const y =\n      (bit_array.byteAt(j) << 16) +\n      (bit_array.byteAt(j + 1) << 8) +\n      (bit_array.byteAt(j + 2) | 0);\n\n    encoded[i] = b64EncodeLookup[y >> 18];\n    encoded[i + 1] = b64EncodeLookup[(y >> 12) & 0x3f];\n    encoded[i + 2] = b64EncodeLookup[(y >> 6) & 0x3f];\n    encoded[i + 3] = b64EncodeLookup[y & 0x3f];\n  }\n\n  let base64 = b64TextDecoder.decode(new Uint8Array(encoded.buffer, 0, n));\n\n  if (padding) {\n    if (k === 1) {\n      base64 += \"==\";\n    } else if (k === 2) {\n      base64 += \"=\";\n    }\n  }\n\n  return base64;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64\nexport function base64_decode(sBase64) {\n  try {\n    const binString = atob(sBase64);\n    const length = binString.length;\n    const array = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      array[i] = binString.charCodeAt(i);\n    }\n    return new Ok(new BitArray(array));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function classify_dynamic(data) {\n  if (typeof data === \"string\") {\n    return \"String\";\n  } else if (typeof data === \"boolean\") {\n    return \"Bool\";\n  } else if (data instanceof Result) {\n    return \"Result\";\n  } else if (data instanceof List) {\n    return \"List\";\n  } else if (data instanceof BitArray) {\n    return \"BitArray\";\n  } else if (data instanceof Dict) {\n    return \"Dict\";\n  } else if (Number.isInteger(data)) {\n    return \"Int\";\n  } else if (Array.isArray(data)) {\n    return `Array`;\n  } else if (typeof data === \"number\") {\n    return \"Float\";\n  } else if (data === null) {\n    return \"Nil\";\n  } else if (data === undefined) {\n    return \"Nil\";\n  } else {\n    const type = typeof data;\n    return type.charAt(0).toUpperCase() + type.slice(1);\n  }\n}\n\nexport function byte_size(string) {\n  return new TextEncoder().encode(string).length;\n}\n\n// In JavaScript bitwise operations convert numbers to a sequence of 32 bits\n// while Erlang uses arbitrary precision.\n// To get around this problem and get consistent results use BigInt and then\n// downcast the value back to a Number value.\n\nexport function bitwise_and(x, y) {\n  return Number(BigInt(x) & BigInt(y));\n}\n\nexport function bitwise_not(x) {\n  return Number(~BigInt(x));\n}\n\nexport function bitwise_or(x, y) {\n  return Number(BigInt(x) | BigInt(y));\n}\n\nexport function bitwise_exclusive_or(x, y) {\n  return Number(BigInt(x) ^ BigInt(y));\n}\n\nexport function bitwise_shift_left(x, y) {\n  return Number(BigInt(x) << BigInt(y));\n}\n\nexport function bitwise_shift_right(x, y) {\n  return Number(BigInt(x) >> BigInt(y));\n}\n\nexport function inspect(v) {\n  return new Inspector().inspect(v);\n}\n\nexport function float_to_string(float) {\n  const string = float.toString().replace(\"+\", \"\");\n  if (string.indexOf(\".\") >= 0) {\n    return string;\n  } else {\n    const index = string.indexOf(\"e\");\n    if (index >= 0) {\n      return string.slice(0, index) + \".0\" + string.slice(index);\n    } else {\n      return string + \".0\";\n    }\n  }\n}\n\nclass Inspector {\n  #references = new Set();\n\n  inspect(v) {\n    const t = typeof v;\n    if (v === true) return \"True\";\n    if (v === false) return \"False\";\n    if (v === null) return \"//js(null)\";\n    if (v === undefined) return \"Nil\";\n    if (t === \"string\") return this.#string(v);\n    if (t === \"bigint\" || Number.isInteger(v)) return v.toString();\n    if (t === \"number\") return float_to_string(v);\n    if (v instanceof UtfCodepoint) return this.#utfCodepoint(v);\n    if (v instanceof BitArray) return this.#bit_array(v);\n    if (v instanceof RegExp) return `//js(${v})`;\n    if (v instanceof Date) return `//js(Date(\"${v.toISOString()}\"))`;\n    if (v instanceof globalThis.Error) return `//js(${v.toString()})`;\n    if (v instanceof Function) {\n      const args = [];\n      for (const i of Array(v.length).keys())\n        args.push(String.fromCharCode(i + 97));\n      return `//fn(${args.join(\", \")}) { ... }`;\n    }\n\n    if (this.#references.size === this.#references.add(v).size) {\n      return \"//js(circular reference)\";\n    }\n\n    let printed;\n    if (Array.isArray(v)) {\n      printed = `#(${v.map((v) => this.inspect(v)).join(\", \")})`;\n    } else if (v instanceof List) {\n      printed = this.#list(v);\n    } else if (v instanceof CustomType) {\n      printed = this.#customType(v);\n    } else if (v instanceof Dict) {\n      printed = this.#dict(v);\n    } else if (v instanceof Set) {\n      return `//js(Set(${[...v].map((v) => this.inspect(v)).join(\", \")}))`;\n    } else {\n      printed = this.#object(v);\n    }\n    this.#references.delete(v);\n    return printed;\n  }\n\n  #object(v) {\n    const name = Object.getPrototypeOf(v)?.constructor?.name || \"Object\";\n    const props = [];\n    for (const k of Object.keys(v)) {\n      props.push(`${this.inspect(k)}: ${this.inspect(v[k])}`);\n    }\n    const body = props.length ? \" \" + props.join(\", \") + \" \" : \"\";\n    const head = name === \"Object\" ? \"\" : name + \" \";\n    return `//js(${head}{${body}})`;\n  }\n\n  #dict(map) {\n    let body = \"dict.from_list([\";\n    let first = true;\n    map.forEach((value, key) => {\n      if (!first) body = body + \", \";\n      body = body + \"#(\" + this.inspect(key) + \", \" + this.inspect(value) + \")\";\n      first = false;\n    });\n    return body + \"])\";\n  }\n\n  #customType(record) {\n    const props = Object.keys(record)\n      .map((label) => {\n        const value = this.inspect(record[label]);\n        return isNaN(parseInt(label)) ? `${label}: ${value}` : value;\n      })\n      .join(\", \");\n    return props\n      ? `${record.constructor.name}(${props})`\n      : record.constructor.name;\n  }\n\n  #list(list) {\n    if (list instanceof Empty) {\n      return \"[]\";\n    }\n\n    let char_out = 'charlist.from_string(\"';\n    let list_out = \"[\";\n\n    let current = list;\n    while (current instanceof NonEmpty) {\n      let element = current.head;\n      current = current.tail;\n\n      if (list_out !== \"[\") {\n        list_out += \", \";\n      }\n      list_out += this.inspect(element);\n\n      if (char_out) {\n        if (Number.isInteger(element) && element >= 32 && element <= 126) {\n          char_out += String.fromCharCode(element);\n        } else {\n          char_out = null;\n        }\n      }\n    }\n\n    if (char_out) {\n      return char_out + '\")';\n    } else {\n      return list_out + \"]\";\n    }\n  }\n\n  #string(str) {\n    let new_str = '\"';\n    for (let i = 0; i < str.length; i++) {\n      const char = str[i];\n      switch (char) {\n        case \"\\n\":\n          new_str += \"\\\\n\";\n          break;\n        case \"\\r\":\n          new_str += \"\\\\r\";\n          break;\n        case \"\\t\":\n          new_str += \"\\\\t\";\n          break;\n        case \"\\f\":\n          new_str += \"\\\\f\";\n          break;\n        case \"\\\\\":\n          new_str += \"\\\\\\\\\";\n          break;\n        case '\"':\n          new_str += '\\\\\"';\n          break;\n        default:\n          if (char < \" \" || (char > \"~\" && char < \"\\u{00A0}\")) {\n            new_str +=\n              \"\\\\u{\" +\n              char.charCodeAt(0).toString(16).toUpperCase().padStart(4, \"0\") +\n              \"}\";\n          } else {\n            new_str += char;\n          }\n      }\n    }\n    new_str += '\"';\n    return new_str;\n  }\n\n  #utfCodepoint(codepoint) {\n    return `//utfcodepoint(${String.fromCodePoint(codepoint.value)})`;\n  }\n\n  #bit_array(bits) {\n    if (bits.bitSize === 0) {\n      return \"<<>>\";\n    }\n\n    let acc = \"<<\";\n\n    for (let i = 0; i < bits.byteSize - 1; i++) {\n      acc += bits.byteAt(i).toString();\n      acc += \", \";\n    }\n\n    if (bits.byteSize * 8 === bits.bitSize) {\n      acc += bits.byteAt(bits.byteSize - 1).toString();\n    } else {\n      const trailingBitsCount = bits.bitSize % 8;\n      acc += bits.byteAt(bits.byteSize - 1) >> (8 - trailingBitsCount);\n      acc += `:size(${trailingBitsCount})`;\n    }\n\n    acc += \">>\";\n    return acc;\n  }\n}\n\nexport function base16_encode(bit_array) {\n  const trailingBitsCount = bit_array.bitSize % 8;\n\n  let result = \"\";\n\n  for (let i = 0; i < bit_array.byteSize; i++) {\n    let byte = bit_array.byteAt(i);\n\n    if (i === bit_array.byteSize - 1 && trailingBitsCount !== 0) {\n      const unusedBitsCount = 8 - trailingBitsCount;\n      byte = (byte >> unusedBitsCount) << unusedBitsCount;\n    }\n\n    result += byte.toString(16).padStart(2, \"0\").toUpperCase();\n  }\n\n  return result;\n}\n\nexport function base16_decode(string) {\n  const bytes = new Uint8Array(string.length / 2);\n  for (let i = 0; i < string.length; i += 2) {\n    const a = parseInt(string[i], 16);\n    const b = parseInt(string[i + 1], 16);\n    if (isNaN(a) || isNaN(b)) return new Error(Nil);\n    bytes[i / 2] = a * 16 + b;\n  }\n  return new Ok(new BitArray(bytes));\n}\n\nexport function bit_array_to_int_and_size(bits) {\n  const trailingBitsCount = bits.bitSize % 8;\n  const unusedBitsCount = trailingBitsCount === 0 ? 0 : 8 - trailingBitsCount;\n\n  return [bits.byteAt(0) >> unusedBitsCount, bits.bitSize];\n}\n\nexport function bit_array_starts_with(bits, prefix) {\n  if (prefix.bitSize > bits.bitSize) {\n    return false;\n  }\n\n  // Check any whole bytes\n  const byteCount = Math.trunc(prefix.bitSize / 8);\n  for (let i = 0; i < byteCount; i++) {\n    if (bits.byteAt(i) !== prefix.byteAt(i)) {\n      return false;\n    }\n  }\n\n  // Check any trailing bits at the end of the prefix\n  if (prefix.bitSize % 8 !== 0) {\n    const unusedBitsCount = 8 - (prefix.bitSize % 8);\n    if (\n      bits.byteAt(byteCount) >> unusedBitsCount !==\n      prefix.byteAt(byteCount) >> unusedBitsCount\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function log(x) {\n  // It is checked in Gleam that:\n  // - The input is strictly positive (x > 0)\n  // - This ensures that Math.log will never return NaN or -Infinity\n  // The function can thus safely pass the input to Math.log\n  // and a valid finite float will always be produced.\n  return Math.log(x);\n}\n\nexport function exp(x) {\n  return Math.exp(x);\n}\n\nexport function list_to_array(list) {\n  let current = list;\n  let array = [];\n  while (current instanceof NonEmpty) {\n    array.push(current.head);\n    current = current.tail;\n  }\n  return array;\n}\n\nexport function index(data, key) {\n  // Dictionaries and dictionary-like objects can be indexed\n  if (data instanceof Dict || data instanceof WeakMap || data instanceof Map) {\n    const token = {};\n    const entry = data.get(key, token);\n    if (entry === token) return new Ok(new None());\n    return new Ok(new Some(entry));\n  }\n\n  const key_is_int = Number.isInteger(key);\n\n  // Only elements 0-7 of lists can be indexed, negative indices are not allowed\n  if (key_is_int && key >= 0 && key < 8 && data instanceof List) {\n    let i = 0;\n    for (const value of data) {\n      if (i === key) return new Ok(new Some(value));\n      i++;\n    }\n    return new Error(\"Indexable\");\n  }\n\n  // Arrays and objects can be indexed\n  if (\n    (key_is_int && Array.isArray(data)) ||\n    (data && typeof data === \"object\") ||\n    (data && Object.getPrototypeOf(data) === Object.prototype)\n  ) {\n    if (key in data) return new Ok(new Some(data[key]));\n    return new Ok(new None());\n  }\n\n  return new Error(key_is_int ? \"Indexable\" : \"Dict\");\n}\n\nexport function list(data, decode, pushPath, index, emptyList) {\n  if (!(data instanceof List || Array.isArray(data))) {\n    const error = new DecodeError(\"List\", classify(data), emptyList);\n    return [emptyList, List.fromArray([error])];\n  }\n\n  const decoded = [];\n\n  for (const element of data) {\n    const layer = decode(element);\n    const [out, errors] = layer;\n\n    if (errors instanceof NonEmpty) {\n      const [_, errors] = pushPath(layer, index.toString());\n      return [emptyList, errors];\n    }\n    decoded.push(out);\n    index++;\n  }\n\n  return [List.fromArray(decoded), emptyList];\n}\n\nexport function dict(data) {\n  if (data instanceof Dict) {\n    return new Ok(data);\n  }\n  if (data instanceof Map || data instanceof WeakMap) {\n    return new Ok(Dict.fromMap(data));\n  }\n  if (data == null) {\n    return new Error(\"Dict\");\n  }\n  if (typeof data !== \"object\") {\n    return new Error(\"Dict\");\n  }\n  const proto = Object.getPrototypeOf(data);\n  if (proto === Object.prototype || proto === null) {\n    return new Ok(Dict.fromObject(data));\n  }\n  return new Error(\"Dict\");\n}\n\nexport function bit_array(data) {\n  if (data instanceof BitArray) return new Ok(data);\n  if (data instanceof Uint8Array) return new Ok(new BitArray(data));\n  return new Error(new BitArray(new Uint8Array()));\n}\n\nexport function float(data) {\n  if (typeof data === \"number\") return new Ok(data);\n  return new Error(0.0);\n}\n\nexport function int(data) {\n  if (Number.isInteger(data)) return new Ok(data);\n  return new Error(0);\n}\n\nexport function string(data) {\n  if (typeof data === \"string\") return new Ok(data);\n  return new Error(\"\");\n}\n\nexport function is_null(data) {\n  return data === null || data === undefined;\n}\n","//# sourceMappingURL=float.mjs.map\nimport { Ok, Error, Empty as $Empty, divideFloat } from \"../gleam.mjs\";\nimport * as $order from \"../gleam/order.mjs\";\nimport {\n  parse_float as parse,\n  float_to_string as to_string,\n  ceiling,\n  floor,\n  round as js_round,\n  truncate,\n  identity as do_to_float,\n  power as do_power,\n  random_uniform as random,\n  log as do_log,\n  exp as exponential,\n} from \"../gleam_stdlib.mjs\";\n\nexport { ceiling, exponential, floor, parse, random, to_string, truncate };\n\n/**\n * Compares two `Float`s, returning an `Order`:\n * `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n *\n * ## Examples\n *\n * ```gleam\n * compare(2.0, 2.3)\n * // -> Lt\n * ```\n *\n * To handle\n * [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems)\n * you may use [`loosely_compare`](#loosely_compare) instead.\n */\nexport function compare(a, b) {\n  let $ = a === b;\n  if ($) {\n    return new $order.Eq();\n  } else {\n    let $1 = a < b;\n    if ($1) {\n      return new $order.Lt();\n    } else {\n      return new $order.Gt();\n    }\n  }\n}\n\n/**\n * Compares two `Float`s, returning the smaller of the two.\n *\n * ## Examples\n *\n * ```gleam\n * min(2.0, 2.3)\n * // -> 2.0\n * ```\n */\nexport function min(a, b) {\n  let $ = a < b;\n  if ($) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n/**\n * Compares two `Float`s, returning the larger of the two.\n *\n * ## Examples\n *\n * ```gleam\n * max(2.0, 2.3)\n * // -> 2.3\n * ```\n */\nexport function max(a, b) {\n  let $ = a > b;\n  if ($) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n/**\n * Restricts a `Float` between two bounds.\n *\n * ## Examples\n *\n * ```gleam\n * clamp(1.2, min: 1.4, max: 1.6)\n * // -> 1.4\n * ```\n *\n * ```gleam\n * clamp(1.2, min: 1.4, max: 0.6)\n * // -> 1.2\n * ```\n */\nexport function clamp(x, min_bound, max_bound) {\n  let $ = min_bound >= max_bound;\n  if ($) {\n    let _pipe = x;\n    let _pipe$1 = min(_pipe, min_bound);\n    return max(_pipe$1, max_bound);\n  } else {\n    let _pipe = x;\n    let _pipe$1 = min(_pipe, max_bound);\n    return max(_pipe$1, min_bound);\n  }\n}\n\n/**\n * Returns the absolute value of the input as a `Float`.\n *\n * ## Examples\n *\n * ```gleam\n * absolute_value(-12.5)\n * // -> 12.5\n * ```\n *\n * ```gleam\n * absolute_value(10.2)\n * // -> 10.2\n * ```\n */\nexport function absolute_value(x) {\n  let $ = x >= 0.0;\n  if ($) {\n    return x;\n  } else {\n    return 0.0 - x;\n  }\n}\n\n/**\n * Compares two `Float`s within a tolerance, returning an `Order`:\n * `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n *\n * This function allows Float comparison while handling\n * [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n *\n * Notice: For `Float`s the tolerance won't be exact:\n * `5.3 - 5.0` is not exactly `0.3`.\n *\n * ## Examples\n *\n * ```gleam\n * loosely_compare(5.0, with: 5.3, tolerating: 0.5)\n * // -> Eq\n * ```\n *\n * If you want to check only for equality you may use\n * [`loosely_equals`](#loosely_equals) instead.\n */\nexport function loosely_compare(a, b, tolerance) {\n  let difference = absolute_value(a - b);\n  let $ = difference <= tolerance;\n  if ($) {\n    return new $order.Eq();\n  } else {\n    return compare(a, b);\n  }\n}\n\n/**\n * Checks for equality of two `Float`s within a tolerance,\n * returning an `Bool`.\n *\n * This function allows Float comparison while handling\n * [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n *\n * Notice: For `Float`s the tolerance won't be exact:\n * `5.3 - 5.0` is not exactly `0.3`.\n *\n * ## Examples\n *\n * ```gleam\n * loosely_equals(5.0, with: 5.3, tolerating: 0.5)\n * // -> True\n * ```\n *\n * ```gleam\n * loosely_equals(5.0, with: 5.1, tolerating: 0.1)\n * // -> False\n * ```\n */\nexport function loosely_equals(a, b, tolerance) {\n  let difference = absolute_value(a - b);\n  return difference <= tolerance;\n}\n\n/**\n * Returns the results of the base being raised to the power of the\n * exponent, as a `Float`.\n *\n * ## Examples\n *\n * ```gleam\n * power(2.0, -1.0)\n * // -> Ok(0.5)\n * ```\n *\n * ```gleam\n * power(2.0, 2.0)\n * // -> Ok(4.0)\n * ```\n *\n * ```gleam\n * power(8.0, 1.5)\n * // -> Ok(22.627416997969522)\n * ```\n *\n * ```gleam\n * 4.0 |> power(of: 2.0)\n * // -> Ok(16.0)\n * ```\n *\n * ```gleam\n * power(-1.0, 0.5)\n * // -> Error(Nil)\n * ```\n */\nexport function power(base, exponent) {\n  let fractional = (ceiling(exponent) - exponent) > 0.0;\n  let $ = ((base < 0.0) && fractional) || ((base === 0.0) && (exponent < 0.0));\n  if ($) {\n    return new Error(undefined);\n  } else {\n    return new Ok(do_power(base, exponent));\n  }\n}\n\n/**\n * Returns the square root of the input as a `Float`.\n *\n * ## Examples\n *\n * ```gleam\n * square_root(4.0)\n * // -> Ok(2.0)\n * ```\n *\n * ```gleam\n * square_root(-16.0)\n * // -> Error(Nil)\n * ```\n */\nexport function square_root(x) {\n  return power(x, 0.5);\n}\n\n/**\n * Returns the negative of the value provided.\n *\n * ## Examples\n *\n * ```gleam\n * negate(1.0)\n * // -> -1.0\n * ```\n */\nexport function negate(x) {\n  return -1.0 * x;\n}\n\n/**\n * Rounds the value to the nearest whole number as an `Int`.\n *\n * ## Examples\n *\n * ```gleam\n * round(2.3)\n * // -> 2\n * ```\n *\n * ```gleam\n * round(2.5)\n * // -> 3\n * ```\n */\nexport function round(x) {\n  let $ = x >= 0.0;\n  if ($) {\n    return js_round(x);\n  } else {\n    return 0 - js_round(negate(x));\n  }\n}\n\n/**\n * Converts the value to a given precision as a `Float`.\n * The precision is the number of allowed decimal places.\n * Negative precisions are allowed and force rounding\n * to the nearest tenth, hundredth, thousandth etc.\n *\n * ## Examples\n *\n * ```gleam\n * to_precision(2.43434348473, precision: 2)\n * // -> 2.43\n * ```\n *\n * ```gleam\n * to_precision(547890.453444, precision: -3)\n * // -> 548000.0\n * ```\n */\nexport function to_precision(x, precision) {\n  let $ = precision <= 0;\n  if ($) {\n    let factor = do_power(10.0, do_to_float(- precision));\n    return do_to_float(round(divideFloat(x, factor))) * factor;\n  } else {\n    let factor = do_power(10.0, do_to_float(precision));\n    return divideFloat(do_to_float(round(x * factor)), factor);\n  }\n}\n\nfunction sum_loop(loop$numbers, loop$initial) {\n  while (true) {\n    let numbers = loop$numbers;\n    let initial = loop$initial;\n    if (numbers instanceof $Empty) {\n      return initial;\n    } else {\n      let first = numbers.head;\n      let rest = numbers.tail;\n      loop$numbers = rest;\n      loop$initial = first + initial;\n    }\n  }\n}\n\n/**\n * Sums a list of `Float`s.\n *\n * ## Example\n *\n * ```gleam\n * sum([1.0, 2.2, 3.3])\n * // -> 6.5\n * ```\n */\nexport function sum(numbers) {\n  return sum_loop(numbers, 0.0);\n}\n\nfunction product_loop(loop$numbers, loop$initial) {\n  while (true) {\n    let numbers = loop$numbers;\n    let initial = loop$initial;\n    if (numbers instanceof $Empty) {\n      return initial;\n    } else {\n      let first = numbers.head;\n      let rest = numbers.tail;\n      loop$numbers = rest;\n      loop$initial = first * initial;\n    }\n  }\n}\n\n/**\n * Multiplies a list of `Float`s and returns the product.\n *\n * ## Example\n *\n * ```gleam\n * product([2.5, 3.2, 4.2])\n * // -> 33.6\n * ```\n */\nexport function product(numbers) {\n  return product_loop(numbers, 1.0);\n}\n\n/**\n * Computes the modulo of an float division of inputs as a `Result`.\n *\n * Returns division of the inputs as a `Result`: If the given divisor equals\n * `0`, this function returns an `Error`.\n *\n * The computed value will always have the same sign as the `divisor`.\n *\n * ## Examples\n *\n * ```gleam\n * modulo(13.3, by: 3.3)\n * // -> Ok(0.1)\n * ```\n *\n * ```gleam\n * modulo(-13.3, by: 3.3)\n * // -> Ok(3.2)\n * ```\n *\n * ```gleam\n * modulo(13.3, by: -3.3)\n * // -> Ok(-3.2)\n * ```\n *\n * ```gleam\n * modulo(-13.3, by: -3.3)\n * // -> Ok(-0.1)\n * ```\n */\nexport function modulo(dividend, divisor) {\n  if (divisor === 0.0) {\n    return new Error(undefined);\n  } else {\n    return new Ok(dividend - (floor(divideFloat(dividend, divisor)) * divisor));\n  }\n}\n\n/**\n * Returns division of the inputs as a `Result`.\n *\n * ## Examples\n *\n * ```gleam\n * divide(0.0, 1.0)\n * // -> Ok(0.0)\n * ```\n *\n * ```gleam\n * divide(1.0, 0.0)\n * // -> Error(Nil)\n * ```\n */\nexport function divide(a, b) {\n  if (b === 0.0) {\n    return new Error(undefined);\n  } else {\n    let b$1 = b;\n    return new Ok(divideFloat(a, b$1));\n  }\n}\n\n/**\n * Adds two floats together.\n *\n * It's the function equivalent of the `+.` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * add(1.0, 2.0)\n * // -> 3.0\n * ```\n *\n * ```gleam\n * import gleam/list\n *\n * list.fold([1.0, 2.0, 3.0], 0.0, add)\n * // -> 6.0\n * ```\n *\n * ```gleam\n * 3.0 |> add(2.0)\n * // -> 5.0\n * ```\n */\nexport function add(a, b) {\n  return a + b;\n}\n\n/**\n * Multiplies two floats together.\n *\n * It's the function equivalent of the `*.` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * multiply(2.0, 4.0)\n * // -> 8.0\n * ```\n *\n * ```gleam\n * import gleam/list\n *\n * list.fold([2.0, 3.0, 4.0], 1.0, multiply)\n * // -> 24.0\n * ```\n *\n * ```gleam\n * 3.0 |> multiply(2.0)\n * // -> 6.0\n * ```\n */\nexport function multiply(a, b) {\n  return a * b;\n}\n\n/**\n * Subtracts one float from another.\n *\n * It's the function equivalent of the `-.` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * subtract(3.0, 1.0)\n * // -> 2.0\n * ```\n *\n * ```gleam\n * import gleam/list\n *\n * list.fold([1.0, 2.0, 3.0], 10.0, subtract)\n * // -> 4.0\n * ```\n *\n * ```gleam\n * 3.0 |> subtract(_, 2.0)\n * // -> 1.0\n * ```\n *\n * ```gleam\n * 3.0 |> subtract(2.0, _)\n * // -> -1.0\n * ```\n */\nexport function subtract(a, b) {\n  return a - b;\n}\n\n/**\n * Returns the natural logarithm (base e) of the given as a `Result`. If the\n * input is less than or equal to 0, returns `Error(Nil)`.\n *\n * ## Examples\n *\n * ```gleam\n * logarithm(1.0)\n * // -> Ok(0.0)\n * ```\n *\n * ```gleam\n * logarithm(2.718281828459045)  // e\n * // -> Ok(1.0)\n * ```\n *\n * ```gleam\n * logarithm(0.0)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * logarithm(-1.0)\n * // -> Error(Nil)\n * ```\n */\nexport function logarithm(x) {\n  let $ = x <= 0.0;\n  if ($) {\n    return new Error(undefined);\n  } else {\n    return new Ok(do_log(x));\n  }\n}\n","//# sourceMappingURL=int.mjs.map\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  remainderInt,\n  divideInt,\n} from \"../gleam.mjs\";\nimport * as $float from \"../gleam/float.mjs\";\nimport * as $order from \"../gleam/order.mjs\";\nimport {\n  parse_int as parse,\n  int_from_base_string as do_base_parse,\n  to_string,\n  int_to_base_string as do_to_base_string,\n  identity as to_float,\n  bitwise_and,\n  bitwise_not,\n  bitwise_or,\n  bitwise_exclusive_or,\n  bitwise_shift_left,\n  bitwise_shift_right,\n} from \"../gleam_stdlib.mjs\";\n\nexport {\n  bitwise_and,\n  bitwise_exclusive_or,\n  bitwise_not,\n  bitwise_or,\n  bitwise_shift_left,\n  bitwise_shift_right,\n  parse,\n  to_float,\n  to_string,\n};\n\n/**\n * Returns the absolute value of the input.\n *\n * ## Examples\n *\n * ```gleam\n * absolute_value(-12)\n * // -> 12\n * ```\n *\n * ```gleam\n * absolute_value(10)\n * // -> 10\n * ```\n */\nexport function absolute_value(x) {\n  let $ = x >= 0;\n  if ($) {\n    return x;\n  } else {\n    return x * -1;\n  }\n}\n\n/**\n * Parses a given string as an int in a given base if possible.\n * Supports only bases 2 to 36, for values outside of which this function returns an `Error(Nil)`.\n *\n * ## Examples\n *\n * ```gleam\n * base_parse(\"10\", 2)\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * base_parse(\"30\", 16)\n * // -> Ok(48)\n * ```\n *\n * ```gleam\n * base_parse(\"1C\", 36)\n * // -> Ok(48)\n * ```\n *\n * ```gleam\n * base_parse(\"48\", 1)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * base_parse(\"48\", 37)\n * // -> Error(Nil)\n * ```\n */\nexport function base_parse(string, base) {\n  let $ = (base >= 2) && (base <= 36);\n  if ($) {\n    return do_base_parse(string, base);\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * Prints a given int to a string using the base number provided.\n * Supports only bases 2 to 36, for values outside of which this function returns an `Error(Nil)`.\n * For common bases (2, 8, 16, 36), use the `to_baseN` functions.\n *\n * ## Examples\n *\n * ```gleam\n * to_base_string(2, 2)\n * // -> Ok(\"10\")\n * ```\n *\n * ```gleam\n * to_base_string(48, 16)\n * // -> Ok(\"30\")\n * ```\n *\n * ```gleam\n * to_base_string(48, 36)\n * // -> Ok(\"1C\")\n * ```\n *\n * ```gleam\n * to_base_string(48, 1)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * to_base_string(48, 37)\n * // -> Error(Nil)\n * ```\n */\nexport function to_base_string(x, base) {\n  let $ = (base >= 2) && (base <= 36);\n  if ($) {\n    return new Ok(do_to_base_string(x, base));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * Prints a given int to a string using base-2.\n *\n * ## Examples\n *\n * ```gleam\n * to_base2(2)\n * // -> \"10\"\n * ```\n */\nexport function to_base2(x) {\n  return do_to_base_string(x, 2);\n}\n\n/**\n * Prints a given int to a string using base-8.\n *\n * ## Examples\n *\n * ```gleam\n * to_base8(15)\n * // -> \"17\"\n * ```\n */\nexport function to_base8(x) {\n  return do_to_base_string(x, 8);\n}\n\n/**\n * Prints a given int to a string using base-16.\n *\n * ## Examples\n *\n * ```gleam\n * to_base16(48)\n * // -> \"30\"\n * ```\n */\nexport function to_base16(x) {\n  return do_to_base_string(x, 16);\n}\n\n/**\n * Prints a given int to a string using base-36.\n *\n * ## Examples\n *\n * ```gleam\n * to_base36(48)\n * // -> \"1C\"\n * ```\n */\nexport function to_base36(x) {\n  return do_to_base_string(x, 36);\n}\n\n/**\n * Returns the results of the base being raised to the power of the\n * exponent, as a `Float`.\n *\n * ## Examples\n *\n * ```gleam\n * power(2, -1.0)\n * // -> Ok(0.5)\n * ```\n *\n * ```gleam\n * power(2, 2.0)\n * // -> Ok(4.0)\n * ```\n *\n * ```gleam\n * power(8, 1.5)\n * // -> Ok(22.627416997969522)\n * ```\n *\n * ```gleam\n * 4 |> power(of: 2.0)\n * // -> Ok(16.0)\n * ```\n *\n * ```gleam\n * power(-1, 0.5)\n * // -> Error(Nil)\n * ```\n */\nexport function power(base, exponent) {\n  let _pipe = base;\n  let _pipe$1 = to_float(_pipe);\n  return $float.power(_pipe$1, exponent);\n}\n\n/**\n * Returns the square root of the input as a `Float`.\n *\n * ## Examples\n *\n * ```gleam\n * square_root(4)\n * // -> Ok(2.0)\n * ```\n *\n * ```gleam\n * square_root(-16)\n * // -> Error(Nil)\n * ```\n */\nexport function square_root(x) {\n  let _pipe = x;\n  let _pipe$1 = to_float(_pipe);\n  return $float.square_root(_pipe$1);\n}\n\n/**\n * Compares two ints, returning an order.\n *\n * ## Examples\n *\n * ```gleam\n * compare(2, 3)\n * // -> Lt\n * ```\n *\n * ```gleam\n * compare(4, 3)\n * // -> Gt\n * ```\n *\n * ```gleam\n * compare(3, 3)\n * // -> Eq\n * ```\n */\nexport function compare(a, b) {\n  let $ = a === b;\n  if ($) {\n    return new $order.Eq();\n  } else {\n    let $1 = a < b;\n    if ($1) {\n      return new $order.Lt();\n    } else {\n      return new $order.Gt();\n    }\n  }\n}\n\n/**\n * Compares two ints, returning the smaller of the two.\n *\n * ## Examples\n *\n * ```gleam\n * min(2, 3)\n * // -> 2\n * ```\n */\nexport function min(a, b) {\n  let $ = a < b;\n  if ($) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n/**\n * Compares two ints, returning the larger of the two.\n *\n * ## Examples\n *\n * ```gleam\n * max(2, 3)\n * // -> 3\n * ```\n */\nexport function max(a, b) {\n  let $ = a > b;\n  if ($) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n/**\n * Restricts an int between two bounds.\n *\n * ## Examples\n *\n * ```gleam\n * clamp(40, min: 50, max: 60)\n * // -> 50\n * ```\n *\n * ```gleam\n * clamp(40, min: 50, max: 30)\n * // -> 40\n * ```\n */\nexport function clamp(x, min_bound, max_bound) {\n  let $ = min_bound >= max_bound;\n  if ($) {\n    let _pipe = x;\n    let _pipe$1 = min(_pipe, min_bound);\n    return max(_pipe$1, max_bound);\n  } else {\n    let _pipe = x;\n    let _pipe$1 = min(_pipe, max_bound);\n    return max(_pipe$1, min_bound);\n  }\n}\n\n/**\n * Returns whether the value provided is even.\n *\n * ## Examples\n *\n * ```gleam\n * is_even(2)\n * // -> True\n * ```\n *\n * ```gleam\n * is_even(3)\n * // -> False\n * ```\n */\nexport function is_even(x) {\n  return (x % 2) === 0;\n}\n\n/**\n * Returns whether the value provided is odd.\n *\n * ## Examples\n *\n * ```gleam\n * is_odd(3)\n * // -> True\n * ```\n *\n * ```gleam\n * is_odd(2)\n * // -> False\n * ```\n */\nexport function is_odd(x) {\n  return (x % 2) !== 0;\n}\n\n/**\n * Returns the negative of the value provided.\n *\n * ## Examples\n *\n * ```gleam\n * negate(1)\n * // -> -1\n * ```\n */\nexport function negate(x) {\n  return -1 * x;\n}\n\nfunction sum_loop(loop$numbers, loop$initial) {\n  while (true) {\n    let numbers = loop$numbers;\n    let initial = loop$initial;\n    if (numbers instanceof $Empty) {\n      return initial;\n    } else {\n      let first = numbers.head;\n      let rest = numbers.tail;\n      loop$numbers = rest;\n      loop$initial = first + initial;\n    }\n  }\n}\n\n/**\n * Sums a list of ints.\n *\n * ## Example\n *\n * ```gleam\n * sum([1, 2, 3])\n * // -> 6\n * ```\n */\nexport function sum(numbers) {\n  return sum_loop(numbers, 0);\n}\n\nfunction product_loop(loop$numbers, loop$initial) {\n  while (true) {\n    let numbers = loop$numbers;\n    let initial = loop$initial;\n    if (numbers instanceof $Empty) {\n      return initial;\n    } else {\n      let first = numbers.head;\n      let rest = numbers.tail;\n      loop$numbers = rest;\n      loop$initial = first * initial;\n    }\n  }\n}\n\n/**\n * Multiplies a list of ints and returns the product.\n *\n * ## Example\n *\n * ```gleam\n * product([2, 3, 4])\n * // -> 24\n * ```\n */\nexport function product(numbers) {\n  return product_loop(numbers, 1);\n}\n\nfunction digits_loop(loop$x, loop$base, loop$acc) {\n  while (true) {\n    let x = loop$x;\n    let base = loop$base;\n    let acc = loop$acc;\n    let $ = absolute_value(x) < base;\n    if ($) {\n      return listPrepend(x, acc);\n    } else {\n      loop$x = divideInt(x, base);\n      loop$base = base;\n      loop$acc = listPrepend(remainderInt(x, base), acc);\n    }\n  }\n}\n\nexport function digits(x, base) {\n  let $ = base < 2;\n  if ($) {\n    return new Error(undefined);\n  } else {\n    return new Ok(digits_loop(x, base, toList([])));\n  }\n}\n\nfunction undigits_loop(loop$numbers, loop$base, loop$acc) {\n  while (true) {\n    let numbers = loop$numbers;\n    let base = loop$base;\n    let acc = loop$acc;\n    if (numbers instanceof $Empty) {\n      return new Ok(acc);\n    } else {\n      let digit = numbers.head;\n      if (digit >= base) {\n        return new Error(undefined);\n      } else {\n        let digit = numbers.head;\n        let rest = numbers.tail;\n        loop$numbers = rest;\n        loop$base = base;\n        loop$acc = acc * base + digit;\n      }\n    }\n  }\n}\n\nexport function undigits(numbers, base) {\n  let $ = base < 2;\n  if ($) {\n    return new Error(undefined);\n  } else {\n    return undigits_loop(numbers, base, 0);\n  }\n}\n\n/**\n * Generates a random int between zero and the given maximum.\n *\n * The lower number is inclusive, the upper number is exclusive.\n *\n * ## Examples\n *\n * ```gleam\n * random(10)\n * // -> 4\n * ```\n *\n * ```gleam\n * random(1)\n * // -> 0\n * ```\n *\n * ```gleam\n * random(-1)\n * // -> -1\n * ```\n */\nexport function random(max) {\n  let _pipe = ($float.random() * to_float(max));\n  let _pipe$1 = $float.floor(_pipe);\n  return $float.round(_pipe$1);\n}\n\n/**\n * Performs a truncated integer division.\n *\n * Returns division of the inputs as a `Result`: If the given divisor equals\n * `0`, this function returns an `Error`.\n *\n * ## Examples\n *\n * ```gleam\n * divide(0, 1)\n * // -> Ok(0)\n * ```\n *\n * ```gleam\n * divide(1, 0)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * divide(5, 2)\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * divide(-99, 2)\n * // -> Ok(-49)\n * ```\n */\nexport function divide(dividend, divisor) {\n  if (divisor === 0) {\n    return new Error(undefined);\n  } else {\n    let divisor$1 = divisor;\n    return new Ok(divideInt(dividend, divisor$1));\n  }\n}\n\n/**\n * Computes the remainder of an integer division of inputs as a `Result`.\n *\n * Returns division of the inputs as a `Result`: If the given divisor equals\n * `0`, this function returns an `Error`.\n *\n * Most the time you will want to use the `%` operator instead of this\n * function.\n *\n * ## Examples\n *\n * ```gleam\n * remainder(3, 2)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * remainder(1, 0)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * remainder(10, -1)\n * // -> Ok(0)\n * ```\n *\n * ```gleam\n * remainder(13, by: 3)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * remainder(-13, by: 3)\n * // -> Ok(-1)\n * ```\n *\n * ```gleam\n * remainder(13, by: -3)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * remainder(-13, by: -3)\n * // -> Ok(-1)\n * ```\n */\nexport function remainder(dividend, divisor) {\n  if (divisor === 0) {\n    return new Error(undefined);\n  } else {\n    let divisor$1 = divisor;\n    return new Ok(remainderInt(dividend, divisor$1));\n  }\n}\n\n/**\n * Computes the modulo of an integer division of inputs as a `Result`.\n *\n * Returns division of the inputs as a `Result`: If the given divisor equals\n * `0`, this function returns an `Error`.\n *\n * Note that this is different from `int.remainder` and `%` in that the\n * computed value will always have the same sign as the `divisor`.\n *\n * ## Examples\n *\n * ```gleam\n * modulo(3, 2)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * modulo(1, 0)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * modulo(10, -1)\n * // -> Ok(0)\n * ```\n *\n * ```gleam\n * modulo(13, by: 3)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * modulo(-13, by: 3)\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * modulo(13, by: -3)\n * // -> Ok(-2)\n * ```\n */\nexport function modulo(dividend, divisor) {\n  if (divisor === 0) {\n    return new Error(undefined);\n  } else {\n    let remainder$1 = remainderInt(dividend, divisor);\n    let $ = remainder$1 * divisor < 0;\n    if ($) {\n      return new Ok(remainder$1 + divisor);\n    } else {\n      return new Ok(remainder$1);\n    }\n  }\n}\n\n/**\n * Performs a *floored* integer division, which means that the result will\n * always be rounded towards negative infinity.\n *\n * If you want to perform truncated integer division (rounding towards zero),\n * use `int.divide()` or the `/` operator instead.\n *\n * Returns division of the inputs as a `Result`: If the given divisor equals\n * `0`, this function returns an `Error`.\n *\n * ## Examples\n *\n * ```gleam\n * floor_divide(1, 0)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * floor_divide(5, 2)\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * floor_divide(6, -4)\n * // -> Ok(-2)\n * ```\n *\n * ```gleam\n * floor_divide(-99, 2)\n * // -> Ok(-50)\n * ```\n */\nexport function floor_divide(dividend, divisor) {\n  if (divisor === 0) {\n    return new Error(undefined);\n  } else {\n    let divisor$1 = divisor;\n    let $ = (dividend * divisor$1 < 0) && ((remainderInt(dividend, divisor$1)) !== 0);\n    if ($) {\n      return new Ok((divideInt(dividend, divisor$1)) - 1);\n    } else {\n      return new Ok(divideInt(dividend, divisor$1));\n    }\n  }\n}\n\n/**\n * Adds two integers together.\n *\n * It's the function equivalent of the `+` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * add(1, 2)\n * // -> 3\n * ```\n *\n * ```gleam\n * import gleam/list\n * list.fold([1, 2, 3], 0, add)\n * // -> 6\n * ```\n *\n * ```gleam\n * 3 |> add(2)\n * // -> 5\n * ```\n */\nexport function add(a, b) {\n  return a + b;\n}\n\n/**\n * Multiplies two integers together.\n *\n * It's the function equivalent of the `*` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * multiply(2, 4)\n * // -> 8\n * ```\n *\n * ```gleam\n * import gleam/list\n *\n * list.fold([2, 3, 4], 1, multiply)\n * // -> 24\n * ```\n *\n * ```gleam\n * 3 |> multiply(2)\n * // -> 6\n * ```\n */\nexport function multiply(a, b) {\n  return a * b;\n}\n\n/**\n * Subtracts one int from another.\n *\n * It's the function equivalent of the `-` operator.\n * This function is useful in higher order functions or pipes.\n *\n * ## Examples\n *\n * ```gleam\n * subtract(3, 1)\n * // -> 2\n * ```\n *\n * ```gleam\n * import gleam/list\n *\n * list.fold([1, 2, 3], 10, subtract)\n * // -> 4\n * ```\n *\n * ```gleam\n * 3 |> subtract(2)\n * // -> 1\n * ```\n *\n * ```gleam\n * 3 |> subtract(2, _)\n * // -> -1\n * ```\n */\nexport function subtract(a, b) {\n  return a - b;\n}\n","//# sourceMappingURL=p5js_gleam.mjs.map\nimport * as $dict from \"../gleam_stdlib/gleam/dict.mjs\";\nimport * as $option from \"../gleam_stdlib/gleam/option.mjs\";\nimport { CustomType as $CustomType } from \"./gleam.mjs\";\n\n/**\n * Assets that are loaded in `preload`.\n * \n * @ignore\n */\nclass Assets extends $CustomType {\n  constructor(fonts, images) {\n    super();\n    this.fonts = fonts;\n    this.images = images;\n  }\n}\n\nclass BaseConfig extends $CustomType {\n  constructor(init, draw, on_tick, on_key_pressed, on_key_released, on_mouse_moved, on_mouse_clicked) {\n    super();\n    this.init = init;\n    this.draw = draw;\n    this.on_tick = on_tick;\n    this.on_key_pressed = on_key_pressed;\n    this.on_key_released = on_key_released;\n    this.on_mouse_moved = on_mouse_moved;\n    this.on_mouse_clicked = on_mouse_clicked;\n  }\n}\n\nclass ConfigWithLoadingAssets extends $CustomType {\n  constructor(preload, init, draw, on_tick, on_key_pressed, on_key_released, on_mouse_moved, on_mouse_clicked) {\n    super();\n    this.preload = preload;\n    this.init = init;\n    this.draw = draw;\n    this.on_tick = on_tick;\n    this.on_key_pressed = on_key_pressed;\n    this.on_key_released = on_key_released;\n    this.on_mouse_moved = on_mouse_moved;\n    this.on_mouse_clicked = on_mouse_clicked;\n  }\n}\n\n/**\n * Creates an initial empty asset set.\n */\nexport function initialize_assets() {\n  return new Assets($dict.new$(), $dict.new$());\n}\n\n/**\n * Adds a font to the asset set.\n */\nexport function insert_font(assets, font_key, font) {\n  return new Assets($dict.insert(assets.fonts, font_key, font), assets.images);\n}\n\n/**\n * Adds an image to the asset set.\n */\nexport function insert_image(assets, image_key, image) {\n  return new Assets(assets.fonts, $dict.insert(assets.images, image_key, image));\n}\n\n/**\n * Get a font from the asset set.\n */\nexport function get_font(assets, font_key) {\n  return $dict.get(assets.fonts, font_key);\n}\n\n/**\n * Get an image from the asset set.\n */\nexport function get_image(assets, image_key) {\n  return $dict.get(assets.images, image_key);\n}\n\n/**\n * Creates a minimal sketch configuration.\n */\nexport function create_sketch(init, draw) {\n  return new BaseConfig(\n    init,\n    draw,\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n  );\n}\n\n/**\n * Creates a sketch configuration that supports preloading assets.\n */\nexport function create_sketch_with_preloading(preload, init, draw) {\n  return new ConfigWithLoadingAssets(\n    preload,\n    init,\n    draw,\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n    new $option.None(),\n  );\n}\n\n/**\n * Sets the `on_tick` function to be called.\n */\nexport function set_on_tick(s, on_tick) {\n  if (s instanceof BaseConfig) {\n    let init = s.init;\n    let draw = s.draw;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new BaseConfig(\n      init,\n      draw,\n      new $option.Some(on_tick),\n      on_key_pressed,\n      on_key_released,\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  } else {\n    let preload = s.preload;\n    let init = s.init;\n    let draw = s.draw;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new ConfigWithLoadingAssets(\n      preload,\n      init,\n      draw,\n      new $option.Some(on_tick),\n      on_key_pressed,\n      on_key_released,\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  }\n}\n\n/**\n * Sets the `on_key_pressed` function to be called.\n */\nexport function set_on_key_pressed(s, on_key_pressed) {\n  if (s instanceof BaseConfig) {\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new BaseConfig(\n      init,\n      draw,\n      on_tick,\n      new $option.Some(on_key_pressed),\n      on_key_released,\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  } else {\n    let preload = s.preload;\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new ConfigWithLoadingAssets(\n      preload,\n      init,\n      draw,\n      on_tick,\n      new $option.Some(on_key_pressed),\n      on_key_released,\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  }\n}\n\n/**\n * Sets the `on_key_released` function to be called.\n */\nexport function set_on_key_released(s, on_key_released) {\n  if (s instanceof BaseConfig) {\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new BaseConfig(\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      new $option.Some(on_key_released),\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  } else {\n    let preload = s.preload;\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_mouse_moved = s.on_mouse_moved;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new ConfigWithLoadingAssets(\n      preload,\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      new $option.Some(on_key_released),\n      on_mouse_moved,\n      on_mouse_clicked,\n    );\n  }\n}\n\n/**\n * Sets the `on_mouse_moved` function to be called.\n */\nexport function set_on_mouse_moved(s, on_mouse_moved) {\n  if (s instanceof BaseConfig) {\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new BaseConfig(\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      on_key_released,\n      new $option.Some(on_mouse_moved),\n      on_mouse_clicked,\n    );\n  } else {\n    let preload = s.preload;\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_clicked = s.on_mouse_clicked;\n    return new ConfigWithLoadingAssets(\n      preload,\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      on_key_released,\n      new $option.Some(on_mouse_moved),\n      on_mouse_clicked,\n    );\n  }\n}\n\n/**\n * Sets the `on_mouse_clicked` function to be called.\n */\nexport function set_on_mouse_clicked(s, on_mouse_clicked) {\n  if (s instanceof BaseConfig) {\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    return new BaseConfig(\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      on_key_released,\n      on_mouse_moved,\n      new $option.Some(on_mouse_clicked),\n    );\n  } else {\n    let preload = s.preload;\n    let init = s.init;\n    let draw = s.draw;\n    let on_tick = s.on_tick;\n    let on_key_pressed = s.on_key_pressed;\n    let on_key_released = s.on_key_released;\n    let on_mouse_moved = s.on_mouse_moved;\n    return new ConfigWithLoadingAssets(\n      preload,\n      init,\n      draw,\n      on_tick,\n      on_key_pressed,\n      on_key_released,\n      on_mouse_moved,\n      new $option.Some(on_mouse_clicked),\n    );\n  }\n}\n","import { is_some, unwrap } from \"../gleam_stdlib/gleam/option.mjs\";\n\nexport const startSketch = (config) => {\n  let model;\n  let assets;\n  new p5(function (p) {\n    if (config.preload) {\n      p.preload = function () {\n        assets = config.preload(p);\n      };\n    }\n\n    p.setup = function () {\n      model = config.init(p);\n    };\n\n    p.draw = function () {\n      config.draw(p, model, assets);\n      if (is_some(config.on_tick)) {\n        model = unwrap(config.on_tick)(model);\n      }\n    };\n\n    if (is_some(config.on_key_pressed)) {\n      p.keyPressed = function () {\n        model = unwrap(config.on_key_pressed)(p.key, p.keyCode, model);\n      };\n    }\n\n    if (is_some(config.on_key_released)) {\n      p.keyReleased = function () {\n        model = unwrap(config.on_key_released)(p.key, p.keyCode, model);\n      };\n    }\n\n    if (is_some(config.on_mouse_clicked)) {\n      p.mouseClicked = function () {\n        model = unwrap(config.on_mouse_clicked)(p.pmouseX, p.pmouseY, model);\n      };\n    }\n\n    if (is_some(config.on_mouse_moved)) {\n      p.mouseMoved = function () {\n        model = unwrap(config.on_mouse_moved)(p.pmouseX, p.pmouseY, model);\n      };\n    }\n  });\n};\n\nexport function createCanvas(p, ...args) {\n  p.createCanvas(...args);\n  return p;\n}\n\nexport function text(p, ...args) {\n  p.text(...args);\n  return p;\n}\n\nexport function textAlign(p, ...args) {\n  p.textAlign(...args);\n  return p;\n}\n\nexport function textFont(p, ...args) {\n  p.textFont(...args);\n  return p;\n}\n\nexport function textFontFromString(p, ...args) {\n  p.textFont(...args);\n  return p;\n}\n\nexport function textSize(p, ...args) {\n  p.textSize(...args);\n  return p;\n}\n\nexport function textWidth(p, ...args) {\n  return p.textWidth(...args);\n}\n\nexport function background(p, ...args) {\n  p.background(...args);\n  return p;\n}\n\nexport function ellipse(p, ...args) {\n  p.ellipse(...args);\n  return p;\n}\n\nexport function circle(p, ...args) {\n  p.circle(...args);\n  return p;\n}\n\nexport function rect(p, ...args) {\n  p.rect(...args);\n  return p;\n}\n\nexport function triangle(p, ...args) {\n  p.triangle(...args);\n  return p;\n}\n\nexport function square(p, ...args) {\n  p.square(...args);\n  return p;\n}\n\nexport function line(p, ...args) {\n  p.line(...args);\n  return p;\n}\n\nexport function quad(p, ...args) {\n  p.quad(...args);\n  return p;\n}\n\nexport function image(p, ...args) {\n  p.image(...args);\n  return p;\n}\n\nexport function fill(p, ...args) {\n  p.fill(...args);\n  return p;\n}\n\nexport function noFill(p, ...args) {\n  p.noFill(...args);\n  return p;\n}\n\nexport function stroke(p, ...args) {\n  p.stroke(...args);\n  return p;\n}\n\nexport function noStroke(p, ...args) {\n  p.noStroke(...args);\n  return p;\n}\n\nexport function strokeWeight(p, ...args) {\n  p.strokeWeight(...args);\n  return p;\n}\n\nexport function erase(p, ...args) {\n  p.erase(...args);\n  return p;\n}\n\nexport function noErase(p, ...args) {\n  p.noErase(...args);\n  return p;\n}\n\nexport function loadImage(p, ...args) {\n  return p.loadImage(...args);\n}\n\nexport function loadFont(p, ...args) {\n  return p.loadFont(...args);\n}\n\n","//# sourceMappingURL=behavior_tree.mjs.map\nimport { Empty as $Empty, CustomType as $CustomType } from \"../gleam.mjs\";\n\n/**\n * Represents the input data needed for an entity to update.\n */\nexport class BehaviorInput extends $CustomType {\n  constructor(entity, additional_inputs) {\n    super();\n    this.entity = entity;\n    this.additional_inputs = additional_inputs;\n  }\n}\nexport const BehaviorInput$BehaviorInput = (entity, additional_inputs) =>\n  new BehaviorInput(entity, additional_inputs);\nexport const BehaviorInput$isBehaviorInput = (value) =>\n  value instanceof BehaviorInput;\nexport const BehaviorInput$BehaviorInput$entity = (value) => value.entity;\nexport const BehaviorInput$BehaviorInput$0 = (value) => value.entity;\nexport const BehaviorInput$BehaviorInput$additional_inputs = (value) =>\n  value.additional_inputs;\nexport const BehaviorInput$BehaviorInput$1 = (value) => value.additional_inputs;\n\n/**\n * Represents the result of an entity update.\n */\nexport class BehaviorResult extends $CustomType {\n  constructor(success, entity, additional_outputs) {\n    super();\n    this.success = success;\n    this.entity = entity;\n    this.additional_outputs = additional_outputs;\n  }\n}\nexport const BehaviorResult$BehaviorResult = (success, entity, additional_outputs) =>\n  new BehaviorResult(success, entity, additional_outputs);\nexport const BehaviorResult$isBehaviorResult = (value) =>\n  value instanceof BehaviorResult;\nexport const BehaviorResult$BehaviorResult$success = (value) => value.success;\nexport const BehaviorResult$BehaviorResult$0 = (value) => value.success;\nexport const BehaviorResult$BehaviorResult$entity = (value) => value.entity;\nexport const BehaviorResult$BehaviorResult$1 = (value) => value.entity;\nexport const BehaviorResult$BehaviorResult$additional_outputs = (value) =>\n  value.additional_outputs;\nexport const BehaviorResult$BehaviorResult$2 = (value) =>\n  value.additional_outputs;\n\n/**\n * Creates a behavior tree that performs the given behavior tree but always succeeds.\n */\nexport function true$(bt) {\n  return (input) => {\n    let $ = bt(input);\n    let e;\n    let a;\n    e = $.entity;\n    a = $.additional_outputs;\n    return new BehaviorResult(true, e, a);\n  };\n}\n\n/**\n * Creates a behavior tree that performs the given behavior tree but returns the opposite for success.\n */\nexport function not(bt) {\n  return (input) => {\n    let $ = bt(input);\n    let s;\n    let e;\n    let a;\n    s = $.success;\n    e = $.entity;\n    a = $.additional_outputs;\n    return new BehaviorResult(!s, e, a);\n  };\n}\n\n/**\n * Creates a behavior tree that performs all the given behavior trees until one succeeds.\n * If none succeed, the last behavior tree's outputs are returned and the whole tree fails.\n */\nexport function selector(btrees, default_output, output_to_input, output_merge) {\n  if (btrees instanceof $Empty) {\n    return (input) => {\n      return new BehaviorResult(false, input.entity, default_output);\n    };\n  } else {\n    let bt = btrees.head;\n    let rest = btrees.tail;\n    return (input) => {\n      let $ = bt(input);\n      let success;\n      let e;\n      let first_behavior_outputs;\n      success = $.success;\n      e = $.entity;\n      first_behavior_outputs = $.additional_outputs;\n      if (success) {\n        return new BehaviorResult(true, e, first_behavior_outputs);\n      } else {\n        let next_input = new BehaviorInput(\n          e,\n          output_to_input(input.additional_inputs, first_behavior_outputs),\n        );\n        let $1 = selector(rest, default_output, output_to_input, output_merge)(\n          next_input,\n        );\n        let success$1;\n        let e$1;\n        let rest_outputs;\n        success$1 = $1.success;\n        e$1 = $1.entity;\n        rest_outputs = $1.additional_outputs;\n        let final_outputs = output_merge(first_behavior_outputs, rest_outputs);\n        return new BehaviorResult(success$1, e$1, final_outputs);\n      }\n    };\n  }\n}\n\n/**\n * Creates a behavior tree that performs all the given behavior trees until one fails.\n * If all succeed, the last behavior tree's outputs are returned and the whole tree succeeds.\n */\nexport function sequence(btrees, default_output, output_to_input, output_merge) {\n  if (btrees instanceof $Empty) {\n    return (input) => {\n      return new BehaviorResult(true, input.entity, default_output);\n    };\n  } else {\n    let bt = btrees.head;\n    let rest = btrees.tail;\n    return (input) => {\n      let $ = bt(input);\n      let success;\n      let e;\n      let first_behavior_outputs;\n      success = $.success;\n      e = $.entity;\n      first_behavior_outputs = $.additional_outputs;\n      if (success) {\n        let next_input = new BehaviorInput(\n          e,\n          output_to_input(input.additional_inputs, first_behavior_outputs),\n        );\n        let $1 = sequence(rest, default_output, output_to_input, output_merge)(\n          next_input,\n        );\n        let success$1;\n        let e$1;\n        let rest_outputs;\n        success$1 = $1.success;\n        e$1 = $1.entity;\n        rest_outputs = $1.additional_outputs;\n        let final_outputs = output_merge(first_behavior_outputs, rest_outputs);\n        return new BehaviorResult(success$1, e$1, final_outputs);\n      } else {\n        return new BehaviorResult(\n          false,\n          e,\n          output_merge(default_output, first_behavior_outputs),\n        );\n      }\n    };\n  }\n}\n\n/**\n * Creates a behavior tree that performs all the given behavior trees and always succeeds.\n */\nexport function all(btrees, default_output, output_to_input, output_merge) {\n  if (btrees instanceof $Empty) {\n    return (input) => {\n      return new BehaviorResult(true, input.entity, default_output);\n    };\n  } else {\n    let bt = btrees.head;\n    let rest = btrees.tail;\n    return (input) => {\n      let $ = bt(input);\n      let e;\n      let first_behavior_outputs;\n      e = $.entity;\n      first_behavior_outputs = $.additional_outputs;\n      let next_input = new BehaviorInput(\n        e,\n        output_to_input(input.additional_inputs, first_behavior_outputs),\n      );\n      let $1 = all(rest, default_output, output_to_input, output_merge)(\n        next_input,\n      );\n      let success;\n      let e$1;\n      let rest_outputs;\n      success = $1.success;\n      e$1 = $1.entity;\n      rest_outputs = $1.additional_outputs;\n      let final_outputs = output_merge(first_behavior_outputs, rest_outputs);\n      return new BehaviorResult(success, e$1, final_outputs);\n    };\n  }\n}\n","export function now() {\n  return Date.now().valueOf();\n}\n","//# sourceMappingURL=result.mjs.map\nimport { Ok, Error, toList, Empty as $Empty, prepend as listPrepend } from \"../gleam.mjs\";\nimport * as $list from \"../gleam/list.mjs\";\n\n/**\n * Checks whether the result is an `Ok` value.\n *\n * ## Examples\n *\n * ```gleam\n * is_ok(Ok(1))\n * // -> True\n * ```\n *\n * ```gleam\n * is_ok(Error(Nil))\n * // -> False\n * ```\n */\nexport function is_ok(result) {\n  if (result instanceof Ok) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Checks whether the result is an `Error` value.\n *\n * ## Examples\n *\n * ```gleam\n * is_error(Ok(1))\n * // -> False\n * ```\n *\n * ```gleam\n * is_error(Error(Nil))\n * // -> True\n * ```\n */\nexport function is_error(result) {\n  if (result instanceof Ok) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n/**\n * Updates a value held within the `Ok` of a result by calling a given function\n * on it.\n *\n * If the result is an `Error` rather than `Ok` the function is not called and the\n * result stays the same.\n *\n * ## Examples\n *\n * ```gleam\n * map(over: Ok(1), with: fn(x) { x + 1 })\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * map(over: Error(1), with: fn(x) { x + 1 })\n * // -> Error(1)\n * ```\n */\nexport function map(result, fun) {\n  if (result instanceof Ok) {\n    let x = result[0];\n    return new Ok(fun(x));\n  } else {\n    return result;\n  }\n}\n\n/**\n * Updates a value held within the `Error` of a result by calling a given function\n * on it.\n *\n * If the result is `Ok` rather than `Error` the function is not called and the\n * result stays the same.\n *\n * ## Examples\n *\n * ```gleam\n * map_error(over: Error(1), with: fn(x) { x + 1 })\n * // -> Error(2)\n * ```\n *\n * ```gleam\n * map_error(over: Ok(1), with: fn(x) { x + 1 })\n * // -> Ok(1)\n * ```\n */\nexport function map_error(result, fun) {\n  if (result instanceof Ok) {\n    return result;\n  } else {\n    let error = result[0];\n    return new Error(fun(error));\n  }\n}\n\n/**\n * Merges a nested `Result` into a single layer.\n *\n * ## Examples\n *\n * ```gleam\n * flatten(Ok(Ok(1)))\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * flatten(Ok(Error(\"\")))\n * // -> Error(\"\")\n * ```\n *\n * ```gleam\n * flatten(Error(Nil))\n * // -> Error(Nil)\n * ```\n */\nexport function flatten(result) {\n  if (result instanceof Ok) {\n    let x = result[0];\n    return x;\n  } else {\n    return result;\n  }\n}\n\n/**\n * \"Updates\" an `Ok` result by passing its value to a function that yields a result,\n * and returning the yielded result. (This may \"replace\" the `Ok` with an `Error`.)\n *\n * If the input is an `Error` rather than an `Ok`, the function is not called and\n * the original `Error` is returned.\n *\n * This function is the equivalent of calling `map` followed by `flatten`, and\n * it is useful for chaining together multiple functions that may fail.\n *\n * ## Examples\n *\n * ```gleam\n * try(Ok(1), fn(x) { Ok(x + 1) })\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * try(Ok(1), fn(x) { Ok(#(\"a\", x)) })\n * // -> Ok(#(\"a\", 1))\n * ```\n *\n * ```gleam\n * try(Ok(1), fn(_) { Error(\"Oh no\") })\n * // -> Error(\"Oh no\")\n * ```\n *\n * ```gleam\n * try(Error(Nil), fn(x) { Ok(x + 1) })\n * // -> Error(Nil)\n * ```\n */\nexport function try$(result, fun) {\n  if (result instanceof Ok) {\n    let x = result[0];\n    return fun(x);\n  } else {\n    return result;\n  }\n}\n\nexport function then$(result, fun) {\n  return try$(result, fun);\n}\n\n/**\n * Extracts the `Ok` value from a result, returning a default value if the result\n * is an `Error`.\n *\n * ## Examples\n *\n * ```gleam\n * unwrap(Ok(1), 0)\n * // -> 1\n * ```\n *\n * ```gleam\n * unwrap(Error(\"\"), 0)\n * // -> 0\n * ```\n */\nexport function unwrap(result, default$) {\n  if (result instanceof Ok) {\n    let v = result[0];\n    return v;\n  } else {\n    return default$;\n  }\n}\n\n/**\n * Extracts the `Ok` value from a result, evaluating the default function if the result\n * is an `Error`.\n *\n * ## Examples\n *\n * ```gleam\n * lazy_unwrap(Ok(1), fn() { 0 })\n * // -> 1\n * ```\n *\n * ```gleam\n * lazy_unwrap(Error(\"\"), fn() { 0 })\n * // -> 0\n * ```\n */\nexport function lazy_unwrap(result, default$) {\n  if (result instanceof Ok) {\n    let v = result[0];\n    return v;\n  } else {\n    return default$();\n  }\n}\n\n/**\n * Extracts the `Error` value from a result, returning a default value if the result\n * is an `Ok`.\n *\n * ## Examples\n *\n * ```gleam\n * unwrap_error(Error(1), 0)\n * // -> 1\n * ```\n *\n * ```gleam\n * unwrap_error(Ok(\"\"), 0)\n * // -> 0\n * ```\n */\nexport function unwrap_error(result, default$) {\n  if (result instanceof Ok) {\n    return default$;\n  } else {\n    let e = result[0];\n    return e;\n  }\n}\n\nexport function unwrap_both(result) {\n  if (result instanceof Ok) {\n    let a = result[0];\n    return a;\n  } else {\n    let a = result[0];\n    return a;\n  }\n}\n\n/**\n * Returns the first value if it is `Ok`, otherwise returns the second value.\n *\n * ## Examples\n *\n * ```gleam\n * or(Ok(1), Ok(2))\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * or(Ok(1), Error(\"Error 2\"))\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * or(Error(\"Error 1\"), Ok(2))\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * or(Error(\"Error 1\"), Error(\"Error 2\"))\n * // -> Error(\"Error 2\")\n * ```\n */\nexport function or(first, second) {\n  if (first instanceof Ok) {\n    return first;\n  } else {\n    return second;\n  }\n}\n\n/**\n * Returns the first value if it is `Ok`, otherwise evaluates the given function for a fallback value.\n *\n * If you need access to the initial error value, use `result.try_recover`.\n *\n * ## Examples\n *\n * ```gleam\n * lazy_or(Ok(1), fn() { Ok(2) })\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * lazy_or(Ok(1), fn() { Error(\"Error 2\") })\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * lazy_or(Error(\"Error 1\"), fn() { Ok(2) })\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * lazy_or(Error(\"Error 1\"), fn() { Error(\"Error 2\") })\n * // -> Error(\"Error 2\")\n * ```\n */\nexport function lazy_or(first, second) {\n  if (first instanceof Ok) {\n    return first;\n  } else {\n    return second();\n  }\n}\n\n/**\n * Combines a list of results into a single result.\n * If all elements in the list are `Ok` then returns an `Ok` holding the list of values.\n * If any element is `Error` then returns the first error.\n *\n * ## Examples\n *\n * ```gleam\n * all([Ok(1), Ok(2)])\n * // -> Ok([1, 2])\n * ```\n *\n * ```gleam\n * all([Ok(1), Error(\"e\")])\n * // -> Error(\"e\")\n * ```\n */\nexport function all(results) {\n  return $list.try_map(results, (result) => { return result; });\n}\n\nfunction partition_loop(loop$results, loop$oks, loop$errors) {\n  while (true) {\n    let results = loop$results;\n    let oks = loop$oks;\n    let errors = loop$errors;\n    if (results instanceof $Empty) {\n      return [oks, errors];\n    } else {\n      let $ = results.head;\n      if ($ instanceof Ok) {\n        let rest = results.tail;\n        let a = $[0];\n        loop$results = rest;\n        loop$oks = listPrepend(a, oks);\n        loop$errors = errors;\n      } else {\n        let rest = results.tail;\n        let e = $[0];\n        loop$results = rest;\n        loop$oks = oks;\n        loop$errors = listPrepend(e, errors);\n      }\n    }\n  }\n}\n\n/**\n * Given a list of results, returns a pair where the first element is a list\n * of all the values inside `Ok` and the second element is a list with all the\n * values inside `Error`. The values in both lists appear in reverse order with\n * respect to their position in the original list of results.\n *\n * ## Examples\n *\n * ```gleam\n * partition([Ok(1), Error(\"a\"), Error(\"b\"), Ok(2)])\n * // -> #([2, 1], [\"b\", \"a\"])\n * ```\n */\nexport function partition(results) {\n  return partition_loop(results, toList([]), toList([]));\n}\n\n/**\n * Replace the value within a result\n *\n * ## Examples\n *\n * ```gleam\n * replace(Ok(1), Nil)\n * // -> Ok(Nil)\n * ```\n *\n * ```gleam\n * replace(Error(1), Nil)\n * // -> Error(1)\n * ```\n */\nexport function replace(result, value) {\n  if (result instanceof Ok) {\n    return new Ok(value);\n  } else {\n    return result;\n  }\n}\n\n/**\n * Replace the error within a result\n *\n * ## Examples\n *\n * ```gleam\n * replace_error(Error(1), Nil)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * replace_error(Ok(1), Nil)\n * // -> Ok(1)\n * ```\n */\nexport function replace_error(result, error) {\n  if (result instanceof Ok) {\n    return result;\n  } else {\n    return new Error(error);\n  }\n}\n\n/**\n * Given a list of results, returns only the values inside `Ok`.\n *\n * ## Examples\n *\n * ```gleam\n * values([Ok(1), Error(\"a\"), Ok(3)])\n * // -> [1, 3]\n * ```\n */\nexport function values(results) {\n  return $list.filter_map(results, (result) => { return result; });\n}\n\n/**\n * Updates a value held within the `Error` of a result by calling a given function\n * on it, where the given function also returns a result. The two results are\n * then merged together into one result.\n *\n * If the result is an `Ok` rather than `Error` the function is not called and the\n * result stays the same.\n *\n * This function is useful for chaining together computations that may fail\n * and trying to recover from possible errors.\n *\n * If you do not need access to the initial error value, use `result.lazy_or`.\n *\n * ## Examples\n *\n * ```gleam\n * Ok(1) |> try_recover(with: fn(_) { Error(\"failed to recover\") })\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * Error(1) |> try_recover(with: fn(error) { Ok(error + 1) })\n * // -> Ok(2)\n * ```\n *\n * ```gleam\n * Error(1) |> try_recover(with: fn(error) { Error(\"failed to recover\") })\n * // -> Error(\"failed to recover\")\n * ```\n */\nexport function try_recover(result, fun) {\n  if (result instanceof Ok) {\n    return result;\n  } else {\n    let error = result[0];\n    return fun(error);\n  }\n}\n","//# sourceMappingURL=yielder.mjs.map\nimport * as $dict from \"../../gleam_stdlib/gleam/dict.mjs\";\nimport * as $int from \"../../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../../gleam_stdlib/gleam/list.mjs\";\nimport * as $option from \"../../gleam_stdlib/gleam/option.mjs\";\nimport { None, Some } from \"../../gleam_stdlib/gleam/option.mjs\";\nimport * as $order from \"../../gleam_stdlib/gleam/order.mjs\";\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  isEqual,\n} from \"../gleam.mjs\";\n\nclass Stop extends $CustomType {}\n\nclass Continue extends $CustomType {\n  constructor($0, $1) {\n    super();\n    this[0] = $0;\n    this[1] = $1;\n  }\n}\n\nclass Yielder extends $CustomType {\n  constructor(continuation) {\n    super();\n    this.continuation = continuation;\n  }\n}\n\nexport class Next extends $CustomType {\n  constructor(element, accumulator) {\n    super();\n    this.element = element;\n    this.accumulator = accumulator;\n  }\n}\nexport const Step$Next = (element, accumulator) =>\n  new Next(element, accumulator);\nexport const Step$isNext = (value) => value instanceof Next;\nexport const Step$Next$element = (value) => value.element;\nexport const Step$Next$0 = (value) => value.element;\nexport const Step$Next$accumulator = (value) => value.accumulator;\nexport const Step$Next$1 = (value) => value.accumulator;\n\nexport class Done extends $CustomType {}\nexport const Step$Done = () => new Done();\nexport const Step$isDone = (value) => value instanceof Done;\n\nclass AnotherBy extends $CustomType {\n  constructor($0, $1, $2, $3) {\n    super();\n    this[0] = $0;\n    this[1] = $1;\n    this[2] = $2;\n    this[3] = $3;\n  }\n}\n\nclass LastBy extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\n\nclass Another extends $CustomType {\n  constructor($0, $1) {\n    super();\n    this[0] = $0;\n    this[1] = $1;\n  }\n}\n\nclass Last extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\n\nclass NoMore extends $CustomType {}\n\nfunction stop() {\n  return new Stop();\n}\n\nfunction unfold_loop(initial, f) {\n  return () => {\n    let $ = f(initial);\n    if ($ instanceof Next) {\n      let x = $.element;\n      let acc = $.accumulator;\n      return new Continue(x, unfold_loop(acc, f));\n    } else {\n      return new Stop();\n    }\n  };\n}\n\n/**\n * Creates an yielder from a given function and accumulator.\n *\n * The function is called on the accumulator and returns either `Done`,\n * indicating the yielder has no more elements, or `Next` which contains a\n * new element and accumulator. The element is yielded by the yielder and the\n * new accumulator is used with the function to compute the next element in\n * the sequence.\n *\n * ## Examples\n *\n * ```gleam\n * unfold(from: 5, with: fn(n) {\n *  case n {\n *    0 -> Done\n *    n -> Next(element: n, accumulator: n - 1)\n *  }\n * })\n * |> to_list\n * // -> [5, 4, 3, 2, 1]\n * ```\n */\nexport function unfold(initial, f) {\n  let _pipe = initial;\n  let _pipe$1 = unfold_loop(_pipe, f);\n  return new Yielder(_pipe$1);\n}\n\n/**\n * Creates an yielder that yields values created by calling a given function\n * repeatedly.\n *\n * ```gleam\n * repeatedly(fn() { 7 })\n * |> take(3)\n * |> to_list\n * // -> [7, 7, 7]\n * ```\n */\nexport function repeatedly(f) {\n  return unfold(undefined, (_) => { return new Next(f(), undefined); });\n}\n\n/**\n * Creates an yielder that returns the same value infinitely.\n *\n * ## Examples\n *\n * ```gleam\n * repeat(10)\n * |> take(4)\n * |> to_list\n * // -> [10, 10, 10, 10]\n * ```\n */\nexport function repeat(x) {\n  return repeatedly(() => { return x; });\n}\n\n/**\n * Creates an yielder that yields each element from the given list.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4])\n * |> to_list\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function from_list(list) {\n  let yield$1 = (acc) => {\n    if (acc instanceof $Empty) {\n      return new Done();\n    } else {\n      let head = acc.head;\n      let tail = acc.tail;\n      return new Next(head, tail);\n    }\n  };\n  return unfold(list, yield$1);\n}\n\nfunction transform_loop(continuation, state, f) {\n  return () => {\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let el = $[0];\n      let next = $[1];\n      let $1 = f(state, el);\n      if ($1 instanceof Next) {\n        let yield$1 = $1.element;\n        let next_state = $1.accumulator;\n        return new Continue(yield$1, transform_loop(next, next_state, f));\n      } else {\n        return new Stop();\n      }\n    }\n  };\n}\n\n/**\n * Creates an yielder from an existing yielder\n * and a stateful function that may short-circuit.\n *\n * `f` takes arguments `acc` for current state and `el` for current element from underlying yielder,\n * and returns either `Next` with yielded element and new state value, or `Done` to halt the yielder.\n *\n * ## Examples\n *\n * Approximate implementation of `index` in terms of `transform`:\n *\n * ```gleam\n * from_list([\"a\", \"b\", \"c\"])\n * |> transform(0, fn(i, el) { Next(#(i, el), i + 1) })\n * |> to_list\n * // -> [#(0, \"a\"), #(1, \"b\"), #(2, \"c\")]\n * ```\n */\nexport function transform(yielder, initial, f) {\n  let _pipe = transform_loop(yielder.continuation, initial, f);\n  return new Yielder(_pipe);\n}\n\nfunction fold_loop(loop$continuation, loop$f, loop$accumulator) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let accumulator = loop$accumulator;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return accumulator;\n    } else {\n      let elem = $[0];\n      let next = $[1];\n      loop$continuation = next;\n      loop$f = f;\n      loop$accumulator = f(accumulator, elem);\n    }\n  }\n}\n\n/**\n * Reduces an yielder of elements into a single value by calling a given\n * function on each element in turn.\n *\n * If called on an yielder of infinite length then this function will never\n * return.\n *\n * If you do not care about the end value and only wish to evaluate the\n * yielder for side effects consider using the `run` function instead.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4])\n * |> fold(from: 0, with: fn(acc, element) { element + acc })\n * // -> 10\n * ```\n */\nexport function fold(yielder, initial, f) {\n  let _pipe = yielder.continuation;\n  return fold_loop(_pipe, f, initial);\n}\n\n/**\n * Evaluates all elements emitted by the given yielder. This function is useful for when\n * you wish to trigger any side effects that would occur when evaluating\n * the yielder.\n */\nexport function run(yielder) {\n  return fold(yielder, undefined, (_, _1) => { return undefined; });\n}\n\n/**\n * Evaluates an yielder and returns all the elements as a list.\n *\n * If called on an yielder of infinite length then this function will never\n * return.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3])\n * |> map(fn(x) { x * 2 })\n * |> to_list\n * // -> [2, 4, 6]\n * ```\n */\nexport function to_list(yielder) {\n  let _pipe = yielder;\n  let _pipe$1 = fold(\n    _pipe,\n    toList([]),\n    (acc, e) => { return listPrepend(e, acc); },\n  );\n  return $list.reverse(_pipe$1);\n}\n\n/**\n * Eagerly accesses the first value of an yielder, returning a `Next`\n * that contains the first value and the rest of the yielder.\n *\n * If called on an empty yielder, `Done` is returned.\n *\n * ## Examples\n *\n * ```gleam\n * let assert Next(first, rest) = from_list([1, 2, 3, 4]) |> step\n *\n * first\n * // -> 1\n *\n * rest |> to_list\n * // -> [2, 3, 4]\n * ```\n *\n * ```gleam\n * empty() |> step\n * // -> Done\n * ```\n */\nexport function step(yielder) {\n  let $ = yielder.continuation();\n  if ($ instanceof Stop) {\n    return new Done();\n  } else {\n    let e = $[0];\n    let a = $[1];\n    return new Next(e, new Yielder(a));\n  }\n}\n\nfunction take_loop(continuation, desired) {\n  return () => {\n    let $ = desired > 0;\n    if ($) {\n      let $1 = continuation();\n      if ($1 instanceof Stop) {\n        return $1;\n      } else {\n        let e = $1[0];\n        let next = $1[1];\n        return new Continue(e, take_loop(next, desired - 1));\n      }\n    } else {\n      return new Stop();\n    }\n  };\n}\n\n/**\n * Creates an yielder that only yields the first `desired` elements.\n *\n * If the yielder does not have enough elements all of them are yielded.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5])\n * |> take(up_to: 3)\n * |> to_list\n * // -> [1, 2, 3]\n * ```\n *\n * ```gleam\n * from_list([1, 2])\n * |> take(up_to: 3)\n * |> to_list\n * // -> [1, 2]\n * ```\n */\nexport function take(yielder, desired) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = take_loop(_pipe, desired);\n  return new Yielder(_pipe$1);\n}\n\nfunction drop_loop(loop$continuation, loop$desired) {\n  while (true) {\n    let continuation = loop$continuation;\n    let desired = loop$desired;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = desired > 0;\n      if ($1) {\n        loop$continuation = next;\n        loop$desired = desired - 1;\n      } else {\n        return new Continue(e, next);\n      }\n    }\n  }\n}\n\n/**\n * Evaluates and discards the first N elements in an yielder, returning a new\n * yielder.\n *\n * If the yielder does not have enough elements an empty yielder is\n * returned.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5])\n * |> drop(up_to: 3)\n * |> to_list\n * // -> [4, 5]\n * ```\n *\n * ```gleam\n * from_list([1, 2])\n * |> drop(up_to: 3)\n * |> to_list\n * // -> []\n * ```\n */\nexport function drop(yielder, desired) {\n  let _pipe = () => { return drop_loop(yielder.continuation, desired); };\n  return new Yielder(_pipe);\n}\n\nfunction map_loop(continuation, f) {\n  return () => {\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let continuation$1 = $[1];\n      return new Continue(f(e), map_loop(continuation$1, f));\n    }\n  };\n}\n\n/**\n * Creates an yielder from an existing yielder and a transformation function.\n *\n * Each element in the new yielder will be the result of calling the given\n * function on the elements in the given yielder.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3])\n * |> map(fn(x) { x * 2 })\n * |> to_list\n * // -> [2, 4, 6]\n * ```\n */\nexport function map(yielder, f) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = map_loop(_pipe, f);\n  return new Yielder(_pipe$1);\n}\n\nfunction map2_loop(continuation1, continuation2, fun) {\n  return () => {\n    let $ = continuation1();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let a = $[0];\n      let next_a = $[1];\n      let $1 = continuation2();\n      if ($1 instanceof Stop) {\n        return $1;\n      } else {\n        let b = $1[0];\n        let next_b = $1[1];\n        return new Continue(fun(a, b), map2_loop(next_a, next_b, fun));\n      }\n    }\n  };\n}\n\n/**\n * Combines two yielders into a single one using the given function.\n *\n * If an yielder is longer than the other the extra elements are dropped.\n *\n * This function does not evaluate the elements of the two yielders, the\n * computation is performed when the resulting yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * let first = from_list([1, 2, 3])\n * let second = from_list([4, 5, 6])\n * map2(first, second, fn(x, y) { x + y }) |> to_list\n * // -> [5, 7, 9]\n * ```\n *\n * ```gleam\n * let first = from_list([1, 2])\n * let second = from_list([\"a\", \"b\", \"c\"])\n * map2(first, second, fn(i, x) { #(i, x) }) |> to_list\n * // -> [#(1, \"a\"), #(2, \"b\")]\n * ```\n */\nexport function map2(yielder1, yielder2, fun) {\n  let _pipe = map2_loop(yielder1.continuation, yielder2.continuation, fun);\n  return new Yielder(_pipe);\n}\n\nfunction append_loop(first, second) {\n  let $ = first();\n  if ($ instanceof Stop) {\n    return second();\n  } else {\n    let e = $[0];\n    let first$1 = $[1];\n    return new Continue(e, () => { return append_loop(first$1, second); });\n  }\n}\n\n/**\n * Appends two yielders, producing a new yielder.\n *\n * This function does not evaluate the elements of the yielders, the\n * computation is performed when the resulting yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2])\n * |> append(from_list([3, 4]))\n * |> to_list\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function append(first, second) {\n  let _pipe = () => {\n    return append_loop(first.continuation, second.continuation);\n  };\n  return new Yielder(_pipe);\n}\n\nfunction flatten_loop(flattened) {\n  let $ = flattened();\n  if ($ instanceof Stop) {\n    return $;\n  } else {\n    let it = $[0];\n    let next_yielder = $[1];\n    return append_loop(\n      it.continuation,\n      () => { return flatten_loop(next_yielder); },\n    );\n  }\n}\n\n/**\n * Flattens an yielder of yielders, creating a new yielder.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([[1, 2], [3, 4]])\n * |> map(from_list)\n * |> flatten\n * |> to_list\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function flatten(yielder) {\n  let _pipe = () => { return flatten_loop(yielder.continuation); };\n  return new Yielder(_pipe);\n}\n\n/**\n * Joins a list of yielders into a single yielder.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * [[1, 2], [3, 4]]\n * |> map(from_list)\n * |> concat\n * |> to_list\n * // -> [1, 2, 3, 4]\n * ```\n */\nexport function concat(yielders) {\n  return flatten(from_list(yielders));\n}\n\n/**\n * Creates an yielder from an existing yielder and a transformation function.\n *\n * Each element in the new yielder will be the result of calling the given\n * function on the elements in the given yielder and then flattening the\n * results.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2])\n * |> flat_map(fn(x) { from_list([x, x + 1]) })\n * |> to_list\n * // -> [1, 2, 2, 3]\n * ```\n */\nexport function flat_map(yielder, f) {\n  let _pipe = yielder;\n  let _pipe$1 = map(_pipe, f);\n  return flatten(_pipe$1);\n}\n\nfunction filter_loop(loop$continuation, loop$predicate) {\n  while (true) {\n    let continuation = loop$continuation;\n    let predicate = loop$predicate;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let yielder = $[1];\n      let $1 = predicate(e);\n      if ($1) {\n        return new Continue(\n          e,\n          () => { return filter_loop(yielder, predicate); },\n        );\n      } else {\n        loop$continuation = yielder;\n        loop$predicate = predicate;\n      }\n    }\n  }\n}\n\n/**\n * Creates an yielder from an existing yielder and a predicate function.\n *\n * The new yielder will contain elements from the first yielder for which\n * the given function returns `True`.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * from_list([1, 2, 3, 4])\n * |> filter(int.is_even)\n * |> to_list\n * // -> [2, 4]\n * ```\n */\nexport function filter(yielder, predicate) {\n  let _pipe = () => { return filter_loop(yielder.continuation, predicate); };\n  return new Yielder(_pipe);\n}\n\nfunction filter_map_loop(loop$continuation, loop$f) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = f(e);\n      if ($1 instanceof Ok) {\n        let e$1 = $1[0];\n        return new Continue(e$1, () => { return filter_map_loop(next, f); });\n      } else {\n        loop$continuation = next;\n        loop$f = f;\n      }\n    }\n  }\n}\n\n/**\n * Creates an yielder from an existing yielder and a transforming predicate function.\n *\n * The new yielder will contain elements from the first yielder for which\n * the given function returns `Ok`, transformed to the value inside the `Ok`.\n *\n * This function does not evaluate the elements of the yielder, the\n * computation is performed when the yielder is later run.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/string\n * import gleam/int\n *\n * \"a1b2c3d4e5f\"\n * |> string.to_graphemes\n * |> from_list\n * |> filter_map(int.parse)\n * |> to_list\n * // -> [1, 2, 3, 4, 5]\n * ```\n */\nexport function filter_map(yielder, f) {\n  let _pipe = () => { return filter_map_loop(yielder.continuation, f); };\n  return new Yielder(_pipe);\n}\n\n/**\n * Creates an yielder that repeats a given yielder infinitely.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2])\n * |> cycle\n * |> take(6)\n * |> to_list\n * // -> [1, 2, 1, 2, 1, 2]\n * ```\n */\nexport function cycle(yielder) {\n  let _pipe = repeat(yielder);\n  return flatten(_pipe);\n}\n\nfunction find_loop(loop$continuation, loop$f) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return new Error(undefined);\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = f(e);\n      if ($1) {\n        return new Ok(e);\n      } else {\n        loop$continuation = next;\n        loop$f = f;\n      }\n    }\n  }\n}\n\n/**\n * Finds the first element in a given yielder for which the given function returns\n * `True`.\n *\n * Returns `Error(Nil)` if the function does not return `True` for any of the\n * elements.\n *\n * ## Examples\n *\n * ```gleam\n * find(from_list([1, 2, 3]), fn(x) { x > 2 })\n * // -> Ok(3)\n * ```\n *\n * ```gleam\n * find(from_list([1, 2, 3]), fn(x) { x > 4 })\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * find(empty(), fn(_) { True })\n * // -> Error(Nil)\n * ```\n */\nexport function find(haystack, is_desired) {\n  let _pipe = haystack.continuation;\n  return find_loop(_pipe, is_desired);\n}\n\nfunction find_map_loop(loop$continuation, loop$f) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return new Error(undefined);\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = f(e);\n      if ($1 instanceof Ok) {\n        return $1;\n      } else {\n        loop$continuation = next;\n        loop$f = f;\n      }\n    }\n  }\n}\n\n/**\n * Finds the first element in a given yielder\n * for which the given function returns `Ok(new_value)`,\n * then returns the wrapped `new_value`.\n *\n * Returns `Error(Nil)` if no such element is found.\n *\n * ## Examples\n *\n * ```gleam\n * find_map(from_list([\"a\", \"1\", \"2\"]), int.parse)\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * find_map(from_list([\"a\", \"b\", \"c\"]), int.parse)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * find_map(from_list([]), int.parse)\n * // -> Error(Nil)\n * ```\n */\nexport function find_map(haystack, is_desired) {\n  let _pipe = haystack.continuation;\n  return find_map_loop(_pipe, is_desired);\n}\n\nfunction index_loop(continuation, next) {\n  return () => {\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let continuation$1 = $[1];\n      return new Continue([e, next], index_loop(continuation$1, next + 1));\n    }\n  };\n}\n\n/**\n * Wraps values yielded from an yielder with indices, starting from 0.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([\"a\", \"b\", \"c\"]) |> index |> to_list\n * // -> [#(\"a\", 0), #(\"b\", 1), #(\"c\", 2)]\n * ```\n */\nexport function index(yielder) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = index_loop(_pipe, 0);\n  return new Yielder(_pipe$1);\n}\n\n/**\n * Creates an yielder that infinitely applies a function to a value.\n *\n * ## Examples\n *\n * ```gleam\n * iterate(1, fn(n) { n * 3 }) |> take(5) |> to_list\n * // -> [1, 3, 9, 27, 81]\n * ```\n */\nexport function iterate(initial, f) {\n  return unfold(initial, (element) => { return new Next(element, f(element)); });\n}\n\nfunction take_while_loop(continuation, predicate) {\n  return () => {\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = predicate(e);\n      if ($1) {\n        return new Continue(e, take_while_loop(next, predicate));\n      } else {\n        return new Stop();\n      }\n    }\n  };\n}\n\n/**\n * Creates an yielder that yields elements while the predicate returns `True`.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 2, 4])\n * |> take_while(satisfying: fn(x) { x < 3 })\n * |> to_list\n * // -> [1, 2]\n * ```\n */\nexport function take_while(yielder, predicate) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = take_while_loop(_pipe, predicate);\n  return new Yielder(_pipe$1);\n}\n\nfunction drop_while_loop(loop$continuation, loop$predicate) {\n  while (true) {\n    let continuation = loop$continuation;\n    let predicate = loop$predicate;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = predicate(e);\n      if ($1) {\n        loop$continuation = next;\n        loop$predicate = predicate;\n      } else {\n        return new Continue(e, next);\n      }\n    }\n  }\n}\n\n/**\n * Creates an yielder that drops elements while the predicate returns `True`,\n * and then yields the remaining elements.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 2, 5])\n * |> drop_while(satisfying: fn(x) { x < 4 })\n * |> to_list\n * // -> [4, 2, 5]\n * ```\n */\nexport function drop_while(yielder, predicate) {\n  let _pipe = () => { return drop_while_loop(yielder.continuation, predicate); };\n  return new Yielder(_pipe);\n}\n\nfunction scan_loop(continuation, f, accumulator) {\n  return () => {\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let el = $[0];\n      let next = $[1];\n      let accumulated = f(accumulator, el);\n      return new Continue(accumulated, scan_loop(next, f, accumulated));\n    }\n  };\n}\n\n/**\n * Creates an yielder from an existing yielder and a stateful function.\n *\n * Specifically, this behaves like `fold`, but yields intermediate results.\n *\n * ## Examples\n *\n * ```gleam\n * // Generate a sequence of partial sums\n * from_list([1, 2, 3, 4, 5])\n * |> scan(from: 0, with: fn(acc, el) { acc + el })\n * |> to_list\n * // -> [1, 3, 6, 10, 15]\n * ```\n */\nexport function scan(yielder, initial, f) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = scan_loop(_pipe, f, initial);\n  return new Yielder(_pipe$1);\n}\n\nfunction zip_loop(left, right) {\n  return () => {\n    let $ = left();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let el_left = $[0];\n      let next_left = $[1];\n      let $1 = right();\n      if ($1 instanceof Stop) {\n        return $1;\n      } else {\n        let el_right = $1[0];\n        let next_right = $1[1];\n        return new Continue(\n          [el_left, el_right],\n          zip_loop(next_left, next_right),\n        );\n      }\n    }\n  };\n}\n\n/**\n * Zips two yielders together, emitting values from both\n * until the shorter one runs out.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([\"a\", \"b\", \"c\"])\n * |> zip(range(20, 30))\n * |> to_list\n * // -> [#(\"a\", 20), #(\"b\", 21), #(\"c\", 22)]\n * ```\n */\nexport function zip(left, right) {\n  let _pipe = zip_loop(left.continuation, right.continuation);\n  return new Yielder(_pipe);\n}\n\nfunction next_chunk(\n  loop$continuation,\n  loop$f,\n  loop$previous_key,\n  loop$current_chunk\n) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let previous_key = loop$previous_key;\n    let current_chunk = loop$current_chunk;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return new LastBy($list.reverse(current_chunk));\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let key = f(e);\n      let $1 = isEqual(key, previous_key);\n      if ($1) {\n        loop$continuation = next;\n        loop$f = f;\n        loop$previous_key = key;\n        loop$current_chunk = listPrepend(e, current_chunk);\n      } else {\n        return new AnotherBy($list.reverse(current_chunk), key, e, next);\n      }\n    }\n  }\n}\n\nfunction chunk_loop(continuation, f, previous_key, previous_element) {\n  let $ = next_chunk(continuation, f, previous_key, toList([previous_element]));\n  if ($ instanceof AnotherBy) {\n    let chunk$1 = $[0];\n    let key = $[1];\n    let el = $[2];\n    let next = $[3];\n    return new Continue(chunk$1, () => { return chunk_loop(next, f, key, el); });\n  } else {\n    let chunk$1 = $[0];\n    return new Continue(chunk$1, stop);\n  }\n}\n\n/**\n * Creates an yielder that emits chunks of elements\n * for which `f` returns the same value.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 2, 3, 4, 4, 6, 7, 7])\n * |> chunk(by: fn(n) { n % 2 })\n * |> to_list\n * // -> [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n * ```\n */\nexport function chunk(yielder, f) {\n  let _pipe = () => {\n    let $ = yielder.continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      return chunk_loop(next, f, f(e), e);\n    }\n  };\n  return new Yielder(_pipe);\n}\n\nfunction next_sized_chunk(loop$continuation, loop$left, loop$current_chunk) {\n  while (true) {\n    let continuation = loop$continuation;\n    let left = loop$left;\n    let current_chunk = loop$current_chunk;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      if (current_chunk instanceof $Empty) {\n        return new NoMore();\n      } else {\n        let remaining = current_chunk;\n        return new Last($list.reverse(remaining));\n      }\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let chunk$1 = listPrepend(e, current_chunk);\n      let $1 = left > 1;\n      if ($1) {\n        loop$continuation = next;\n        loop$left = left - 1;\n        loop$current_chunk = chunk$1;\n      } else {\n        return new Another($list.reverse(chunk$1), next);\n      }\n    }\n  }\n}\n\nfunction sized_chunk_loop(continuation, count) {\n  return () => {\n    let $ = next_sized_chunk(continuation, count, toList([]));\n    if ($ instanceof Another) {\n      let chunk$1 = $[0];\n      let next_element = $[1];\n      return new Continue(chunk$1, sized_chunk_loop(next_element, count));\n    } else if ($ instanceof Last) {\n      let chunk$1 = $[0];\n      return new Continue(chunk$1, stop);\n    } else {\n      return new Stop();\n    }\n  };\n}\n\n/**\n * Creates an yielder that emits chunks of given size.\n *\n * If the last chunk does not have `count` elements, it is yielded\n * as a partial chunk, with less than `count` elements.\n *\n * For any `count` less than 1 this function behaves as if it was set to 1.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5, 6])\n * |> sized_chunk(into: 2)\n * |> to_list\n * // -> [[1, 2], [3, 4], [5, 6]]\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5, 6, 7, 8])\n * |> sized_chunk(into: 3)\n * |> to_list\n * // -> [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function sized_chunk(yielder, count) {\n  let _pipe = yielder.continuation;\n  let _pipe$1 = sized_chunk_loop(_pipe, count);\n  return new Yielder(_pipe$1);\n}\n\nfunction intersperse_loop(continuation, separator) {\n  let $ = continuation();\n  if ($ instanceof Stop) {\n    return $;\n  } else {\n    let e = $[0];\n    let next = $[1];\n    let next_interspersed = () => { return intersperse_loop(next, separator); };\n    return new Continue(\n      separator,\n      () => { return new Continue(e, next_interspersed); },\n    );\n  }\n}\n\n/**\n * Creates an yielder that yields the given `elem` element\n * between elements emitted by the underlying yielder.\n *\n * ## Examples\n *\n * ```gleam\n * empty()\n * |> intersperse(with: 0)\n * |> to_list\n * // -> []\n * ```\n *\n * ```gleam\n * from_list([1])\n * |> intersperse(with: 0)\n * |> to_list\n * // -> [1]\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5])\n * |> intersperse(with: 0)\n * |> to_list\n * // -> [1, 0, 2, 0, 3, 0, 4, 0, 5]\n * ```\n */\nexport function intersperse(yielder, elem) {\n  let _pipe = () => {\n    let $ = yielder.continuation();\n    if ($ instanceof Stop) {\n      return $;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      return new Continue(e, () => { return intersperse_loop(next, elem); });\n    }\n  };\n  return new Yielder(_pipe);\n}\n\nfunction any_loop(loop$continuation, loop$predicate) {\n  while (true) {\n    let continuation = loop$continuation;\n    let predicate = loop$predicate;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return false;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = predicate(e);\n      if ($1) {\n        return $1;\n      } else {\n        loop$continuation = next;\n        loop$predicate = predicate;\n      }\n    }\n  }\n}\n\n/**\n * Returns `True` if any element emitted by the yielder satisfies the given predicate,\n * `False` otherwise.\n *\n * This function short-circuits once it finds a satisfying element.\n *\n * An empty yielder results in `False`.\n *\n * ## Examples\n *\n * ```gleam\n * empty()\n * |> any(fn(n) { n % 2 == 0 })\n * // -> False\n * ```\n *\n * ```gleam\n * from_list([1, 2, 5, 7, 9])\n * |> any(fn(n) { n % 2 == 0 })\n * // -> True\n * ```\n *\n * ```gleam\n * from_list([1, 3, 5, 7, 9])\n * |> any(fn(n) { n % 2 == 0 })\n * // -> False\n * ```\n */\nexport function any(yielder, predicate) {\n  let _pipe = yielder.continuation;\n  return any_loop(_pipe, predicate);\n}\n\nfunction all_loop(loop$continuation, loop$predicate) {\n  while (true) {\n    let continuation = loop$continuation;\n    let predicate = loop$predicate;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return true;\n    } else {\n      let e = $[0];\n      let next = $[1];\n      let $1 = predicate(e);\n      if ($1) {\n        loop$continuation = next;\n        loop$predicate = predicate;\n      } else {\n        return $1;\n      }\n    }\n  }\n}\n\n/**\n * Returns `True` if all elements emitted by the yielder satisfy the given predicate,\n * `False` otherwise.\n *\n * This function short-circuits once it finds a non-satisfying element.\n *\n * An empty yielder results in `True`.\n *\n * ## Examples\n *\n * ```gleam\n * empty()\n * |> all(fn(n) { n % 2 == 0 })\n * // -> True\n * ```\n *\n * ```gleam\n * from_list([2, 4, 6, 8])\n * |> all(fn(n) { n % 2 == 0 })\n * // -> True\n * ```\n *\n * ```gleam\n * from_list([2, 4, 5, 8])\n * |> all(fn(n) { n % 2 == 0 })\n * // -> False\n * ```\n */\nexport function all(yielder, predicate) {\n  let _pipe = yielder.continuation;\n  return all_loop(_pipe, predicate);\n}\n\nfunction update_group_with(el) {\n  return (maybe_group) => {\n    if (maybe_group instanceof Some) {\n      let group$1 = maybe_group[0];\n      return listPrepend(el, group$1);\n    } else {\n      return toList([el]);\n    }\n  };\n}\n\nfunction group_updater(f) {\n  return (groups, elem) => {\n    let _pipe = groups;\n    return $dict.upsert(_pipe, f(elem), update_group_with(elem));\n  };\n}\n\n/**\n * Returns a `Dict(k, List(element))` of elements from the given yielder\n * grouped with the given key function.\n *\n * The order within each group is preserved from the yielder.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5, 6])\n * |> group(by: fn(n) { n % 3 })\n * // -> dict.from_list([#(0, [3, 6]), #(1, [1, 4]), #(2, [2, 5])])\n * ```\n */\nexport function group(yielder, key) {\n  let _pipe = yielder;\n  let _pipe$1 = fold(_pipe, $dict.new$(), group_updater(key));\n  return $dict.map_values(\n    _pipe$1,\n    (_, group) => { return $list.reverse(group); },\n  );\n}\n\n/**\n * This function acts similar to fold, but does not take an initial state.\n * Instead, it starts from the first yielded element\n * and combines it with each subsequent element in turn using the given function.\n * The function is called as `f(accumulator, current_element)`.\n *\n * Returns `Ok` to indicate a successful run, and `Error` if called on an empty yielder.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([])\n * |> reduce(fn(acc, x) { acc + x })\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4, 5])\n * |> reduce(fn(acc, x) { acc + x })\n * // -> Ok(15)\n * ```\n */\nexport function reduce(yielder, f) {\n  let $ = yielder.continuation();\n  if ($ instanceof Stop) {\n    return new Error(undefined);\n  } else {\n    let e = $[0];\n    let next = $[1];\n    let _pipe = fold_loop(next, f, e);\n    return new Ok(_pipe);\n  }\n}\n\n/**\n * Returns the last element in the given yielder.\n *\n * Returns `Error(Nil)` if the yielder is empty.\n *\n * This function runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * empty() |> last\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * range(1, 10) |> last\n * // -> Ok(10)\n * ```\n */\nexport function last(yielder) {\n  let _pipe = yielder;\n  return reduce(_pipe, (_, elem) => { return elem; });\n}\n\n/**\n * Creates an yielder that yields no elements.\n *\n * ## Examples\n *\n * ```gleam\n * empty() |> to_list\n * // -> []\n * ```\n */\nexport function empty() {\n  return new Yielder(stop);\n}\n\n/**\n * Creates an yielder that yields exactly one element provided by calling the given function.\n *\n * ## Examples\n *\n * ```gleam\n * once(fn() { 1 }) |> to_list\n * // -> [1]\n * ```\n */\nexport function once(f) {\n  let _pipe = () => { return new Continue(f(), stop); };\n  return new Yielder(_pipe);\n}\n\n/**\n * Creates an yielder of ints, starting at a given start int and stepping by\n * one to a given end int.\n *\n * ## Examples\n *\n * ```gleam\n * range(from: 1, to: 5) |> to_list\n * // -> [1, 2, 3, 4, 5]\n * ```\n *\n * ```gleam\n * range(from: 1, to: -2) |> to_list\n * // -> [1, 0, -1, -2]\n * ```\n *\n * ```gleam\n * range(from: 0, to: 0) |> to_list\n * // -> [0]\n * ```\n */\nexport function range(start, stop) {\n  let $ = $int.compare(start, stop);\n  if ($ instanceof $order.Lt) {\n    return unfold(\n      start,\n      (current) => {\n        let $1 = current > stop;\n        if ($1) {\n          return new Done();\n        } else {\n          return new Next(current, current + 1);\n        }\n      },\n    );\n  } else if ($ instanceof $order.Eq) {\n    return once(() => { return start; });\n  } else {\n    return unfold(\n      start,\n      (current) => {\n        let $1 = current < stop;\n        if ($1) {\n          return new Done();\n        } else {\n          return new Next(current, current - 1);\n        }\n      },\n    );\n  }\n}\n\n/**\n * Creates an yielder that yields the given element exactly once.\n *\n * ## Examples\n *\n * ```gleam\n * single(1) |> to_list\n * // -> [1]\n * ```\n */\nexport function single(elem) {\n  return once(() => { return elem; });\n}\n\nfunction interleave_loop(current, next) {\n  let $ = current();\n  if ($ instanceof Stop) {\n    return next();\n  } else {\n    let e = $[0];\n    let next_other = $[1];\n    return new Continue(e, () => { return interleave_loop(next, next_other); });\n  }\n}\n\n/**\n * Creates an yielder that alternates between the two given yielders\n * until both have run out.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4])\n * |> interleave(from_list([11, 12, 13, 14]))\n * |> to_list\n * // -> [1, 11, 2, 12, 3, 13, 4, 14]\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4])\n * |> interleave(from_list([100]))\n * |> to_list\n * // -> [1, 100, 2, 3, 4]\n * ```\n */\nexport function interleave(left, right) {\n  let _pipe = () => {\n    return interleave_loop(left.continuation, right.continuation);\n  };\n  return new Yielder(_pipe);\n}\n\nfunction fold_until_loop(loop$continuation, loop$f, loop$accumulator) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let accumulator = loop$accumulator;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return accumulator;\n    } else {\n      let elem = $[0];\n      let next = $[1];\n      let $1 = f(accumulator, elem);\n      if ($1 instanceof $list.Continue) {\n        let accumulator$1 = $1[0];\n        loop$continuation = next;\n        loop$f = f;\n        loop$accumulator = accumulator$1;\n      } else {\n        let accumulator$1 = $1[0];\n        return accumulator$1;\n      }\n    }\n  }\n}\n\n/**\n * Like `fold`, `fold_until` reduces an yielder of elements into a single value by calling a given\n * function on each element in turn, but uses `list.ContinueOrStop` to determine\n * whether or not to keep iterating.\n *\n * If called on an yielder of infinite length then this function will only ever\n * return if the function returns `list.Stop`.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/list\n *\n * let f = fn(acc, e) {\n *   case e {\n *     _ if e < 4 -> list.Continue(e + acc)\n *     _ -> list.Stop(acc)\n *   }\n * }\n *\n * from_list([1, 2, 3, 4])\n * |> fold_until(from: 0, with: f)\n * // -> 6\n * ```\n */\nexport function fold_until(yielder, initial, f) {\n  let _pipe = yielder.continuation;\n  return fold_until_loop(_pipe, f, initial);\n}\n\nfunction try_fold_loop(loop$continuation, loop$f, loop$accumulator) {\n  while (true) {\n    let continuation = loop$continuation;\n    let f = loop$f;\n    let accumulator = loop$accumulator;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return new Ok(accumulator);\n    } else {\n      let elem = $[0];\n      let next = $[1];\n      let $1 = f(accumulator, elem);\n      if ($1 instanceof Ok) {\n        let result = $1[0];\n        loop$continuation = next;\n        loop$f = f;\n        loop$accumulator = result;\n      } else {\n        return $1;\n      }\n    }\n  }\n}\n\n/**\n * A variant of fold that might fail.\n *\n * The folding function should return `Result(accumulator, error)`.\n * If the returned value is `Ok(accumulator)` try_fold will try the next value in the yielder.\n * If the returned value is `Error(error)` try_fold will stop and return that error.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4])\n * |> try_fold(0, fn(acc, i) {\n *   case i < 3 {\n *     True -> Ok(acc + i)\n *     False -> Error(Nil)\n *   }\n * })\n * // -> Error(Nil)\n * ```\n */\nexport function try_fold(yielder, initial, f) {\n  let _pipe = yielder.continuation;\n  return try_fold_loop(_pipe, f, initial);\n}\n\n/**\n * Returns the first element yielded by the given yielder, if it exists,\n * or `Error(Nil)` otherwise.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3]) |> first\n * // -> Ok(1)\n * ```\n *\n * ```gleam\n * empty() |> first\n * // -> Error(Nil)\n * ```\n */\nexport function first(yielder) {\n  let $ = yielder.continuation();\n  if ($ instanceof Stop) {\n    return new Error(undefined);\n  } else {\n    let e = $[0];\n    return new Ok(e);\n  }\n}\n\n/**\n * Returns nth element yielded by the given yielder, where `0` means the first element.\n *\n * If there are not enough elements in the yielder, `Error(Nil)` is returned.\n *\n * For any `index` less than `0` this function behaves as if it was set to `0`.\n *\n * ## Examples\n *\n * ```gleam\n * from_list([1, 2, 3, 4]) |> at(2)\n * // -> Ok(3)\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4]) |> at(4)\n * // -> Error(Nil)\n * ```\n *\n * ```gleam\n * empty() |> at(0)\n * // -> Error(Nil)\n * ```\n */\nexport function at(yielder, index) {\n  let _pipe = yielder;\n  let _pipe$1 = drop(_pipe, index);\n  return first(_pipe$1);\n}\n\nfunction length_loop(loop$continuation, loop$length) {\n  while (true) {\n    let continuation = loop$continuation;\n    let length = loop$length;\n    let $ = continuation();\n    if ($ instanceof Stop) {\n      return length;\n    } else {\n      let next = $[1];\n      loop$continuation = next;\n      loop$length = length + 1;\n    }\n  }\n}\n\n/**\n * Counts the number of elements in the given yielder.\n *\n * This function has to traverse the entire yielder to count its elements,\n * so it runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * empty() |> length\n * // -> 0\n * ```\n *\n * ```gleam\n * from_list([1, 2, 3, 4]) |> length\n * // -> 4\n * ```\n */\nexport function length(yielder) {\n  let _pipe = yielder.continuation;\n  return length_loop(_pipe, 0);\n}\n\n/**\n * Traverse an yielder, calling a function on each element.\n *\n * ## Examples\n *\n * ```gleam\n * empty() |> each(io.println)\n * // -> Nil\n * ```\n *\n * ```gleam\n * from_list([\"Tom\", \"Malory\", \"Louis\"]) |> each(io.println)\n * // -> Nil\n * // Tom\n * // Malory\n * // Louis\n * ```\n */\nexport function each(yielder, f) {\n  let _pipe = yielder;\n  let _pipe$1 = map(_pipe, f);\n  return run(_pipe$1);\n}\n\n/**\n * Add a new element to the start of an yielder.\n *\n * This function is for use with `use` expressions, to replicate the behaviour\n * of the `yield` keyword found in other languages.\n *\n * If you only need to prepend an element and don't require the `use` syntax,\n * use `prepend`.\n *\n * ## Examples\n *\n * ```gleam\n * let yielder = {\n *   use <- yield(1)\n *   use <- yield(2)\n *   use <- yield(3)\n *   empty()\n * }\n *\n * yielder |> to_list\n * // -> [1, 2, 3]\n * ```\n */\nexport function yield$(element, next) {\n  return new Yielder(\n    () => {\n      return new Continue(element, () => { return next().continuation(); });\n    },\n  );\n}\n\n/**\n * Add a new element to the start of an yielder.\n *\n * ## Examples\n *\n * ```gleam\n * let yielder = from_list([1, 2, 3]) |> prepend(0)\n *\n * yielder.to_list\n * // -> [0, 1, 2, 3]\n * ```\n */\nexport function prepend(yielder, element) {\n  return yield$(element, () => { return yielder; });\n}\n","export function sin(float) {\n    return Math.sin(float)\n}\n\nexport function pi() {\n    return Math.PI\n}\n\nexport function acos(float) {\n    return Math.acos(float)\n}\n\nexport function acosh(float) {\n    return Math.acosh(float)\n}\n\nexport function asin(float) {\n    return Math.asin(float)\n}\n\nexport function asinh(float) {\n    return Math.asinh(float)\n}\n\nexport function atan(float) {\n    return Math.atan(float)\n}\n\nexport function tan(float) {\n    return Math.tan(float)\n}\n\nexport function atan2(floaty, floatx) {\n    return Math.atan2(floaty, floatx)\n}\n\nexport function atanh(float) {\n    return Math.atanh(float)\n}\n\nexport function cos(float) {\n    return Math.cos(float)\n}\n\nexport function cosh(float) {\n    return Math.cosh(float)\n}\n\nexport function exponential(float) {\n    return Math.exp(float)\n}\n\nexport function ceiling(float) {\n    return Math.ceil(float)\n}\n\nexport function floor(float) {\n    return Math.floor(float)\n}\n\nexport function power(base, exponent) {\n    return Math.pow(base, exponent)\n}\n\nexport function logarithm(float) {\n    return Math.log(float)\n}\n\nexport function logarithm_10(float) {\n    return Math.log10(float)\n}\n\nexport function logarithm_2(float) {\n    return Math.log2(float)\n}\n\nexport function sinh(float) {\n    return Math.sinh(float)\n}\n\nexport function tanh(float) {\n    return Math.tanh(float)\n}\n\nexport function sign(float) {\n    return Math.sign(float)\n}\n\nexport function truncate(float) {\n    return Math.trunc(float)\n}\n\nexport function to_int(float) {\n    return Math.trunc(float)\n}\n","//# sourceMappingURL=maths.mjs.map\nimport * as $bool from \"../../gleam_stdlib/gleam/bool.mjs\";\nimport * as $float from \"../../gleam_stdlib/gleam/float.mjs\";\nimport * as $int from \"../../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../../gleam_stdlib/gleam/list.mjs\";\nimport * as $order from \"../../gleam_stdlib/gleam/order.mjs\";\nimport * as $set from \"../../gleam_stdlib/gleam/set.mjs\";\nimport * as $yielder from \"../../gleam_yielder/gleam/yielder.mjs\";\nimport { Done, Next } from \"../../gleam_yielder/gleam/yielder.mjs\";\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  makeError,\n  remainderInt,\n  divideFloat,\n  divideInt,\n} from \"../gleam.mjs\";\nimport {\n  acos as do_acos,\n  acosh as do_acosh,\n  asin as do_asin,\n  asinh as do_asinh,\n  atan as do_atan,\n  atan2 as do_atan2,\n  atanh as do_atanh,\n  cos as do_cos,\n  cosh as do_cosh,\n  sin as do_sin,\n  sinh as do_sinh,\n  tan as do_tan,\n  tanh as do_tanh,\n  exponential as do_exponential,\n  logarithm as do_natural_logarithm,\n  logarithm_2 as do_logarithm_2,\n  logarithm_10 as do_logarithm_10,\n  pi as do_pi,\n  truncate as do_truncate_float,\n  floor as do_floor,\n  ceiling as do_ceiling,\n  sign as do_sign,\n  sign as do_int_sign,\n} from \"../maths.mjs\";\n\nconst FILEPATH = \"src/gleam_community/maths.gleam\";\n\n/**\n * A constant used in the Lanczos approximation formula.\n * \n * @ignore\n */\nconst lanczos_g = 7.0;\n\n/**\n * Lanczos coefficients for the approximation formula. These coefficients are part of a\n * polynomial approximation to the Gamma function.\n * \n * @ignore\n */\nconst lanczos_p = /* @__PURE__ */ toList([\n  0.99999999999980993,\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  0.0000099843695780195716,\n  0.00000015056327351493116,\n]);\n\nfunction do_gcd(loop$x, loop$y) {\n  while (true) {\n    let x = loop$x;\n    let y = loop$y;\n    let $ = x === 0;\n    if ($) {\n      return y;\n    } else {\n      loop$x = remainderInt(y, x);\n      loop$y = x;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function calculates the greatest common divisor of two integers\n * \\\\(x, y \\in \\mathbb{Z}\\\\). The greatest common divisor is the largest positive\n * integer that is divisible by both \\\\(x\\\\) and \\\\(y\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.gcd(1, 1)\n *       |> should.equal(1)\n *\n *       maths.gcd(100, 10)\n *       |> should.equal(10)\n *\n *       maths.gcd(-36, -17)\n *       |> should.equal(1)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function gcd(x, y) {\n  let absx = $int.absolute_value(x);\n  let absy = $int.absolute_value(y);\n  return do_gcd(absx, absy);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n *\n * Given two integers, \\\\(x\\\\) (dividend) and \\\\(y\\\\) (divisor), the Euclidean modulo\n * of \\\\(x\\\\) by \\\\(y\\\\), denoted as \\\\(x \\mod y\\\\), is the remainder \\\\(r\\\\) of the\n * division of \\\\(x\\\\) by \\\\(y\\\\), such that:\n *\n * \\\\[\n * x = q \\cdot y + r \\quad \\text{and} \\quad 0 \\leq r < |y|,\n * \\\\]\n *\n * where \\\\(q\\\\) is an integer that represents the quotient of the division.\n *\n * Note that like the Gleam division operator `/` this will return `0` if one of\n * the arguments is `0`.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.euclidean_modulo(15, 4)\n *       |> should.equal(3)\n *\n *       maths.euclidean_modulo(-3, -2)\n *       |> should.equal(1)\n *\n *       maths.euclidean_modulo(5, 0)\n *       |> should.equal(0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function euclidean_modulo(x, y) {\n  let $ = remainderInt(x, y);\n  if (x === 0) {\n    return x;\n  } else if (y === 0) {\n    return y;\n  } else {\n    let md = $;\n    if (md < 0) {\n      return md + $int.absolute_value(y);\n    } else {\n      return $;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function calculates the least common multiple of two integers\n * \\\\(x, y \\in \\mathbb{Z}\\\\). The least common multiple is the smallest positive\n * integer that has both \\\\(x\\\\) and \\\\(y\\\\) as factors.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.lcm(1, 1)\n *       |> should.equal(1)\n *\n *       maths.lcm(100, 10)\n *       |> should.equal(100)\n *\n *       maths.lcm(-36, -17)\n *       |> should.equal(612)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function lcm(x, y) {\n  let absx = $int.absolute_value(x);\n  let absy = $int.absolute_value(y);\n  return divideInt(absx * absy, do_gcd(absx, absy));\n}\n\nfunction do_find_divisors(loop$n, loop$max, loop$acc, loop$i) {\n  while (true) {\n    let n = loop$n;\n    let max = loop$max;\n    let acc = loop$acc;\n    let i = loop$i;\n    let $ = i <= max;\n    if ($) {\n      let _block;\n      let $1 = (remainderInt(n, i)) === 0;\n      if ($1) {\n        let _pipe = $set.insert(acc, i);\n        _block = $set.insert(_pipe, divideInt(n, i));\n      } else {\n        _block = acc;\n      }\n      let updated_acc = _block;\n      loop$n = n;\n      loop$max = max;\n      loop$acc = updated_acc;\n      loop$i = i + 1;\n    } else {\n      return acc;\n    }\n  }\n}\n\nfunction find_divisors(n) {\n  let nabs = $float.absolute_value($int.to_float(n));\n  let $ = $float.square_root(nabs);\n  let sqrt_result;\n  if ($ instanceof Ok) {\n    sqrt_result = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      219,\n      \"find_divisors\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 6246,\n        end: 6298,\n        pattern_start: 6257,\n        pattern_end: 6272\n      }\n    )\n  }\n  let max = $float.round(sqrt_result) + 1;\n  return do_find_divisors(n, max, $set.new$(), 1);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns all the positive divisors of an integer, including the\n * number itself.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.divisors(4)\n *       |> should.equal([1, 2, 4])\n *\n *       maths.divisors(6)\n *       |> should.equal([1, 2, 3, 6])\n *\n *       maths.divisors(13)\n *       |> should.equal([1, 13])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function divisors(n) {\n  let _pipe = find_divisors(n);\n  let _pipe$1 = $set.to_list(_pipe);\n  return $list.sort(_pipe$1, $int.compare);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns all the positive divisors of an integer, excluding the\n * number itself.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.proper_divisors(4)\n *       |> should.equal([1, 2])\n *\n *       maths.proper_divisors(6)\n *       |> should.equal([1, 2, 3])\n *\n *       maths.proper_divisors(13)\n *       |> should.equal([1])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function proper_divisors(n) {\n  let _pipe = find_divisors(n);\n  let _pipe$1 = $set.delete$(_pipe, n);\n  let _pipe$2 = $set.to_list(_pipe$1);\n  return $list.sort(_pipe$2, $int.compare);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted sum of the elements in a list:\n *\n * \\\\[\n * \\sum_{i=1}^n w_i x_i\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the list and \\\\(x_i \\in \\mathbb{R}\\\\)\n * is the value in the input list indexed by \\\\(i\\\\), while the \\\\(w_i \\in \\mathbb{R}\\\\)\n * are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.weighted_sum()\n *       |> should.equal(Ok(0.0))\n *\n *       [#(1.0, 1.0), #(2.0, 1.0), #(3.0, 1.0)]\n *       |> maths.weighted_sum()\n *       |> should.equal(Ok(6.0))\n *\n *       [#(9.0, 0.5), #(10.0, 0.5), #(10.0, 0.5)]\n *       |> maths.weighted_sum()\n *       |> should.equal(Ok(14.5))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function weighted_sum(arr) {\n  if (arr instanceof $Empty) {\n    return new Ok(0.0);\n  } else {\n    return $list.try_fold(\n      arr,\n      0.0,\n      (acc, tuple) => {\n        let $ = tuple[1] < 0.0;\n        if ($) {\n          return new Error(undefined);\n        } else {\n          return new Ok((tuple[0] * tuple[1]) + acc);\n        }\n      },\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted product of the elements in a list:\n *\n * \\\\[\n * \\prod_{i=1}^n x_i^{w_i}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the list and \\\\(x_i \\in \\mathbb{R}\\\\) is\n * the value in the input list indexed by \\\\(i\\\\), while the \\\\(w_i \\in \\mathbb{R}\\\\)\n * are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.weighted_product()\n *       |> should.equal(Ok(1.0))\n *\n *       [#(1.0, 1.0), #(2.0, 1.0), #(3.0, 1.0)]\n *       |> maths.weighted_product()\n *       |> should.equal(Ok(6.0))\n *\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(result) =\n *         [#(9.0, 0.5), #(10.0, 0.5), #(10.0, 0.5)]\n *         |> maths.weighted_product()\n *       result\n *       |> maths.is_close(30.0, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function weighted_product(arr) {\n  if (arr instanceof $Empty) {\n    return new Ok(1.0);\n  } else {\n    return $list.try_fold(\n      arr,\n      1.0,\n      (acc, tuple) => {\n        let $ = tuple[1] < 0.0;\n        if ($) {\n          return new Error(undefined);\n        } else {\n          let $1 = $float.power(tuple[0], tuple[1]);\n          if ($1 instanceof Ok) {\n            let value = $1[0];\n            return new Ok(value * acc);\n          } else {\n            return $1;\n          }\n        }\n      },\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the cumulative sum of the elements in a list:\n *\n * \\\\[\n * v_j = \\sum_{i=1}^j x_i \\\\;\\\\; \\forall j = 1,\\dots, n\n * \\\\]\n *\n * In the formula, \\\\(v_j\\\\) is the \\\\(j\\\\)'th element in the cumulative sum of \\\\(n\\\\)\n * elements. That is, \\\\(n\\\\) is the length of the list and \\\\(x_i \\in \\mathbb{R}\\\\)\n * is the value in the input list indexed by \\\\(i\\\\). The value \\\\(v_j\\\\) is thus the\n * sum of the \\\\(1\\\\) to \\\\(j\\\\) first elements in the given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.cumulative_sum()\n *       |> should.equal([])\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.cumulative_sum()\n *       |> should.equal([1.0, 3.0, 6.0])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cumulative_sum(arr) {\n  if (arr instanceof $Empty) {\n    return arr;\n  } else {\n    return $list.scan(arr, 0.0, (acc, element) => { return element + acc; });\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the cumulative sum of the elements in a list:\n *\n * \\\\[\n * v_j = \\sum_{i=1}^j x_i \\\\;\\\\; \\forall j = 1,\\dots, n\n * \\\\]\n *\n * In the formula, \\\\(v_j\\\\) is the \\\\(j\\\\)'th element in the cumulative sum of \\\\(n\\\\)\n * elements. That is, \\\\(n\\\\) is the length of the list and \\\\(x_i \\in \\mathbb{Z}\\\\)\n * is the value in the input list indexed by \\\\(i\\\\). The value \\\\(v_j\\\\) is thus the\n * sum of the \\\\(1\\\\) to \\\\(j\\\\) first elements in the given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.int_cumulative_sum()\n *       |> should.equal([])\n *\n *       [1, 2, 3]\n *       |> maths.int_cumulative_sum()\n *       |> should.equal([1, 3, 6])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_cumulative_sum(arr) {\n  if (arr instanceof $Empty) {\n    return arr;\n  } else {\n    return $list.scan(arr, 0, (acc, element) => { return element + acc; });\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the cumulative product of the elements in a list:\n *\n * \\\\[\n * v_j = \\prod_{i=1}^j x_i \\\\;\\\\; \\forall j = 1,\\dots, n\n * \\\\]\n *\n * In the formula, \\\\(v_j\\\\) is the \\\\(j\\\\)'th element in the cumulative product\n * of \\\\(n\\\\) elements. That is, \\\\(n\\\\) is the length of the list and\n * \\\\(x_i \\in \\mathbb{R}\\\\) is the value in the input list indexed by \\\\(i\\\\).\n * The value \\\\(v_j\\\\) is thus the sum of the \\\\(1\\\\) to \\\\(j\\\\) first elements\n * in the given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.cumulative_product()\n *       |> should.equal([])\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.cumulative_product()\n *       |> should.equal([1.0, 2.0, 6.0])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cumulative_product(arr) {\n  if (arr instanceof $Empty) {\n    return arr;\n  } else {\n    return $list.scan(arr, 1.0, (acc, element) => { return element * acc; });\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the cumulative product of the elements in a list:\n *\n * \\\\[\n * v_j = \\prod_{i=1}^j x_i \\\\;\\\\; \\forall j = 1,\\dots, n\n * \\\\]\n *\n * In the formula, \\\\(v_j\\\\) is the \\\\(j\\\\)'th element in the cumulative product\n * of \\\\(n\\\\) elements. That is, \\\\(n\\\\) is the length of the list and\n * \\\\(x_i \\in \\mathbb{Z}\\\\) is the value in the input list indexed by \\\\(i\\\\).\n * The value \\\\(v_j\\\\) is thus the product of the \\\\(1\\\\) to \\\\(j\\\\) first elements\n * in the given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.int_cumulative_product()\n *       |> should.equal([])\n *\n *       [1, 2, 3]\n *       |> maths.int_cumulative_product()\n *       |> should.equal([1, 2, 6])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_cumulative_product(arr) {\n  if (arr instanceof $Empty) {\n    return arr;\n  } else {\n    return $list.scan(arr, 1, (acc, element) => { return element * acc; });\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse cosine function:\n *\n * \\\\[\n * \\forall x \\in \\[-1, 1\\],   \\\\; \\cos^{-1}{(x)} = y \\in \\[0, \\pi \\]\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\[-1, 1\\]\\\\) as input and\n * returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[0, \\pi \\]\\\\) (an\n * angle in radians). If the input value is outside the domain of the function\n * an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.acos(1.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.acos(1.1)\n *       |> should.be_error()\n *\n *       maths.acos(-1.1)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function acos(x) {\n  let $ = (x >= -1.0) && (x <= 1.0);\n  if ($) {\n    return new Ok(do_acos(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse hyperbolic cosine function:\n *\n * \\\\[\n * \\forall x \\in [1, +\\infty\\),   \\\\; \\cosh^{-1}{(x)} = y \\in \\[0, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\[1, +\\infty\\)\\\\) as input\n * and returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[0, +\\infty\\)\\\\)\n * (an angle in radians). If the input value is outside the domain of the function\n * an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.acosh(1.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.acosh(0.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function acosh(x) {\n  let $ = x >= 1.0;\n  if ($) {\n    return new Ok(do_acosh(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse sine function:\n *\n * \\\\[\n * \\forall x \\in \\[-1, 1\\],   \\\\; \\sin^{-1}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\[-1, 1\\]\\\\) as input and returns a numeric\n * value \\\\(y\\\\) that lies in the range \\\\(\\[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\]\\\\) (an angle in\n * radians). If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.asin(0.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.asin(1.1)\n *       |> should.be_error()\n *\n *       maths.asin(-1.1)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function asin(x) {\n  let $ = (x >= -1.0) && (x <= 1.0);\n  if ($) {\n    return new Ok(do_asin(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse hyperbolic sine function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, \\infty\\),   \\\\; \\sinh^{-1}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, +\\infty\\)\\\\)\n * as input and returns a numeric value \\\\(y\\\\) that lies in the range\n * \\\\(\\(-\\infty, +\\infty\\)\\\\) (an angle in radians).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.asinh(0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function asinh(x) {\n  return do_asinh(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse tangent function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, \\infty\\),  \\\\; \\tan^{-1}{(x)} = y \\in \\[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\]\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, +\\infty\\)\\\\) as input and\n * returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\]\\\\)\n * (an angle in radians).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.atan(0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function atan(x) {\n  return do_atan(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse 2-argument tangent function:\n *\n * \\\\[\n * \\text{atan2}(y, x) =\n * \\begin{cases}\n *  \\tan^{-1}(\\frac y x) &\\text{if } x > 0, \\\\\\\\\n *  \\tan^{-1}(\\frac y x) + \\pi &\\text{if } x < 0 \\text{ and } y \\ge 0, \\\\\\\\\n *  \\tan^{-1}(\\frac y x) - \\pi &\\text{if } x < 0 \\text{ and } y < 0, \\\\\\\\\n *  +\\frac{\\pi}{2} &\\text{if } x = 0 \\text{ and } y > 0, \\\\\\\\\n *  -\\frac{\\pi}{2} &\\text{if } x = 0 \\text{ and } y < 0, \\\\\\\\\n *  \\text{undefined} &\\text{if } x = 0 \\text{ and } y = 0.\n * \\end{cases}\n * \\\\]\n *\n * The function returns the angle in radians from the x-axis to the line containing\n * the origin \\\\(\\(0, 0\\)\\\\) and a point given as input with coordinates \\\\(\\(x, y\\)\\\\).\n * The numeric value returned by \\\\(\\text{atan2}(y, x)\\\\) is in the range\n * \\\\(\\[-\\pi, \\pi\\]\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.atan2(0.0, 0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function atan2(y, x) {\n  return do_atan2(y, x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Converts Cartesian coordinates \\\\((x, y)\\\\) to polar coordinates \\\\((r, \\theta)\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.cartesian_to_polar(1.0, 0.0)\n *       |> should.equal((1.0, 0.0))\n *\n *       maths.cartesian_to_polar(0.0, 1.0)\n *       |> should.equal((1.0, float.pi() /. 2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cartesian_to_polar(x, y) {\n  let $ = $float.square_root((x * x) + (y * y));\n  let r;\n  if ($ instanceof Ok) {\n    r = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      729,\n      \"cartesian_to_polar\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 19885,\n        end: 19939,\n        pattern_start: 19896,\n        pattern_end: 19901\n      }\n    )\n  }\n  let theta = atan2(y, x);\n  return [r, theta];\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The inverse hyperbolic tangent function:\n *\n * \\\\[\n * \\forall x \\in \\(-1, 1\\),   \\\\; \\tanh^{-1}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-1, 1\\)\\\\) as input and returns\n * a numeric value \\\\(y\\\\) that lies in the range \\\\(\\(-\\infty, \\infty\\)\\\\) (an angle in radians).\n * If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.atanh(0.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.atanh(1.0)\n *       |> should.be_error()\n *\n *       maths.atanh(-1.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function atanh(x) {\n  let $ = (x > -1.0) && (x < 1.0);\n  if ($) {\n    return new Ok(do_atanh(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The cosine function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, +\\infty\\),   \\\\; \\cos{(x)} = y \\in \\[-1, 1\\]\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, \\infty\\)\\\\) (an angle in\n * radians) as input and returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[-1, 1\\]\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.cos(0.0)\n *       |> should.equal(1.0)\n *\n *       maths.cos(maths.pi())\n *       |> should.equal(-1.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cos(x) {\n  return do_cos(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The hyperbolic cosine function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, \\infty\\),   \\\\; \\cosh{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, \\infty\\)\\\\) as input (an angle\n * in radians) and returns a numeric value \\\\(y\\\\) that lies in the range\n * \\\\(\\(-\\infty, \\infty\\)\\\\). If the input value is too large an overflow error might occur.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.cosh(0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cosh(x) {\n  return do_cosh(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The sine function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, +\\infty\\),   \\\\; \\sin{(x)} = y \\in \\[-1, 1\\]\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, \\infty\\)\\\\) (an angle in\n * radians) as input and returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[-1, 1\\]\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.sin(0.0)\n *       |> should.equal(0.0)\n *\n *       maths.sin(0.5 *. maths.pi())\n *       |> should.equal(1.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function sin(x) {\n  return do_sin(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Converts polar coordinates \\\\((r, \\theta)\\\\) to Cartesian coordinates \\\\((x, y)\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.polar_to_cartesian(1.0, 0.0)\n *       |> should.equal(#(1.0, 0.0))\n *\n *       maths.polar_to_cartesian(1.0, float.pi() /. 2.0)\n *       |> should.equal(#(0.0, 1.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function polar_to_cartesian(r, theta) {\n  let x = r * cos(theta);\n  let y = r * sin(theta);\n  return [x, y];\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The hyperbolic sine function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, +\\infty\\),   \\\\; \\sinh{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, +\\infty\\)\\\\) as input\n * (an angle in radians) and returns a numeric value \\\\(y\\\\) that lies in the range\n * \\\\(\\(-\\infty, +\\infty\\)\\\\). If the input value is too large an overflow error might occur.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.sinh(0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function sinh(x) {\n  return do_sinh(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The tangent function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, +\\infty\\),   \\\\; \\tan{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, +\\infty\\)\\\\) as input\n * (an angle in radians) and returns a numeric value \\\\(y\\\\) that lies in the range\n * \\\\(\\(-\\infty, +\\infty\\)\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.tan(0.0)\n *       |> should.equal(0.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function tan(x) {\n  return do_tan(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The hyperbolic tangent function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, \\infty\\),   \\\\; \\tanh{(x)} = y \\in \\[-1, 1\\]\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(-\\infty, \\infty\\)\\\\) as input (an angle\n * in radians) and returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\[-1, 1\\]\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.tanh(0.0)\n *       |> should.equal(0.0)\n *\n *       maths.tanh(25.0)\n *       |> should.equal(1.0)\n *\n *       maths.tanh(-25.0)\n *       |> should.equal(-1.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function tanh(x) {\n  return do_tanh(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The exponential function:\n *\n * \\\\[\n * \\forall x \\in \\(-\\infty, \\infty\\),   \\\\; e^{x} = y \\in \\(0, +\\infty\\)\n * \\\\]\n *\n * where \\\\(e \\approx 2.71828\\dots\\\\) is Eulers' number.\n *\n * Note: If the input value \\\\(x\\\\) is too large an overflow error might occur.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.exponential(0.0)\n *       |> should.equal(1.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function exponential(x) {\n  return do_exponential(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The natural logarithm function:\n *\n * \\\\[\n * \\forall x \\in \\(0, \\infty\\),   \\\\; \\log_{e}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(0, \\infty\\)\\\\) as input and returns\n * a numeric value \\\\(y\\\\) that lies in the range \\\\(\\(-\\infty, \\infty\\)\\\\).\n * If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.natural_logarithm(1.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.natural_logarithm(maths.e())\n *       |> should.equal(Ok(1.0))\n *\n *       maths.natural_logarithm(-1.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function natural_logarithm(x) {\n  let $ = x > 0.0;\n  if ($) {\n    return new Ok(do_natural_logarithm(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The base-2 logarithm function:\n *\n * \\\\[\n * \\forall x \\in \\(0, \\infty),   \\\\; \\log_{2}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(0, \\infty\\)\\\\) as input and returns a\n * numeric value \\\\(y\\\\) that lies in the range \\\\(\\(-\\infty, \\infty\\)\\\\).\n * If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.logarithm_2(1.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.logarithm_2(2.0)\n *       |> should.equal(Ok(1.0))\n *\n *       maths.logarithm_2(-1.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function logarithm_2(x) {\n  let $ = x > 0.0;\n  if ($) {\n    return new Ok(do_logarithm_2(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The base-10 logarithm function:\n *\n * \\\\[\n * \\forall x \\in \\(0, \\infty),   \\\\; \\log_{10}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(0, \\infty\\)\\\\) as input and returns a\n * numeric value \\\\(y\\\\) that lies in the range \\\\(\\(-\\infty, \\infty\\)\\\\).\n * If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.logarithm_10(1.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.logarithm_10(10.0)\n *       |> should.equal(Ok(1.0))\n *\n *       maths.logarithm_10(-1.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function logarithm_10(x) {\n  let $ = x > 0.0;\n  if ($) {\n    return new Ok(do_logarithm_10(x));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The base \\\\(b\\\\) logarithm function (computed through the \"change of base\" formula):\n *\n * \\\\[\n * \\forall x \\in \\(0, \\infty\\) \\textnormal{ and } b > 1,  \\\\; \\log_{b}{(x)} = y \\in \\(-\\infty, +\\infty\\)\n * \\\\]\n *\n * The function takes a number \\\\(x\\\\) in its domain \\\\(\\(0, \\infty\\)\\\\) and a base \\\\(b > 1\\\\)\n * as input and returns a numeric value \\\\(y\\\\) that lies in the range \\\\(\\(-\\infty, \\infty\\)\\\\).\n * If the input value is outside the domain of the function an error is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.logarithm(1.0, 10.0)\n *       |> should.equal(Ok(0.0))\n *\n *       maths.logarithm(maths.e(), maths.e())\n *       |> should.equal(Ok(1.0))\n *\n *       maths.logarithm(-1.0, 2.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function logarithm(x, base) {\n  let $ = ((x > 0.0) && (base > 0.0)) && (base !== 1.0);\n  if ($) {\n    let $1 = logarithm_10(x);\n    let numerator;\n    if ($1 instanceof Ok) {\n      numerator = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        1475,\n        \"logarithm\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 39708,\n          end: 39750,\n          pattern_start: 39719,\n          pattern_end: 39732\n        }\n      )\n    }\n    let $2 = logarithm_10(base);\n    let denominator;\n    if ($2 instanceof Ok) {\n      denominator = $2[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        1476,\n        \"logarithm\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $2,\n          start: 39757,\n          end: 39804,\n          pattern_start: 39768,\n          pattern_end: 39783\n        }\n      )\n    }\n    return new Ok(divideFloat(numerator, denominator));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The \\\\(n\\\\)'th root function: \\\\(y = \\sqrt[n]{x} = x^{\\frac{1}{n}}\\\\).\n *\n * Note that the function is not defined if the input is negative (\\\\(x < 0\\\\)). An error will be\n * returned as an imaginary number will otherwise have to be returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.nth_root(-1.0, 2)\n *       |> should.be_error()\n *\n *       maths.nth_root(1.0, 2)\n *       |> should.equal(Ok(1.0))\n *\n *       maths.nth_root(27.0, 3)\n *       |> should.equal(Ok(3.0))\n *\n *       maths.nth_root(256.0, 4)\n *       |> should.equal(Ok(4.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function nth_root(x, n) {\n  let $ = (x >= 0.0) && (n >= 1);\n  if ($) {\n    return $float.power(x, divideFloat(1.0, $int.to_float(n)));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Convert a value in degrees to a value measured in radians.\n * That is, \\\\(1 \\text{ degrees } = \\frac{\\pi}{180} \\text{ radians }\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.degrees_to_radians(360.)\n *       |> should.equal(2. *. maths.pi())\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function degrees_to_radians(x) {\n  return ((x * do_pi())) / 180.0;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Convert a value in degrees to a value measured in radians.\n * That is, \\\\(1 \\text{ radians } = \\frac{180}{\\pi} \\text{ degrees }\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.radians_to_degrees(0.0)\n *       |> should.equal(0.0)\n *\n *       maths.radians_to_degrees(2. *. maths.pi())\n *       |> should.equal(360.)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function radians_to_degrees(x) {\n  return divideFloat((x * 180.0), do_pi());\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The mathematical constant pi: \\\\(\\pi \\approx 3.1415\\dots\\\\)\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function pi() {\n  return do_pi();\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The mathematical (circle) constant tau: \\\\(\\tau = 2 \\cdot \\pi \\approx 6.283\\dots\\\\)\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function tau() {\n  return 2.0 * pi();\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The golden ratio: \\\\(\\phi = \\frac{1 + \\sqrt{5}}{2}\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.golden_ratio()\n *       |> should.equal(1.618033988749895)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function golden_ratio() {\n  let $ = $float.square_root(5.0);\n  let sqrt5;\n  if ($ instanceof Ok) {\n    sqrt5 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      1705,\n      \"golden_ratio\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 45847,\n        end: 45892,\n        pattern_start: 45858,\n        pattern_end: 45867\n      }\n    )\n  }\n  return (1.0 + sqrt5) / 2.0;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Euler's number \\\\(e \\approx 2.71828\\dots\\\\).\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       // Test that the constant is approximately equal to 2.7128...\n *       maths.e()\n *       |> maths.is_close(2.7182818284590452353602, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function e() {\n  return exponential(1.0);\n}\n\nfunction truncate_float(x) {\n  return do_truncate_float(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) that is less than or equal to the absolute value of the input \\\\(x\\\\). This\n * rounding behaviour is similar to behaviour of the Gleam stdlib `truncate` function.\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(12.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.0\\\\) for 1 digit after the decimal point (`digits = 1`)\n *   - \\\\(12.06\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.065\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *   number refers to the digits before the decimal point.\n *   - \\\\(10.0\\\\) for 1 digit before the decimal point (`digits = -1`)\n *   - \\\\(0.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(0.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_to_zero(12.0654, 2)\n *       |> should.equal(12.06)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_to_zero(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      1984,\n      \"round_to_zero\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 56003,\n        end: 56056,\n        pattern_start: 56014,\n        pattern_end: 56019\n      }\n    )\n  }\n  return divideFloat(truncate_float(x * p$1), p$1);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) that is less than or equal to the input \\\\(x\\\\). This rounding behaviour is\n * similar to behaviour of the Gleam stdlib `floor` function.\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(12.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.0\\\\) for 1 digits after the decimal point (`digits = 1`)\n *   - \\\\(12.06\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.065\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *   number refers to the digits before the decimal point.\n *   - \\\\(10.0\\\\) for 1 digit before the decimal point (`digits = -1`)\n *   - \\\\(0.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(0.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_down(12.0654, 2)\n *       |> should.equal(12.06)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_down(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      2047,\n      \"round_down\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 58313,\n        end: 58366,\n        pattern_start: 58324,\n        pattern_end: 58329\n      }\n    )\n  }\n  return divideFloat(do_floor(x * p$1), p$1);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) that is larger than or equal to the input \\\\(x\\\\). This rounding behaviour is\n * similar to behaviour of the Gleam stdlib `ceiling` function.\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(13.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.1\\\\) for 1 digit after the decimal point (`digits = 1`)\n *   - \\\\(12.07\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.066\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *   number refers to the digits before the decimal point.\n *   - \\\\(20.0\\\\) for 1 digit places before the decimal point (`digit = -1`)\n *   - \\\\(100.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(1000.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_up(12.0654, 2)\n *       |> should.equal(12.07)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_up(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      2106,\n      \"round_up\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 60548,\n        end: 60601,\n        pattern_start: 60559,\n        pattern_end: 60564\n      }\n    )\n  }\n  return divideFloat(do_ceiling(x * p$1), p$1);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The absolute difference:\n *\n * \\\\[\n *  \\forall x, y \\in \\mathbb{R}, \\\\; |x - y|  \\in \\mathbb{R}_{+}.\n * \\\\]\n *\n * The function takes two inputs \\\\(x\\\\) and \\\\(y\\\\) and returns a positive float\n * value which is the absolute difference of the inputs.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.absolute_difference(-10.0, 10.0)\n *       |> should.equal(20.0)\n *\n *       maths.absolute_difference(0.0, -2.0)\n *       |> should.equal(2.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function absolute_difference(a, b) {\n  return $float.absolute_value(a - b);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The absolute difference:\n *\n * \\\\[\n *  \\forall x, y \\in \\mathbb{Z}, \\\\; |x - y|  \\in \\mathbb{Z}_{+}.\n * \\\\]\n *\n * The function takes two inputs \\\\(x\\\\) and \\\\(y\\\\) and returns a positive integer\n * value which is the absolute difference of the inputs.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.absolute_difference(-10, 10)\n *       |> should.equal(20)\n *\n *       maths.absolute_difference(0, -2)\n *       |> should.equal(2)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_absolute_difference(a, b) {\n  return $int.absolute_value(a - b);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function takes an input \\\\(x \\in \\mathbb{R}\\\\) and returns the sign of\n * the input, indicating whether it is positive (+1.0), negative (-1.0), or\n * zero (0.0).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function sign(x) {\n  return do_sign(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) with ties (fractional values of 0.5) being rounded to the nearest even\n * integer.\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(12.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.1\\\\) for 1 digit after the decimal point (`digits = 1`)\n *   - \\\\(12.07\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.065\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *   number refers to the digits before the decimal point.\n *   - \\\\(10.0\\\\) for 1 digit before the decimal point (`digits = -1`)\n *   - \\\\(0.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(0.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_to_nearest(12.0654, 2)\n *       |> should.equal(12.07)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_to_nearest(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      1794,\n      \"round_to_nearest\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 48759,\n        end: 48812,\n        pattern_start: 48770,\n        pattern_end: 48775\n      }\n    )\n  }\n  let xabs = $float.absolute_value(x) * p$1;\n  let xabs_truncated = truncate_float(xabs);\n  let remainder = xabs - xabs_truncated;\n  if (remainder > 0.5) {\n    return divideFloat((sign(x) * truncate_float(xabs + 1.0)), p$1);\n  } else if (remainder === 0.5) {\n    let is_even = $float.truncate(xabs) % 2;\n    let $1 = is_even === 0;\n    if ($1) {\n      return divideFloat((sign(x) * xabs_truncated), p$1);\n    } else {\n      return divideFloat((sign(x) * truncate_float(xabs + 1.0)), p$1);\n    }\n  } else {\n    return divideFloat((sign(x) * xabs_truncated), p$1);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) with ties (fractional values of 0.5) being rounded away from zero (C/C++\n * rounding behaviour).\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(12.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.1\\\\) for 1 digit after the decimal point (`digits = 1`)\n *   - \\\\(12.07\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.065\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *   number refers to the digits before the decimal point.\n *   - \\\\(10.0\\\\) for 1 digit before the decimal point (`digits = -1`)\n *   - \\\\(0.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(0.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_ties_away(12.0654, 2)\n *       |> should.equal(12.07)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_ties_away(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      1862,\n      \"round_ties_away\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 51301,\n        end: 51354,\n        pattern_start: 51312,\n        pattern_end: 51317\n      }\n    )\n  }\n  let xabs = $float.absolute_value(x) * p$1;\n  let remainder = xabs - truncate_float(xabs);\n  if (remainder >= 0.5) {\n    return divideFloat((sign(x) * truncate_float(xabs + 1.0)), p$1);\n  } else {\n    return divideFloat((sign(x) * truncate_float(xabs)), p$1);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function rounds a float to a specific number of digits (after the decimal place or before\n * if negative). In particular, the input \\\\(x\\\\) is rounded to the nearest integer value (at the\n * specified digit) with ties (fractional values of 0.5) being rounded towards \\\\(+\\infty\\\\)\n * (Java/JavaScript rounding behaviour).\n *\n * <details>\n * <summary>Details</summary>\n *\n *   The rounding mode rounds \\\\(12.0654\\\\) to:\n *   - \\\\(12.0\\\\) for 0 digits after the decimal point (`digits = 0`)\n *   - \\\\(12.1\\\\) for 1 digits after the decimal point (`digits = 1`)\n *   - \\\\(12.07\\\\) for 2 digits after the decimal point (`digits = 2`)\n *   - \\\\(12.065\\\\) for 3 digits after the decimal point (`digits = 3`)\n *\n *   It is also possible to specify a negative number of digits. In that case, the negative\n *    number refers to the digits before the decimal point.\n *   - \\\\(10.0\\\\) for 1 digit before the decimal point (`digits = -1`)\n *   - \\\\(0.0\\\\) for 2 digits before the decimal point (`digits = -2`)\n *   - \\\\(0.0\\\\) for 3 digits before the decimal point (`digits = -3`)\n *\n * </details>\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.round_ties_up(12.0654, 2)\n *       |> should.equal(12.07)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function round_ties_up(x, p) {\n  let $ = $float.power(10.0, $int.to_float(p));\n  let p$1;\n  if ($ instanceof Ok) {\n    p$1 = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      1922,\n      \"round_ties_up\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 53603,\n        end: 53656,\n        pattern_start: 53614,\n        pattern_end: 53619\n      }\n    )\n  }\n  let xabs = $float.absolute_value(x) * p$1;\n  let xabs_truncated = truncate_float(xabs);\n  let remainder = xabs - xabs_truncated;\n  if ((remainder >= 0.5) && (x >= 0.0)) {\n    return divideFloat((sign(x) * truncate_float(xabs + 1.0)), p$1);\n  } else {\n    return divideFloat((sign(x) * xabs_truncated), p$1);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function takes an input \\\\(x \\in \\mathbb{Z}\\\\) and returns the sign of\n * the input, indicating whether it is positive (+1), negative (-1), or zero\n * (0).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_sign(x) {\n  return do_int_sign(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function flips the sign of a given input value \\\\(x \\in \\mathbb{R}\\\\).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function flip_sign(x) {\n  return -1.0 * x;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function takes two arguments \\\\(x, y \\in \\mathbb{R}\\\\) and returns \\\\(x\\\\)\n * such that it has the same sign as \\\\(y\\\\).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function copy_sign(x, y) {\n  let $ = sign(x) === sign(y);\n  if ($) {\n    return x;\n  } else {\n    return flip_sign(x);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function flips the sign of a given input value \\\\(x \\in \\mathbb{Z}\\\\).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_flip_sign(x) {\n  return -1 * x;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function takes two arguments \\\\(x, y \\in \\mathbb{Z}\\\\) and returns \\\\(x\\\\)\n * such that it has the same sign as \\\\(y\\\\).\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function int_copy_sign(x, y) {\n  let $ = int_sign(x) === int_sign(y);\n  if ($) {\n    return x;\n  } else {\n    return int_flip_sign(x);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The minmax function takes two arguments \\\\(x, y\\\\) along with a function\n * for comparing \\\\(x, y\\\\). The function returns a tuple with the smallest\n * value first and largest second.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleam/float\n *     import gleam/int\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.minmax(2.0, 1.5, float.compare)\n *       |> should.equal(#(1.5, 2.0))\n *\n *       maths.minmax(1, 2, int.compare)\n *       |> should.equal(#(1, 2))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function minmax(x, y, compare) {\n  let $ = compare(x, y);\n  if ($ instanceof $order.Lt) {\n    return [x, y];\n  } else if ($ instanceof $order.Eq) {\n    return [x, y];\n  } else {\n    return [y, x];\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Returns the minimum value of a given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/int\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.list_minimum(int.compare)\n *       |> should.be_error()\n *\n *       [4, 4, 3, 2, 1]\n *       |> maths.list_minimum(int.compare)\n *       |> should.equal(Ok(1))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_minimum(arr, compare) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let x = arr.head;\n    let rest = arr.tail;\n    return new Ok(\n      $list.fold(\n        rest,\n        x,\n        (acc, element) => {\n          let $ = compare(element, acc);\n          if ($ instanceof $order.Lt) {\n            return element;\n          } else {\n            return acc;\n          }\n        },\n      ),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Returns the maximum value of a given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.list_maximum(float.compare)\n *       |> should.be_error()\n *\n *       [4.0, 4.0, 3.0, 2.0, 1.0]\n *       |> maths.list_maximum(float.compare)\n *       |> should.equal(Ok(4.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_maximum(arr, compare) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let x = arr.head;\n    let rest = arr.tail;\n    return new Ok(\n      $list.fold(\n        rest,\n        x,\n        (acc, element) => {\n          let $ = compare(acc, element);\n          if ($ instanceof $order.Lt) {\n            return element;\n          } else {\n            return acc;\n          }\n        },\n      ),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Returns the indices of the minimum values in a given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.arg_minimum(float.compare)\n *       |> should.be_error()\n *\n *       [4.0, 4.0, 3.0, 2.0, 1.0]\n *       |> maths.arg_minimum(float.compare)\n *       |> should.equal(Ok([4]))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function arg_minimum(arr, compare) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let $ = list_minimum(arr, compare);\n    let min;\n    if ($ instanceof Ok) {\n      min = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        2526,\n        \"arg_minimum\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 71111,\n          end: 71158,\n          pattern_start: 71122,\n          pattern_end: 71129\n        }\n      )\n    }\n    return new Ok(\n      (() => {\n        let _pipe = $list.index_map(\n          arr,\n          (element, index) => {\n            let $1 = compare(element, min);\n            if ($1 instanceof $order.Eq) {\n              return index;\n            } else {\n              return -1;\n            }\n          },\n        );\n        return $list.filter(\n          _pipe,\n          (index) => {\n            if (index === -1) {\n              return false;\n            } else {\n              return true;\n            }\n          },\n        );\n      })(),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Returns the indices of the maximum values in a given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.arg_maximum(float.compare)\n *       |> should.be_error()\n *\n *       [4.0, 4.0, 3.0, 2.0, 1.0]\n *       |> maths.arg_maximum(float.compare)\n *       |> should.equal(Ok([0, 1]))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function arg_maximum(arr, compare) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let $ = list_maximum(arr, compare);\n    let max;\n    if ($ instanceof Ok) {\n      max = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        2591,\n        \"arg_maximum\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 72657,\n          end: 72704,\n          pattern_start: 72668,\n          pattern_end: 72675\n        }\n      )\n    }\n    return new Ok(\n      (() => {\n        let _pipe = $list.index_map(\n          arr,\n          (element, index) => {\n            let $1 = compare(element, max);\n            if ($1 instanceof $order.Eq) {\n              return index;\n            } else {\n              return -1;\n            }\n          },\n        );\n        return $list.filter(\n          _pipe,\n          (index) => {\n            if (index === -1) {\n              return false;\n            } else {\n              return true;\n            }\n          },\n        );\n      })(),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Returns a tuple consisting of the minimum and maximum values of a given list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/float\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.extrema(float.compare)\n *       |> should.be_error()\n *\n *       [4.0, 4.0, 3.0, 2.0, 1.0]\n *       |> maths.extrema(float.compare)\n *       |> should.equal(Ok(#(1.0, 4.0)))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function extrema(arr, compare) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let x = arr.head;\n    let rest = arr.tail;\n    return new Ok(\n      $list.fold(\n        rest,\n        [x, x],\n        (acc, element) => {\n          let first = acc[0];\n          let second = acc[1];\n          let $ = compare(element, first);\n          let $1 = compare(second, element);\n          if ($ instanceof $order.Lt) {\n            if ($1 instanceof $order.Lt) {\n              return [element, element];\n            } else {\n              return [element, second];\n            }\n          } else if ($1 instanceof $order.Lt) {\n            return [first, element];\n          } else {\n            return [first, second];\n          }\n        },\n      ),\n    );\n  }\n}\n\nfunction do_combination(loop$n, loop$k, loop$acc, loop$element) {\n  while (true) {\n    let n = loop$n;\n    let k = loop$k;\n    let acc = loop$acc;\n    let element = loop$element;\n    let $ = element > k;\n    if ($) {\n      return acc;\n    } else {\n      loop$n = n;\n      loop$k = k;\n      loop$acc = divideInt(acc * ((n + 1) - element), element);\n      loop$element = element + 1;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A combinatorial function for computing the number of \\\\(k\\\\)-combinations of \\\\(n\\\\) elements\n * without repetitions:\n *\n * \\\\[\n * C(n, k) = \\binom{n}{k} = \\frac{n!}{k! (n-k)!}\n * \\\\]\n *\n * Also known as \"\\\\(n\\\\) choose \\\\(k\\\\)\" or the binomial coefficient.\n *\n *\n * <details>\n * <summary>Details</summary>\n *\n * A \\\\(k\\\\)-combination without repetition is a sequence of \\\\(k\\\\) elements selected from\n * \\\\(n\\\\) elements where the order of selection does not matter and elements are not allowed to\n * repeat. For example, consider selecting  2 elements from a list of 3 elements:\n * `[\"A\", \"B\", \"C\"]`. In this case, possible selections are:\n *   - `[\"A\", \"B\"]`\n *   - `[\"A\", \"C\"]`\n *   - `[\"B\", \"C\"]`\n *\n * </details>\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.combination(-1, 1)\n *       |> should.be_error()\n *\n *       maths.combination(4, 0)\n *       |> should.equal(Ok(1))\n *\n *       maths.combination(4, 4)\n *       |> should.equal(Ok(1))\n *\n *       maths.combination(13, 5)\n *       |> should.equal(Ok(1287))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function combination(n, k) {\n  if (n < 0) {\n    return new Error(undefined);\n  } else if (k < 0) {\n    return new Error(undefined);\n  } else if (k > n) {\n    return new Ok(0);\n  } else if ((k === 0) || (k === n)) {\n    return new Ok(1);\n  } else {\n    let _block;\n    let $ = k < (n - k);\n    if ($) {\n      _block = k;\n    } else {\n      _block = n - k;\n    }\n    let min = _block;\n    return new Ok(do_combination(n, min, 1, 1));\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A combinatorial function for computing the number of \\\\(k\\\\)-combinations of \\\\(n\\\\) elements\n * with repetitions:\n *\n * \\\\[\n * C^*(n, k) = \\binom{n + k - 1}{k} = \\frac{(n + k - 1)!}{k! (n - 1)!}\n * \\\\]\n *\n * Also known as the \"stars and bars\" problem in maths. Furthermore, the implementation uses an\n * efficient iterative multiplicative formula for computing the result.\n *\n * <details>\n * <summary>Details</summary>\n *\n * A \\\\(k\\\\)-combination with repetitions is a sequence of \\\\(k\\\\) elements selected from\n * \\\\(n\\\\) elements where the order of selection does not matter and elements are allowed to\n * repeat. For example, consider selecting 2 elements from a list of 3 elements: `[\"A\", \"B\", \"C\"]`.\n * In this case, possible selections are:\n *   - `[\"A\", \"A\"], [\"A\", \"B\"], [\"A\", \"C\"]`\n *   - `[\"B\", \"B\"], [\"B\", \"C\"], [\"C\", \"C\"]`\n *\n * </details>\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.combination_with_repetitions(-1, 1)\n *       |> should.be_error()\n *\n *       maths.combination_with_repetitions(2, 3)\n *       |> should.equal(Ok(4))\n *\n *       maths.combination_with_repetitions(13, 5)\n *       |> should.equal(Ok(6188))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function combination_with_repetitions(n, k) {\n  return combination((n + k) - 1, k);\n}\n\nfunction do_factorial(loop$n, loop$acc) {\n  while (true) {\n    let n = loop$n;\n    let acc = loop$acc;\n    if (n === 0) {\n      return acc;\n    } else if (n === 1) {\n      return acc;\n    } else {\n      loop$n = n - 1;\n      loop$acc = acc * n;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A combinatorial function for computing the total number of combinations of \\\\(n\\\\)\n * elements, that is \\\\(n!\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.factorial(-1)\n *       |> should.be_error()\n *\n *       maths.factorial(0)\n *       |> should.equal(Ok(1))\n *\n *       maths.factorial(3)\n *       |> should.equal(Ok(6))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function factorial(n) {\n  if (n < 0) {\n    return new Error(undefined);\n  } else {\n    return new Ok(do_factorial(n, 1));\n  }\n}\n\nfunction do_permutation(loop$n, loop$k, loop$acc) {\n  while (true) {\n    let n = loop$n;\n    let k = loop$k;\n    let acc = loop$acc;\n    if (k === 0) {\n      return acc;\n    } else {\n      loop$n = n - 1;\n      loop$k = k - 1;\n      loop$acc = acc * n;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A combinatorial function for computing the number of \\\\(k\\\\)-permutations without\n * repetitions:\n *\n * \\\\[\n * P(n, k) = \\binom{n}{k} \\cdot k! = \\frac{n!}{(n - k)!}\n * \\\\]\n *\n * The implementation uses an efficient iterative multiplicative formula for computing the result.\n *\n * <details>\n * <summary>Details</summary>\n *\n * A \\\\(k\\\\)-permutation without repetitions is a sequence of \\\\(k\\\\) elements selected from \\\n * \\\\(n\\\\) elements where the order of selection matters and elements are not allowed to repeat.\n * For example, consider selecting 2 elements from a list of 3 elements: `[\"A\", \"B\", \"C\"]`. In\n * this case, possible selections are:\n *   - `[\"A\", \"B\"], [\"B\", \"A\"]`\n *   - `[\"A\", \"C\"], [\"C\", \"A\"]`\n *   - `[\"B\", \"C\"], [\"C\", \"B\"]`\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.permutation(-1, 1)\n *       |> should.be_error()\n *\n *       maths.permutation(4, 0)\n *       |> should.equal(Ok(1))\n *\n *       maths.permutation(4, 2)\n *       |> should.equal(Ok(12))\n *\n *       maths.permutation(13, 5)\n *       |> should.equal(Ok(154_440))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function permutation(n, k) {\n  if (n < 0) {\n    return new Error(undefined);\n  } else if (k < 0) {\n    return new Error(undefined);\n  } else if (k > n) {\n    return new Ok(0);\n  } else if (k === 0) {\n    return new Ok(1);\n  } else {\n    return new Ok(do_permutation(n, k, 1));\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A combinatorial function for computing the number of \\\\(k\\\\)-permutations with repetitions:\n *\n * \\\\[\n * P^*(n, k) = n^k\n * \\\\]\n *\n * <details>\n * <summary>Details</summary>\n *\n * A \\\\(k\\\\)-permutation with repetitions is a sequence of \\\\(k\\\\) elements selected from \\\\(n\\\\)\n * elements where the order of selection matters and elements are allowed to repeat. For example,\n * consider selecting 2 elements from a list of 3 elements: `[\"A\", \"B\", \"C\"]`. In this case,\n * possible selections are:\n *   - `[\"A\", \"A\"], [\"A\", \"B\"], [\"A\", \"C\"]`\n *   - `[\"B\", \"A\"], [\"B\", \"B\"], [\"B\", \"C\"]`\n *   - `[\"C\", \"A\"], [\"C\", \"B\"], [\"C\", \"C\"]`\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.permutation_with_repetitions(1, -1)\n *       |> should.be_error()\n *\n *       maths.permutation_with_repetitions(2, 3)\n *       |> should.equal(Ok(8))\n *\n *       maths.permutation_with_repetitions(4, 4)\n *       |> should.equal(Ok(256))\n *\n *       maths.permutation_with_repetitions(6, 3)\n *       |> should.equal(Ok(216))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function permutation_with_repetitions(n, k) {\n  if (n < 0) {\n    return new Error(undefined);\n  } else if (k < 0) {\n    return new Error(undefined);\n  } else {\n    let n_float = $int.to_float(n);\n    let k_float = $int.to_float(k);\n    let $ = $float.power(n_float, k_float);\n    let result;\n    if ($ instanceof Ok) {\n      result = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        2987,\n        \"permutation_with_repetitions\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 83409,\n          end: 83462,\n          pattern_start: 83420,\n          pattern_end: 83430\n        }\n      )\n    }\n    return new Ok($float.round(result));\n  }\n}\n\nfunction do_list_combination_without_repetitions(arr, k, prefix) {\n  if (k === 0) {\n    return $yielder.single($list.reverse(prefix));\n  } else {\n    let $ = $yielder.step(arr);\n    if ($ instanceof $yielder.Next) {\n      let x = $.element;\n      let xs = $.accumulator;\n      let with_x = do_list_combination_without_repetitions(\n        xs,\n        k - 1,\n        listPrepend(x, prefix),\n      );\n      let without_x = do_list_combination_without_repetitions(xs, k, prefix);\n      return $yielder.concat(toList([with_x, without_x]));\n    } else {\n      return $yielder.empty();\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generates all possible combinations of \\\\(k\\\\) elements selected from a given list of size\n * \\\\(n\\\\). The function handles the case without repetitions, that is, repeated elements\n * are not treated as distinct.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // All 2-combinations of [1, 2, 3] without repetition\n *       let assert Ok(combinations) = maths.list_combination([1, 2, 3], 2)\n *\n *       combinations\n *       |> yielder.to_list()\n *       |> should.equal([[1, 2], [1, 3], [2, 3]])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_combination(arr, k) {\n  let $ = $list.length(arr);\n  if (k < 0) {\n    return new Error(undefined);\n  } else {\n    let arr_length = $;\n    if (k > arr_length) {\n      return new Error(undefined);\n    } else {\n      let arr_length = $;\n      if (k === arr_length) {\n        return new Ok($yielder.single(arr));\n      } else {\n        return new Ok(\n          do_list_combination_without_repetitions(\n            $yielder.from_list(arr),\n            k,\n            toList([]),\n          ),\n        );\n      }\n    }\n  }\n}\n\nfunction do_list_combination_with_repetitions(arr, k, prefix) {\n  if (k === 0) {\n    return $yielder.single($list.reverse(prefix));\n  } else {\n    let $ = $yielder.step(arr);\n    if ($ instanceof $yielder.Next) {\n      let x = $.element;\n      let xs = $.accumulator;\n      let with_x = do_list_combination_with_repetitions(\n        arr,\n        k - 1,\n        listPrepend(x, prefix),\n      );\n      let without_x = do_list_combination_with_repetitions(xs, k, prefix);\n      return $yielder.concat(toList([with_x, without_x]));\n    } else {\n      return $yielder.empty();\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generates all possible combinations of \\\\(k\\\\) elements selected from a given list of size\n * \\\\(n\\\\). The function handles the case when the repetition of elements is allowed, that is,\n * repeated elements are treated as distinct.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // All 2-combinations of [1, 2, 3] with repetition\n *       let assert Ok(combinations) =\n *         maths.list_combination_with_repetitions([1, 2, 3], 2)\n *\n *       combinations\n *       |> yielder.to_list()\n *       |> should.equal([[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_combination_with_repetitions(arr, k) {\n  if (k < 0) {\n    return new Error(undefined);\n  } else {\n    return new Ok(\n      do_list_combination_with_repetitions(\n        $yielder.from_list(arr),\n        k,\n        toList([]),\n      ),\n    );\n  }\n}\n\nfunction remove_first_by_index(arr, index_to_remove) {\n  return $yielder.flat_map(\n    arr,\n    (tuple) => {\n      let index;\n      let element;\n      index = tuple[0];\n      element = tuple[1];\n      let $ = index === index_to_remove;\n      if ($) {\n        return $yielder.empty();\n      } else {\n        return $yielder.single([index, element]);\n      }\n    },\n  );\n}\n\nfunction do_list_permutation_without_repetitions(arr, k) {\n  if (k === 0) {\n    return $yielder.single(toList([]));\n  } else {\n    return $yielder.flat_map(\n      arr,\n      (tuple) => {\n        let index;\n        let element;\n        index = tuple[0];\n        element = tuple[1];\n        let remaining = remove_first_by_index(arr, index);\n        let permutations = do_list_permutation_without_repetitions(\n          remaining,\n          k - 1,\n        );\n        return $yielder.map(\n          permutations,\n          (permutation) => { return listPrepend(element, permutation); },\n        );\n      },\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generates all possible permutations of \\\\(k\\\\) elements selected from a given list of size\n * \\\\(n\\\\). The function handles the case without repetitions, that is, repeated elements are\n * not treated as distinct.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // All 2-permutations of [1, 2] without repetition\n *       let assert Ok(permutations) =\n *         [1, 2]\n *         |> maths.list_permutation(2)\n *       permutations\n *       |> yielder.to_list()\n *       |> should.equal([[1, 2], [2, 1]])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_permutation(arr, k) {\n  let $ = $list.length(arr);\n  if (k < 0) {\n    return new Error(undefined);\n  } else {\n    let arr_length = $;\n    if (k > arr_length) {\n      return new Error(undefined);\n    } else {\n      let indexed_arr = $list.index_map(\n        arr,\n        (element, index) => { return [index, element]; },\n      );\n      return new Ok(\n        do_list_permutation_without_repetitions(\n          $yielder.from_list(indexed_arr),\n          k,\n        ),\n      );\n    }\n  }\n}\n\nfunction do_list_permutation_with_repetitions(arr, k) {\n  if (k === 0) {\n    return $yielder.single(toList([]));\n  } else {\n    return $yielder.flat_map(\n      arr,\n      (tuple) => {\n        let element;\n        element = tuple[1];\n        let permutations = do_list_permutation_with_repetitions(arr, k - 1);\n        return $yielder.map(\n          permutations,\n          (permutation) => { return listPrepend(element, permutation); },\n        );\n      },\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generates all possible permutations of \\\\(k\\\\) elements selected from a given list of size\n * \\\\(n\\\\). The function handles the case when the repetition of elements is allowed, that is,\n * repeated elements are treated as distinct.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // All 2-permutations of [1, 2] with repetition\n *       let assert Ok(permutations) =\n *         [1, 2]\n *         |> maths.list_permutation_with_repetitions(2)\n *       permutations\n *       |> yielder.to_list()\n *       |> set.from_list()\n *       |> should.equal(set.from_list([[1, 1], [1, 2], [2, 2], [2, 1]]))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function list_permutation_with_repetitions(arr, k) {\n  if (k < 0) {\n    return new Error(undefined);\n  } else {\n    let indexed_arr = $list.index_map(\n      arr,\n      (element, index) => { return [index, element]; },\n    );\n    return new Ok(\n      do_list_permutation_with_repetitions($yielder.from_list(indexed_arr), k),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generate a set containing all combinations of pairs of elements coming from two given sets.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/set\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       set.from_list([])\n *       |> maths.cartesian_product(set.from_list([]))\n *       |> should.equal(set.from_list([]))\n *\n *       set.from_list([1.0, 10.0])\n *       |> maths.cartesian_product(set.from_list([1.0, 2.0]))\n *       |> should.equal(\n *         set.from_list([#(1.0, 1.0), #(1.0, 2.0), #(10.0, 1.0), #(10.0, 2.0)]),\n *       )\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cartesian_product(xset, yset) {\n  return $set.fold(\n    xset,\n    $set.new$(),\n    (acc0, element0) => {\n      return $set.fold(\n        yset,\n        acc0,\n        (acc1, element1) => { return $set.insert(acc1, [element0, element1]); },\n      );\n    },\n  );\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the \\\\(p\\\\)-norm of a list (representing a vector):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n \\left|x_{i}\\right|^{p} \\right)^{\\frac{1}{p}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the list and \\\\(x_i\\\\) is the value in\n * the input list indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       [1.0, 1.0, 1.0]\n *       |> maths.norm(1.0)\n *       |> should.equal(Ok(3.0))\n *\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(result) =\n *         [1.0, 2.0, 3.0]\n *         |> maths.norm(2.0)\n *       result\n *       |> maths.is_close(3.7416573867739413, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function norm(arr, p) {\n  if (arr instanceof $Empty) {\n    return new Ok(0.0);\n  } else {\n    if (p === 0.0) {\n      return new Ok(\n        $list.fold(\n          arr,\n          0.0,\n          (acc, element) => {\n            if (element === 0.0) {\n              return acc;\n            } else {\n              return acc + 1.0;\n            }\n          },\n        ),\n      );\n    } else if (p < 0.0) {\n      let aggregate = $list.try_fold(\n        arr,\n        0.0,\n        (acc, element) => {\n          if (element === 0.0) {\n            return new Error(0.0);\n          } else {\n            let $ = $float.power($float.absolute_value(element), p);\n            let result;\n            if ($ instanceof Ok) {\n              result = $[0];\n            } else {\n              throw makeError(\n                \"let_assert\",\n                FILEPATH,\n                \"gleam_community/maths\",\n                3385,\n                \"norm\",\n                \"Pattern match failed, no pattern matched the value.\",\n                {\n                  value: $,\n                  start: 95228,\n                  end: 95317,\n                  pattern_start: 95239,\n                  pattern_end: 95249\n                }\n              )\n            }\n            return new Ok(result + acc);\n          }\n        },\n      );\n      if (aggregate instanceof Ok) {\n        let result = aggregate[0];\n        return $float.power(result, divideFloat(1.0, p));\n      } else {\n        return new Ok(0.0);\n      }\n    } else {\n      let aggregate = $list.fold(\n        arr,\n        0.0,\n        (acc, element) => {\n          let $ = $float.power($float.absolute_value(element), p);\n          let result;\n          if ($ instanceof Ok) {\n            result = $[0];\n          } else {\n            throw makeError(\n              \"let_assert\",\n              FILEPATH,\n              \"gleam_community/maths\",\n              3402,\n              \"norm\",\n              \"Pattern match failed, no pattern matched the value.\",\n              {\n                value: $,\n                start: 95823,\n                end: 95908,\n                pattern_start: 95834,\n                pattern_end: 95844\n              }\n            )\n          }\n          return result + acc;\n        },\n      );\n      return $float.power(aggregate, divideFloat(1.0, p));\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted \\\\(p\\\\)-norm of a list (representing a vector):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n w_{i} \\left|x_{i}\\right|^{p} \\right)^{\\frac{1}{p}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the list and \\\\(x_i\\\\) is the value in\n * the input list indexed by \\\\(i\\\\), while \\\\(w_i \\in \\mathbb{R}_{+}\\\\) is\n * a corresponding positive weight.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       [#(1.0, 0.5), #(1.0, 0.5), #(1.0, 0.5)]\n *       |> maths.norm_with_weights(1.0)\n *       |> should.equal(Ok(1.5))\n *\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(result) =\n *         [#(1.0, 0.5), #(2.0, 0.5), #(3.0, 0.5)]\n *         |> maths.norm_with_weights(2.0)\n *       result\n *       |> maths.is_close(2.6457513110645907, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function norm_with_weights(arr, p) {\n  if (arr instanceof $Empty) {\n    return new Ok(0.0);\n  } else {\n    let weight_is_invalid = $list.any(\n      arr,\n      (tuple) => { return tuple[1] < 0.0; },\n    );\n    if (weight_is_invalid) {\n      return new Error(undefined);\n    } else {\n      if (p === 0.0) {\n        return new Ok(\n          $list.fold(\n            arr,\n            0.0,\n            (acc, tuple) => {\n              let $ = tuple[0];\n              if ($ === 0.0) {\n                return acc;\n              } else {\n                return acc + 1.0;\n              }\n            },\n          ),\n        );\n      } else if (p < 0.0) {\n        let aggregate = $list.try_fold(\n          arr,\n          0.0,\n          (acc, tuple) => {\n            let $ = tuple[0];\n            if ($ === 0.0) {\n              return new Error(0.0);\n            } else {\n              let $1 = tuple[1];\n              if ($1 === 0.0) {\n                return new Error(0.0);\n              } else {\n                let $2 = $float.power($float.absolute_value(tuple[0]), p);\n                let result;\n                if ($2 instanceof Ok) {\n                  result = $2[0];\n                } else {\n                  throw makeError(\n                    \"let_assert\",\n                    FILEPATH,\n                    \"gleam_community/maths\",\n                    3496,\n                    \"norm_with_weights\",\n                    \"Pattern match failed, no pattern matched the value.\",\n                    {\n                      value: $2,\n                      start: 99059,\n                      end: 99152,\n                      pattern_start: 99070,\n                      pattern_end: 99080\n                    }\n                  )\n                }\n                return new Ok((tuple[1] * result) + acc);\n              }\n            }\n          },\n        );\n        if (aggregate instanceof Ok) {\n          let result = aggregate[0];\n          return $float.power(result, divideFloat(1.0, p));\n        } else {\n          return new Ok(0.0);\n        }\n      } else {\n        let aggregate = $list.fold(\n          arr,\n          0.0,\n          (acc, tuple) => {\n            let $ = $float.power($float.absolute_value(tuple[0]), p);\n            let result;\n            if ($ instanceof Ok) {\n              result = $[0];\n            } else {\n              throw makeError(\n                \"let_assert\",\n                FILEPATH,\n                \"gleam_community/maths\",\n                3513,\n                \"norm_with_weights\",\n                \"Pattern match failed, no pattern matched the value.\",\n                {\n                  value: $,\n                  start: 99731,\n                  end: 99820,\n                  pattern_start: 99742,\n                  pattern_end: 99752\n                }\n              )\n            }\n            return (tuple[1] * result) + acc;\n          },\n        );\n        return $float.power(aggregate, divideFloat(1.0, p));\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Minkowski distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n w_{i} \\left|x_i - y_i \\right|^{p} \\right)^{\\frac{1}{p}}\n * \\\\]\n *\n * In the formula, \\\\(p >= 1\\\\) is the order, \\\\(n\\\\) is the length of the two lists\n * and \\\\(x_i, y_i\\\\) are the values in the respective input lists indexed by \\\\(i\\\\).\n *\n * The Minkowski distance is a generalization of the Euclidean distance\n * (\\\\(p=2\\\\)) and the Manhattan distance (\\\\(p = 1\\\\)).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       let assert Ok(result) =\n *         maths.minkowski_distance([#(1.0, 2.0), #(3.0, 4.0), #(5.0, 6.0)], 4.0)\n *       result\n *       |> maths.is_close(1.3160740129524924, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function minkowski_distance(arr, p) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let $ = p < 1.0;\n    if ($) {\n      return new Error(undefined);\n    } else {\n      let differences = $list.map(\n        arr,\n        (tuple) => { return tuple[0] - tuple[1]; },\n      );\n      return norm(differences, p);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Manhattan distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\sum_{i=1}^n \\left|x_i - y_i \\right|\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.manhattan_distance([#(1.0, 2.0), #(2.0, 3.0)])\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function manhattan_distance(arr) {\n  return minkowski_distance(arr, 1.0);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Minkowski distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n w_{i} \\left|x_i - y_i \\right|^{p} \\right)^{\\frac{1}{p}}\n * \\\\]\n *\n * In the formula, \\\\(p >= 1\\\\) is the order, \\\\(n\\\\) is the length of the two lists\n * and \\\\(x_i, y_i\\\\) are the values in the respective input lists indexed by \\\\(i\\\\).\n * The \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * The Minkowski distance is a generalization of the Euclidean distance\n * (\\\\(p=2\\\\)) and the Manhattan distance (\\\\(p = 1\\\\)).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       let assert Ok(result) =\n *         maths.minkowski_distance_with_weights(\n *           [#(1.0, 2.0, 0.5), #(3.0, 4.0, 1.0), #(5.0, 6.0, 1.0)],\n *           4.0,\n *         )\n *       result\n *       |> maths.is_close(1.2574334296829355, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function minkowski_distance_with_weights(arr, p) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let weight_is_negative = $list.any(\n      arr,\n      (tuple) => { return tuple[2] < 0.0; },\n    );\n    let $ = p < 1.0;\n    if (!$ && !weight_is_negative) {\n      let differences = $list.map(\n        arr,\n        (tuple) => { return [tuple[0] - tuple[1], tuple[2]]; },\n      );\n      return norm_with_weights(differences, p);\n    } else {\n      return new Error(undefined);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Manhattan distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\sum_{i=1}^n w_{i} \\left|x_i - y_i \\right|\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.manhattan_distance_with_weights([#(1.0, 2.0, 0.5), #(2.0, 3.0, 1.0)])\n *       |> should.equal(Ok(1.5))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function manhattan_distance_with_weights(arr) {\n  return minkowski_distance_with_weights(arr, 1.0);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Euclidean distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n \\left|x_i - y_i \\right|^{2} \\right)^{\\frac{1}{2}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       let assert Ok(result) = maths.euclidean_distance([#(1.0, 2.0), #(3.0, 4.0)])\n *       result\n *       |> maths.is_close(1.4142135623730951, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function euclidean_distance(arr) {\n  return minkowski_distance(arr, 2.0);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Euclidean distance between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\left( \\sum_{i=1}^n w_{i} \\left|x_i - y_i \\right|^{2} \\right)^{\\frac{1}{2}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       let assert Ok(result) =\n *         maths.euclidean_distance_with_weights([#(1.0, 2.0, 0.5), #(3.0, 4.0, 1.0)])\n *       result\n *       |> maths.is_close(1.224744871391589, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function euclidean_distance_with_weights(arr) {\n  return minkowski_distance_with_weights(arr, 2.0);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Chebyshev distance between two lists (representing vectors):\n *\n * \\\\[\n * \\text{max}_{i=1}^n \\left|x_i - y_i \\right|\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.chebyshev_distance([#(-5.0, -1.0), #(-10.0, -12.0), #(-3.0, -3.0)])\n *       |> should.equal(Ok(4.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function chebyshev_distance(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let _pipe = $list.map(\n      arr,\n      (tuple) => { return $float.absolute_value((tuple[0] - tuple[1])); },\n    );\n    return list_maximum(_pipe, $float.compare);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Chebyshev distance between two lists (representing vectors):\n *\n * \\\\[\n * \\text{max}_{i=1}^n w_i \\left|x_i - y_i \\right|\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.chebyshev_distance_with_weights([\n *         #(-5.0, -1.0, 0.5),\n *         #(-10.0, -12.0, 1.0),\n *         #(-3.0, -3.0, 1.0),\n *       ])\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function chebyshev_distance_with_weights(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let weight_is_negative = $list.any(\n      arr,\n      (tuple) => { return tuple[2] < 0.0; },\n    );\n    if (weight_is_negative) {\n      return new Error(undefined);\n    } else {\n      let _pipe = $list.map(\n        arr,\n        (tuple) => {\n          return $float.absolute_value((tuple[0] - tuple[1])) * tuple[2];\n        },\n      );\n      return list_maximum(_pipe, $float.compare);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the arithmetic mean of the elements in a list:\n *\n * \\\\[\n * \\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the list) and \\\\(x_i\\\\)\n * is the sample point in the input list indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.mean()\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.mean()\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function mean(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    return new Ok(\n      divideFloat($float.sum(arr), $int.to_float($list.length(arr))),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the n'th moment about the mean of a list of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.moment(0)\n *       |> should.be_error()\n *\n *       // 0th moment about the mean is 1. per definition\n *       [0.0, 1.0, 2.0, 3.0, 4.0]\n *       |> maths.moment(0)\n *       |> should.equal(Ok(1.0))\n *\n *       // 1st moment about the mean is 0. per definition\n *       [0.0, 1.0, 2.0, 3.0, 4.0]\n *       |> maths.moment(1)\n *       |> should.equal(Ok(0.0))\n *\n *       // 2nd moment about the mean\n *       [0.0, 1.0, 2.0, 3.0, 4.0]\n *       |> maths.moment(2)\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function moment(arr, n) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else if (n === 0) {\n    return new Ok(1.0);\n  } else if (n === 1) {\n    return new Ok(0.0);\n  } else {\n    let n$1 = n;\n    if (n$1 > 1) {\n      let $ = mean(arr);\n      let m1;\n      if ($ instanceof Ok) {\n        m1 = $[0];\n      } else {\n        throw makeError(\n          \"let_assert\",\n          FILEPATH,\n          \"gleam_community/maths\",\n          3976,\n          \"moment\",\n          \"Pattern match failed, no pattern matched the value.\",\n          {\n            value: $,\n            start: 112666,\n            end: 112695,\n            pattern_start: 112677,\n            pattern_end: 112683\n          }\n        )\n      }\n      let result = $list.try_fold(\n        arr,\n        0.0,\n        (acc, a) => {\n          let $1 = $float.power(a - m1, $int.to_float(n$1));\n          if ($1 instanceof Ok) {\n            let value = $1[0];\n            return new Ok(acc + value);\n          } else {\n            return new Error(undefined);\n          }\n        },\n      );\n      if (result instanceof Ok) {\n        let value = result[0];\n        return new Ok(divideFloat(value, $int.to_float($list.length(arr))));\n      } else {\n        return new Error(undefined);\n      }\n    } else {\n      return new Error(undefined);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the harmonic mean \\\\(\\bar{x}\\\\) of the elements in a list:\n *\n * \\\\[\n *   \\bar{x} = \\frac{n}{\\sum_{i=1}^{n}\\frac{1}{x_i}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the list) and\n * \\\\(x_i\\\\) is the sample point in the input list indexed by \\\\(i\\\\).\n * Note: The harmonic mean is only defined for positive numbers.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.harmonic_mean()\n *       |> should.be_error()\n *\n *       // List with negative numbers returns an error\n *       [-1.0, -3.0, -6.0]\n *       |> maths.harmonic_mean()\n *       |> should.be_error()\n *\n *       // Valid input returns a result\n *       [1.0, 3.0, 6.0]\n *       |> maths.harmonic_mean()\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function harmonic_mean(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let sum = $list.try_fold(\n      arr,\n      0.0,\n      (acc, a) => {\n        let a$1 = a;\n        if (a$1 > 0.0) {\n          return new Ok((divideFloat(1.0, a$1)) + acc);\n        } else {\n          let a$1 = a;\n          if (a$1 === 0.0) {\n            return new Error(0.0);\n          } else {\n            return new Error(-1.0);\n          }\n        }\n      },\n    );\n    if (sum instanceof Ok) {\n      let sum$1 = sum[0];\n      return new Ok(divideFloat($int.to_float($list.length(arr)), sum$1));\n    } else {\n      let $ = sum[0];\n      if ($ === 0.0) {\n        return new Ok(0.0);\n      } else {\n        return new Error(undefined);\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the geometric mean \\\\(\\bar{x}\\\\) of the elements in a list:\n *\n * \\\\[\n *   \\bar{x} = \\left(\\prod^{n}_{i=1} x_i\\right)^{\\frac{1}{n}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the list) and\n * \\\\(x_i\\\\) is the sample point in the input list indexed by \\\\(i\\\\).\n * Note: The geometric mean is only defined for positive numbers.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.geometric_mean()\n *       |> should.be_error()\n *\n *       // List with negative numbers returns an error\n *       [-1.0, -3.0, -6.0]\n *       |> maths.geometric_mean()\n *       |> should.be_error()\n *\n *       // Valid input returns a result\n *       [1.0, 3.0, 9.0]\n *       |> maths.geometric_mean()\n *       |> should.equal(Ok(3.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function geometric_mean(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let product = $list.try_fold(\n      arr,\n      1.0,\n      (acc, a) => {\n        let a$1 = a;\n        if (a$1 > 0.0) {\n          return new Ok(acc * a$1);\n        } else {\n          let a$1 = a;\n          if (a$1 === 0.0) {\n            return new Error(0.0);\n          } else {\n            return new Error(-1.0);\n          }\n        }\n      },\n    );\n    if (product instanceof Ok) {\n      let product$1 = product[0];\n      return $float.power(\n        product$1,\n        divideFloat(1.0, $int.to_float($list.length(arr))),\n      );\n    } else {\n      let $ = product[0];\n      if ($ === 0.0) {\n        return new Ok(0.0);\n      } else {\n        return new Error(undefined);\n      }\n    }\n  }\n}\n\nfunction do_median(xs, mid, mean, index) {\n  return $bool.guard(\n    index > mid,\n    new Error(undefined),\n    () => {\n      let mid_less_one = mid - 1;\n      if (xs instanceof $Empty) {\n        return new Error(undefined);\n      } else if (!mean && (index === mid)) {\n        let x = xs.head;\n        return new Ok(x);\n      } else {\n        let $ = xs.tail;\n        if ($ instanceof $Empty) {\n          let rest = $;\n          return do_median(rest, mid, mean, index + 1);\n        } else if (mean && (index === mid_less_one)) {\n          let x = xs.head;\n          let y = $.head;\n          return new Ok((x + y) / 2.0);\n        } else {\n          let rest = $;\n          return do_median(rest, mid, mean, index + 1);\n        }\n      }\n    },\n  );\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the median of the elements in a list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       []\n *       |> maths.median()\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.median()\n *       |> should.equal(Ok(2.0))\n *\n *       [1.0, 2.0, 3.0, 4.0]\n *       |> maths.median()\n *       |> should.equal(Ok(2.5))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function median(arr) {\n  return $bool.guard(\n    $list.is_empty(arr),\n    new Error(undefined),\n    () => {\n      let length = $list.length(arr);\n      let mid = globalThis.Math.trunc(length / 2);\n      let arr_sorted = $list.sort(arr, $float.compare);\n      let $ = (length % 2) === 0;\n      if ($) {\n        return do_median(arr_sorted, mid, true, 0);\n      } else {\n        return do_median(arr_sorted, mid, false, 0);\n      }\n    },\n  );\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the sample variance of the elements in a list:\n *\n * \\\\[\n * s^{2} = \\frac{1}{n - d} \\sum_{i=1}^{n}(x_i - \\bar{x})\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the list) and \\\\(x_i\\\\)\n * is the sample point in the input list indexed by \\\\(i\\\\).\n * Furthermore, \\\\(\\bar{x}\\\\) is the sample mean and \\\\(d\\\\) is the \"Delta\n * Degrees of Freedom\". It is typically set to \\\\(d = 1\\\\), which gives an unbiased estimate.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // Degrees of freedom\n *       let ddof = 1\n *\n *       []\n *       |> maths.variance(ddof)\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.variance(ddof)\n *       |> should.equal(Ok(1.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function variance(arr, ddof) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else if (ddof < 0) {\n    return new Error(undefined);\n  } else {\n    let $ = mean(arr);\n    let mean$1;\n    if ($ instanceof Ok) {\n      mean$1 = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        4297,\n        \"variance\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 121215,\n          end: 121246,\n          pattern_start: 121226,\n          pattern_end: 121234\n        }\n      )\n    }\n    return new Ok(\n      (() => {\n        let _pipe = $list.map(\n          arr,\n          (element) => {\n            let $1 = $float.power(element - mean$1, 2.0);\n            let result;\n            if ($1 instanceof Ok) {\n              result = $1[0];\n            } else {\n              throw makeError(\n                \"let_assert\",\n                FILEPATH,\n                \"gleam_community/maths\",\n                4304,\n                \"variance\",\n                \"Pattern match failed, no pattern matched the value.\",\n                {\n                  value: $1,\n                  start: 121610,\n                  end: 121667,\n                  pattern_start: 121621,\n                  pattern_end: 121631\n                }\n              )\n            }\n            return result;\n          },\n        );\n        let _pipe$1 = $float.sum(_pipe);\n        return ((element) => {\n          return divideFloat(\n            element,\n            ($int.to_float($list.length(arr)) - $int.to_float(ddof))\n          );\n        })(_pipe$1);\n      })(),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the sample standard deviation of the elements in a list:\n * \\\\[\n * s = \\left(\\frac{1}{n - d} \\sum_{i=1}^{n}(x_i - \\bar{x})\\right)^{\\frac{1}{2}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the list) and \\\\(x_i\\\\)\n * is the sample point in the input list indexed by \\\\(i\\\\).\n * Furthermore, \\\\(\\bar{x}\\\\) is the sample mean and \\\\(d\\\\) is the \"Delta\n * Degrees of Freedom\", and is typically set to \\\\(d = 1\\\\), which gives an unbiased estimate.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // Degrees of freedom\n *       let ddof = 1\n *\n *       []\n *       |> maths.standard_deviation(ddof)\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0]\n *       |> maths.standard_deviation(ddof)\n *       |> should.equal(Ok(1.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function standard_deviation(arr, ddof) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else if (ddof < 0) {\n    return new Error(undefined);\n  } else {\n    let $ = variance(arr, ddof);\n    let variance$1;\n    if ($ instanceof Ok) {\n      variance$1 = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        4365,\n        \"standard_deviation\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 123423,\n          end: 123468,\n          pattern_start: 123434,\n          pattern_end: 123446\n        }\n      )\n    }\n    return $float.square_root(variance$1);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the sample kurtosis of a list of elements using the\n * definition of Fisher.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.kurtosis()\n *       |> should.be_error()\n *\n *       // To calculate kurtosis at least four values are needed\n *       [1.0, 2.0, 3.0]\n *       |> maths.kurtosis()\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0, 4.0]\n *       |> maths.kurtosis()\n *       |> should.equal(Ok(-1.36))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function kurtosis(arr) {\n  let $ = $list.length(arr) < 4;\n  if ($) {\n    return new Error(undefined);\n  } else {\n    let $1 = moment(arr, 2);\n    let $2 = moment(arr, 4);\n    if ($1 instanceof Ok && $2 instanceof Ok) {\n      let m2 = $1[0];\n      if (m2 !== 0.0) {\n        let m4 = $2[0];\n        let $3 = $float.power(m2, 2.0);\n        if ($3 instanceof Ok) {\n          let value = $3[0];\n          return new Ok((divideFloat(m4, value)) - 3.0);\n        } else {\n          return $3;\n        }\n      } else {\n        return new Error(undefined);\n      }\n    } else {\n      return new Error(undefined);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the sample skewness of a list of elements using the\n * Fisher-Pearson coefficient of skewness.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.skewness()\n *       |> should.be_error()\n *\n *       // To calculate skewness at least three values are needed\n *       [1.0, 2.0, 3.0]\n *       |> maths.skewness()\n *       |> should.equal(Ok(0.0))\n *\n *       [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 4.0]\n *       |> maths.skewness()\n *       |> should.equal(Ok(0.6))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function skewness(arr) {\n  let $ = $list.length(arr) < 3;\n  if ($) {\n    return new Error(undefined);\n  } else {\n    let $1 = moment(arr, 2);\n    let $2 = moment(arr, 3);\n    if ($1 instanceof Ok && $2 instanceof Ok) {\n      let m2 = $1[0];\n      if (m2 !== 0.0) {\n        let m3 = $2[0];\n        let $3 = $float.power(m2, 1.5);\n        if ($3 instanceof Ok) {\n          let value = $3[0];\n          return new Ok(divideFloat(m3, value));\n        } else {\n          return $3;\n        }\n      } else {\n        return new Error(undefined);\n      }\n    } else {\n      return new Error(undefined);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the n'th percentile of the elements in a list using\n * linear interpolation between closest ranks.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.percentile(40)\n *       |> should.be_error()\n *\n *       // Calculate 40th percentile\n *       [15.0, 20.0, 35.0, 40.0, 50.0]\n *       |> maths.percentile(40)\n *       |> should.equal(Ok(29.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function percentile(arr, n) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let $ = arr.tail;\n    if ($ instanceof $Empty) {\n      let element = arr.head;\n      return new Ok(element);\n    } else {\n      let n$1 = n;\n      if (n$1 === 0) {\n        return $list.first($list.sort(arr, $float.compare));\n      } else {\n        let n$1 = n;\n        if (n$1 === 100) {\n          return $list.last($list.sort(arr, $float.compare));\n        } else {\n          let n$1 = n;\n          if ((n$1 > 0) && (n$1 < 100)) {\n            let r = ($int.to_float(n$1) / 100.0) * $int.to_float(\n              $list.length(arr) - 1,\n            );\n            let f = $float.truncate(r);\n            let sorted_arr = $list.drop($list.sort(arr, $float.compare), f);\n            let $1 = $list.take(sorted_arr, 2);\n            if ($1 instanceof $Empty) {\n              return new Error(undefined);\n            } else {\n              let $2 = $1.tail;\n              if ($2 instanceof $Empty) {\n                return new Error(undefined);\n              } else {\n                let $3 = $2.tail;\n                if ($3 instanceof $Empty) {\n                  let lower = $1.head;\n                  let upper = $2.head;\n                  return new Ok(\n                    lower + ((upper - lower) * (r - $int.to_float(f))),\n                  );\n                } else {\n                  return new Error(undefined);\n                }\n              }\n            }\n          } else {\n            return new Error(undefined);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the z-score of each value in the list relative to the sample\n * mean and standard deviation.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       // Use degrees of freedom = 1\n *       |> maths.zscore(1)\n *       |> should.be_error()\n *\n *       [1.0, 2.0, 3.0]\n *       // Use degrees of freedom = 1\n *       |> maths.zscore(1)\n *       |> should.equal(Ok([-1.0, 0.0, 1.0]))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function zscore(arr, ddof) {\n  let length = $list.length(arr);\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let ddof$1 = ddof;\n    if (ddof$1 < 0) {\n      return new Error(undefined);\n    } else {\n      let ddof$1 = ddof;\n      if (length <= ddof$1) {\n        return new Error(undefined);\n      } else {\n        let $ = mean(arr);\n        let $1 = standard_deviation(arr, ddof);\n        if ($ instanceof Ok && $1 instanceof Ok) {\n          let stdev = $1[0];\n          if (stdev !== 0.0) {\n            let mean$1 = $[0];\n            return new Ok(\n              $list.map(\n                arr,\n                (a) => { return divideFloat((a - mean$1), stdev); },\n              ),\n            );\n          } else {\n            return new Error(undefined);\n          }\n        } else {\n          return new Error(undefined);\n        }\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the interquartile range (IQR) of the elements in a list.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty list returns an error\n *       []\n *       |> maths.interquartile_range()\n *       |> should.be_error()\n *\n *       // Valid input returns a result\n *       [1.0, 2.0, 3.0, 4.0, 5.0]\n *       |> maths.interquartile_range()\n *       |> should.equal(Ok(3.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function interquartile_range(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let length = $list.length(arr);\n    let arr_sorted = $list.sort(arr, $float.compare);\n    let $ = $int.is_even(length);\n    if ($) {\n      let $1 = $list.split(arr_sorted, globalThis.Math.trunc(length / 2));\n      let lower_half;\n      let upper_half;\n      lower_half = $1[0];\n      upper_half = $1[1];\n      let $2 = median(lower_half);\n      let $3 = median(upper_half);\n      if ($2 instanceof Ok && $3 instanceof Ok) {\n        let q1 = $2[0];\n        let q3 = $3[0];\n        return new Ok(q3 - q1);\n      } else {\n        return new Error(undefined);\n      }\n    } else {\n      let $1 = $list.split(arr_sorted, globalThis.Math.trunc((length - 1) / 2));\n      let lower_half;\n      lower_half = $1[0];\n      let $2 = $list.split(arr_sorted, globalThis.Math.trunc((length + 1) / 2));\n      let upper_half;\n      upper_half = $2[1];\n      let $3 = median(lower_half);\n      let $4 = median(upper_half);\n      if ($3 instanceof Ok && $4 instanceof Ok) {\n        let q1 = $3[0];\n        let q3 = $4[0];\n        return new Ok(q3 - q1);\n      } else {\n        return new Error(undefined);\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate Pearson's sample correlation coefficient to determine the linear\n * relationship between the elements in two lists of equal\n * length. The correlation coefficient \\\\(r_{xy} \\in \\[-1, 1\\]\\\\) is calculated\n * as:\n *\n * \\\\[\n * r_{xy} =\\frac{\\sum ^n _{i=1}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum^n _{i=1}(x_i - \\bar{x})^2} \\sqrt{\\sum^n _{i=1}(y_i - \\bar{y})^2}}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the sample size (the length of the input lists),\n * \\\\(x_i\\\\), \\\\(y_i\\\\) are the corresponding sample points indexed by \\\\(i\\\\) and\n * \\\\(\\bar{x}\\\\), \\\\(\\bar{y}\\\\) are the sample means.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       // An empty lists returns an error\n *       maths.correlation([], [])\n *       |> should.be_error()\n *\n *       // Perfect positive correlation\n *       let xarr =\n *         list.range(0, 100)\n *         |> list.map(fn(x) { int.to_float(x) })\n *       let yarr =\n *         list.range(0, 100)\n *         |> list.map(fn(y) { int.to_float(y) })\n *       list.zip(xarr, yarr)\n *       |> maths.correlation()\n *       |> should.equal(Ok(1.0))\n *\n *       // Perfect negative correlation\n *       let xarr =\n *         list.range(0, 100)\n *         |> list.map(fn(x) { -1.0 *. int.to_float(x) })\n *       let yarr =\n *         list.range(0, 100)\n *         |> list.map(fn(y) { int.to_float(y) })\n *       list.zip(xarr, yarr)\n *       |> maths.correlation()\n *       |> should.equal(Ok(-1.0))\n *\n *       // No correlation (independent variables)\n *       let xarr = [1.0, 2.0, 3.0, 4.0]\n *       let yarr = [5.0, 5.0, 5.0, 5.0]\n *       list.zip(xarr, yarr)\n *       |> maths.correlation()\n *       |> should.equal(Ok(0.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function correlation(arr) {\n  let length = $list.length(arr);\n  let $ = length >= 2;\n  if ($) {\n    let $1 = $list.unzip(arr);\n    let xarr;\n    let yarr;\n    xarr = $1[0];\n    yarr = $1[1];\n    let $2 = mean(xarr);\n    let xmean;\n    if ($2 instanceof Ok) {\n      xmean = $2[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        4743,\n        \"correlation\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $2,\n          start: 134466,\n          end: 134499,\n          pattern_start: 134477,\n          pattern_end: 134486\n        }\n      )\n    }\n    let $3 = mean(yarr);\n    let ymean;\n    if ($3 instanceof Ok) {\n      ymean = $3[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        4744,\n        \"correlation\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $3,\n          start: 134506,\n          end: 134539,\n          pattern_start: 134517,\n          pattern_end: 134526\n        }\n      )\n    }\n    let _block;\n    let _pipe = $list.map(\n      arr,\n      (tuple) => { return (tuple[0] - xmean) * (tuple[1] - ymean); },\n    );\n    _block = $float.sum(_pipe);\n    let a = _block;\n    let _block$1;\n    let _pipe$1 = $list.map(xarr, (x) => { return (x - xmean) * (x - xmean); });\n    _block$1 = $float.sum(_pipe$1);\n    let b = _block$1;\n    let _block$2;\n    let _pipe$2 = $list.map(yarr, (y) => { return (y - ymean) * (y - ymean); });\n    _block$2 = $float.sum(_pipe$2);\n    let c = _block$2;\n    let $4 = $float.square_root(b * c);\n    let value;\n    if ($4 instanceof Ok) {\n      value = $4[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        4758,\n        \"correlation\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $4,\n          start: 135044,\n          end: 135092,\n          pattern_start: 135055,\n          pattern_end: 135064\n        }\n      )\n    }\n    return new Ok(divideFloat(a, value));\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The Tversky index is a generalization of the Jaccard index and Srensen-Dice\n * coefficient, which adds flexibility in measuring similarity between two sets using two\n * parameters, \\\\(\\alpha\\\\) and \\\\(\\beta\\\\). These parameters allow for asymmetric\n * similarity measures between sets. The Tversky index is defined as:\n *\n * \\\\[\n * \\frac{|X \\cap Y|}{|X \\cap Y| + \\alpha|X - Y| + \\beta|Y - X|}\n * \\\\]\n *\n * where:\n *\n * - \\\\(X\\\\) and \\\\(Y\\\\) are the sets being compared\n * - \\\\(|X - Y|\\\\) and \\\\(|Y - X|\\\\) are the sizes of the relative complements of\n * \\\\(Y\\\\) in \\\\(X\\\\) and \\\\(X\\\\) in \\\\(Y\\\\), respectively,\n * - \\\\(\\alpha\\\\) and \\\\(\\beta\\\\) are parameters that weight the relative importance\n * of the elements unique to \\\\(X\\\\) and \\\\(Y\\\\)\n *\n * The Tversky index reduces to the Jaccard index when \\\\(\\alpha = \\beta = 1\\\\) and\n * to the Srensen-Dice coefficient when \\\\(\\alpha = \\beta = 0.5\\\\). In general, the\n * Tversky index can take on any non-negative value, including 0. The index equals\n * 0 when there is no intersection between the two sets, indicating no similarity.\n * The Tversky index does not have a strict upper limit of 1 when \\\\(\\alpha \\neq \\beta\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/set\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let yset = set.from_list([\"cat\", \"dog\", \"hippo\", \"monkey\"])\n *       let xset = set.from_list([\"monkey\", \"rhino\", \"ostrich\", \"salmon\"])\n *       // Test Jaccard index (alpha = beta = 1)\n *       maths.tversky_index(xset, yset, 1.0, 1.0)\n *       |> should.equal(Ok(1.0 /. 7.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function tversky_index(xset, yset, alpha, beta) {\n  let $ = alpha >= 0.0;\n  let $1 = beta >= 0.0;\n  if ($ && $1) {\n    let _block;\n    let _pipe = $set.intersection(xset, yset);\n    let _pipe$1 = $set.size(_pipe);\n    _block = $int.to_float(_pipe$1);\n    let intersection = _block;\n    let _block$1;\n    let _pipe$2 = $set.difference(xset, yset);\n    let _pipe$3 = $set.size(_pipe$2);\n    _block$1 = $int.to_float(_pipe$3);\n    let difference1 = _block$1;\n    let _block$2;\n    let _pipe$4 = $set.difference(yset, xset);\n    let _pipe$5 = $set.size(_pipe$4);\n    _block$2 = $int.to_float(_pipe$5);\n    let difference2 = _block$2;\n    return new Ok(\n      divideFloat(\n        intersection,\n        ((intersection + (alpha * difference1)) + (beta * difference2))\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The Jaccard index measures similarity between two sets of elements. Mathematically, the\n * Jaccard index is defined as:\n *\n * \\\\[\n * \\frac{|X \\cap Y|}{|X \\cup Y|} \\\\; \\in \\\\; \\left[0, 1\\right]\n * \\\\]\n *\n * where:\n *\n * - \\\\(X\\\\) and \\\\(Y\\\\) are two sets being compared\n * - \\\\(|X \\cap Y|\\\\) represents the size of the intersection of the two sets\n * - \\\\(|X \\cup Y|\\\\) denotes the size of the union of the two sets\n *\n * The value of the Jaccard index ranges from 0 to 1, where 0 indicates that the\n * two sets share no elements and 1 indicates that the sets are identical. The\n * Jaccard index is a special case of the  [Tversky index](#tversky_index) (with\n * \\\\(\\alpha=\\beta=1\\\\)).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/set\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let xset = set.from_list([\"cat\", \"dog\", \"hippo\", \"monkey\"])\n *       let yset = set.from_list([\"monkey\", \"rhino\", \"ostrich\", \"salmon\"])\n *       maths.jaccard_index(xset, yset)\n *       |> should.equal(1.0 /. 7.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function jaccard_index(xset, yset) {\n  let $ = tversky_index(xset, yset, 1.0, 1.0);\n  let result;\n  if ($ instanceof Ok) {\n    result = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      4812,\n      \"jaccard_index\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 136787,\n        end: 136846,\n        pattern_start: 136798,\n        pattern_end: 136808\n      }\n    )\n  }\n  return result;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The Srensen-Dice coefficient measures the similarity between two sets of elements.\n * Mathematically, the coefficient is defined as:\n *\n * \\\\[\n * \\frac{2 |X \\cap Y|}{|X| + |Y|} \\\\; \\in \\\\; \\left[0, 1\\right]\n * \\\\]\n *\n * where:\n *\n * - \\\\(X\\\\) and \\\\(Y\\\\) are two sets being compared\n * - \\\\(|X \\cap Y|\\\\) is the size of the intersection of the two sets (i.e., the\n * number of elements common to both sets)\n * - \\\\(|X|\\\\) and \\\\(|Y|\\\\) are the sizes of the sets \\\\(X\\\\) and \\\\(Y\\\\), respectively\n *\n * The coefficient ranges from 0 to 1, where 0 indicates no similarity (the sets\n * share no elements) and 1 indicates perfect similarity (the sets are identical).\n * The higher the coefficient, the greater the similarity between the two sets.\n * The Srensen-Dice coefficient is a special case of the\n * [Tversky index](#tversky_index) (with \\\\(\\alpha=\\beta=0.5\\\\)).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/set\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let xset = set.from_list([\"cat\", \"dog\", \"hippo\", \"monkey\"])\n *       let yset = set.from_list([\"monkey\", \"rhino\", \"ostrich\", \"salmon\", \"spider\"])\n *       maths.sorensen_dice_coefficient(xset, yset)\n *       |> should.equal(2.0 *. 1.0 /. { 4.0 +. 5.0 })\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function sorensen_dice_coefficient(xset, yset) {\n  let $ = tversky_index(xset, yset, 0.5, 0.5);\n  let result;\n  if ($ instanceof Ok) {\n    result = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"gleam_community/maths\",\n      4866,\n      \"sorensen_dice_coefficient\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 138758,\n        end: 138817,\n        pattern_start: 138769,\n        pattern_end: 138779\n      }\n    )\n  }\n  return result;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The Overlap coefficient, also known as the SzymkiewiczSimpson coefficient, is\n * a measure of similarity between two sets that focuses on the size of the\n * intersection relative to the smaller of the two sets. It is defined\n * mathematically as:\n *\n * \\\\[\n * \\frac{|X \\cap Y|}{\\min(|X|, |Y|)} \\\\; \\in \\\\; \\left[0, 1\\right]\n * \\\\]\n *\n * where:\n *\n * - \\\\(X\\\\) and \\\\(Y\\\\) are the sets being compared\n * - \\\\(|X \\cap Y|\\\\) is the size of the intersection of the sets\n * - \\\\(\\min(|X|, |Y|)\\\\) is the size of the smaller set among \\\\(X\\\\) and \\\\(Y\\\\)\n *\n * The coefficient ranges from 0 to 1, where 0 indicates no overlap and 1\n * indicates that the smaller set is a suyset of the larger set. This\n * measure is especially useful in situations where the similarity in terms\n * of the proportion of overlap is more relevant than the difference in sizes\n * between the two sets.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/set\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let set_a = set.from_list([\"horse\", \"dog\", \"hippo\", \"monkey\", \"bird\"])\n *       let set_b = set.from_list([\"monkey\", \"bird\", \"ostrich\", \"salmon\"])\n *       maths.overlap_coefficient(set_a, set_b)\n *       |> should.equal(2.0 /. 4.0)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function overlap_coefficient(xset, yset) {\n  let _block;\n  let _pipe = $set.intersection(xset, yset);\n  let _pipe$1 = $set.size(_pipe);\n  _block = $int.to_float(_pipe$1);\n  let intersection = _block;\n  let _block$1;\n  let _pipe$2 = $int.min($set.size(xset), $set.size(yset));\n  _block$1 = $int.to_float(_pipe$2);\n  let minsize = _block$1;\n  return divideFloat(intersection, minsize);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the cosine similarity between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\frac{\\sum_{i=1}^n  x_i \\cdot y_i}\n * {\\left(\\sum_{i=1}^n x_i^2\\right)^{\\frac{1}{2}}\n * \\cdot\n * \\left(\\sum_{i=1}^n y_i^2\\right)^{\\frac{1}{2}}}\n * \\\\; \\in \\\\; \\left[-1, 1\\right]\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i\\\\), \\\\(y_i\\\\) are\n * the values in the respective input lists indexed by \\\\(i\\\\).\n *\n * The cosine similarity provides a value between -1 and 1, where 1 means the\n * vectors are in the same direction, -1 means they are in exactly opposite\n * directions, and 0 indicates orthogonality.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/option\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       // Two orthogonal vectors\n *       maths.cosine_similarity([#(-1.0, 1.0), #(1.0, 1.0), #(0.0, -1.0)])\n *       |> should.equal(Ok(0.0))\n *\n *       // Two identical (parallel) vectors\n *       maths.cosine_similarity([#(1.0, 1.0), #(2.0, 2.0), #(3.0, 3.0)])\n *       |> should.equal(Ok(1.0))\n *\n *       // Two parallel, but oppositely oriented vectors\n *       maths.cosine_similarity([#(-1.0, 1.0), #(-2.0, 2.0), #(-3.0, 3.0)])\n *       |> should.equal(Ok(-1.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cosine_similarity(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let numerator = $list.fold(\n      arr,\n      0.0,\n      (acc, tuple) => { return acc + (tuple[0] * tuple[1]); },\n    );\n    let xarr = $list.map(arr, (tuple) => { return tuple[0]; });\n    let yarr = $list.map(arr, (tuple) => { return tuple[1]; });\n    let $ = norm(xarr, 2.0);\n    let xarr_norm;\n    if ($ instanceof Ok) {\n      xarr_norm = $[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        5073,\n        \"cosine_similarity\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $,\n          start: 145613,\n          end: 145655,\n          pattern_start: 145624,\n          pattern_end: 145637\n        }\n      )\n    }\n    let $1 = norm(yarr, 2.0);\n    let yarr_norm;\n    if ($1 instanceof Ok) {\n      yarr_norm = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        5074,\n        \"cosine_similarity\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 145662,\n          end: 145704,\n          pattern_start: 145673,\n          pattern_end: 145686\n        }\n      )\n    }\n    let denominator = (xarr_norm * yarr_norm);\n    return new Ok(divideFloat(numerator, denominator));\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted cosine similarity between two lists (representing\n * vectors):\n *\n * \\\\[\n * \\frac{\\sum_{i=1}^n w_{i} \\cdot x_i \\cdot y_i}\n * {\\left(\\sum_{i=1}^n w_{i} \\cdot x_i^2\\right)^{\\frac{1}{2}}\n * \\cdot\n * \\left(\\sum_{i=1}^n w_{i} \\cdot y_i^2\\right)^{\\frac{1}{2}}}\n * \\\\; \\in \\\\; \\left[-1, 1\\right]\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists and \\\\(x_i\\\\), \\\\(y_i\\\\) are\n * the values in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * The cosine similarity provides a value between -1 and 1, where 1 means the\n * vectors are in the same direction, -1 means they are in exactly opposite\n * directions, and 0 indicates orthogonality.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/option\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *\n *       let assert Ok(result) =\n *         maths.cosine_similarity_with_weights([\n *           #(1.0, 1.0, 2.0),\n *           #(2.0, 2.0, 3.0),\n *           #(3.0, 3.0, 4.0),\n *         ])\n *       result\n *       |> maths.is_close(1.0, 0.0, tolerance)\n *       |> should.be_true()\n *\n *       let assert Ok(result) =\n *         maths.cosine_similarity_with_weights([\n *           #(-1.0, 1.0, 1.0),\n *           #(-2.0, 2.0, 0.5),\n *           #(-3.0, 3.0, 0.33),\n *         ])\n *       result\n *       |> maths.is_close(-1.0, 0.0, tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function cosine_similarity_with_weights(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let weight_is_negative = $list.any(\n      arr,\n      (tuple) => { return tuple[2] < 0.0; },\n    );\n    if (weight_is_negative) {\n      return new Error(undefined);\n    } else {\n      let numerator = $list.fold(\n        arr,\n        0.0,\n        (acc, tuple) => { return acc + ((tuple[0] * tuple[1]) * tuple[2]); },\n      );\n      let xarr = $list.map(arr, (tuple) => { return [tuple[0], tuple[2]]; });\n      let yarr = $list.map(arr, (tuple) => { return [tuple[1], tuple[2]]; });\n      let $ = norm_with_weights(xarr, 2.0);\n      let xarr_norm;\n      if ($ instanceof Ok) {\n        xarr_norm = $[0];\n      } else {\n        throw makeError(\n          \"let_assert\",\n          FILEPATH,\n          \"gleam_community/maths\",\n          5167,\n          \"cosine_similarity_with_weights\",\n          \"Pattern match failed, no pattern matched the value.\",\n          {\n            value: $,\n            start: 148512,\n            end: 148567,\n            pattern_start: 148523,\n            pattern_end: 148536\n          }\n        )\n      }\n      let $1 = norm_with_weights(yarr, 2.0);\n      let yarr_norm;\n      if ($1 instanceof Ok) {\n        yarr_norm = $1[0];\n      } else {\n        throw makeError(\n          \"let_assert\",\n          FILEPATH,\n          \"gleam_community/maths\",\n          5168,\n          \"cosine_similarity_with_weights\",\n          \"Pattern match failed, no pattern matched the value.\",\n          {\n            value: $1,\n            start: 148578,\n            end: 148633,\n            pattern_start: 148589,\n            pattern_end: 148602\n          }\n        )\n      }\n      let denominator = (xarr_norm * yarr_norm);\n      return new Ok(divideFloat(numerator, denominator));\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Canberra distance between two lists:\n *\n * \\\\[\n * \\sum_{i=1}^n \\frac{\\left| x_i - y_i \\right|}\n * {\\left| x_i \\right| + \\left| y_i \\right|}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists, and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.canberra_distance([])\n *       |> should.be_error()\n *\n *       maths.canberra_distance([#(1.0, -2.0), #(2.0, -1.0)])\n *       |> should.equal(Ok(2.0))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function canberra_distance(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    return new Ok(\n      $list.fold(\n        arr,\n        0.0,\n        (acc, tuple) => {\n          let numerator = $float.absolute_value((tuple[0] - tuple[1]));\n          let denominator = ($float.absolute_value(tuple[0]) + $float.absolute_value(\n            tuple[1],\n          ));\n          return acc + (divideFloat(numerator, denominator));\n        },\n      ),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Canberra distance between two lists:\n *\n * \\\\[\n * \\sum_{i=1}^n w_{i}\\frac{\\left| x_i - y_i \\right|}\n * {\\left| x_i \\right| + \\left| y_i \\right|}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists, and \\\\(x_i, y_i\\\\) are the\n * values in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.canberra_distance_with_weights([])\n *       |> should.be_error()\n *\n *       maths.canberra_distance_with_weights([#(1.0, -2.0, 0.5), #(2.0, -1.0, 1.0)])\n *       |> should.equal(Ok(1.5))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function canberra_distance_with_weights(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let weight_is_negative = $list.any(\n      arr,\n      (tuple) => { return tuple[2] < 0.0; },\n    );\n    if (weight_is_negative) {\n      return new Error(undefined);\n    } else {\n      return new Ok(\n        $list.fold(\n          arr,\n          0.0,\n          (acc, tuple) => {\n            let numerator = $float.absolute_value((tuple[0] - tuple[1]));\n            let denominator = ($float.absolute_value(tuple[0]) + $float.absolute_value(\n              tuple[1],\n            ));\n            return acc + (divideFloat((tuple[2] * numerator), denominator));\n          },\n        ),\n      );\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the Bray-Curtis distance between two lists:\n *\n * \\\\[\n * \\frac{\\sum_{i=1}^n  \\left| x_i - y_i \\right|}\n * {\\sum_{i=1}^n \\left| x_i + y_i \\right|}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists, and \\\\(x_i, y_i\\\\) are the values\n * in the respective input lists indexed by \\\\(i\\\\).\n *\n * The Bray-Curtis distance is in the range \\\\([0, 1]\\\\) if all entries \\\\(x_i, y_i\\\\) are\n * positive.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.braycurtis_distance([])\n *       |> should.be_error()\n *\n *       maths.braycurtis_distance([#(1.0, 3.0), #(2.0, 4.0)])\n *       |> should.equal(Ok(0.4))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function braycurtis_distance(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let numerator = $list.fold(\n      arr,\n      0.0,\n      (acc, tuple) => {\n        return acc + $float.absolute_value((tuple[0] - tuple[1]));\n      },\n    );\n    let denominator = $list.fold(\n      arr,\n      0.0,\n      (acc, tuple) => {\n        return acc + $float.absolute_value((tuple[0] + tuple[1]));\n      },\n    );\n    return new Ok((divideFloat(numerator, denominator)));\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Calculate the weighted Bray-Curtis distance between two lists:\n *\n * \\\\[\n * \\frac{\\sum_{i=1}^n w_{i} \\left| x_i - y_i \\right|}\n * {\\sum_{i=1}^n w_{i}\\left| x_i + y_i \\right|}\n * \\\\]\n *\n * In the formula, \\\\(n\\\\) is the length of the two lists, and \\\\(x_i, y_i\\\\) are the values\n * in the respective input lists indexed by \\\\(i\\\\), while the\n * \\\\(w_i \\in \\mathbb{R}_{+}\\\\) are corresponding positive weights.\n *\n * The Bray-Curtis distance is in the range \\\\([0, 1]\\\\) if all entries \\\\(x_i, y_i\\\\) are\n * positive and \\\\(w_i = 1.0\\\\;\\forall i=1...n\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.braycurtis_distance_with_weights([])\n *       |> should.be_error()\n *\n *       maths.braycurtis_distance_with_weights([#(1.0, 3.0, 0.5), #(2.0, 4.0, 1.0)])\n *       |> should.equal(Ok(0.375))\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function braycurtis_distance_with_weights(arr) {\n  if (arr instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let weight_is_negative = $list.any(\n      arr,\n      (tuple) => { return tuple[2] < 0.0; },\n    );\n    if (weight_is_negative) {\n      return new Error(undefined);\n    } else {\n      let numerator = $list.fold(\n        arr,\n        0.0,\n        (acc, tuple) => {\n          return acc + (tuple[2] * $float.absolute_value((tuple[0] - tuple[1])));\n        },\n      );\n      let denominator = $list.fold(\n        arr,\n        0.0,\n        (acc, tuple) => {\n          return acc + (tuple[2] * $float.absolute_value((tuple[0] + tuple[1])));\n        },\n      );\n      return new Ok((divideFloat(numerator, denominator)));\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Determine if a given value \\\\(x\\\\) is close to or equivalent to a reference value\n * \\\\(y\\\\) based on supplied relative \\\\(r_{tol}\\\\) and absolute \\\\(a_{tol}\\\\) tolerance\n * values. The equivalance of the two given values are then determined based on\n * the equation:\n *\n * \\\\[\n *     \\|x - y\\| \\leq (a_{tol} + r_{tol} \\cdot \\|y\\|)\n * \\\\]\n *\n * `True` is returned if the statement holds, otherwise `False` is returned.\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let value = 99.\n *       let reference_value = 100.\n *       // We set 'absolute_tolerance' and 'relative_tolerance' such that the values are\n *       // equivalent if 'value' is within 1 percent of 'reference_value' +/- 0.1\n *       let relative_tolerance = 0.01\n *       let absolute_tolerance = 0.10\n *       maths.is_close(value, reference_value, relative_tolerance, absolute_tolerance)\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_close(x, y, rtol, atol) {\n  let x$1 = absolute_difference(x, y);\n  let y$1 = atol + (rtol * $float.absolute_value(y));\n  return x$1 <= y$1;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Determine if each value \\\\(x_i\\\\) is close to or equivalent to its corresponding reference value\n * \\\\(y_i\\\\), in a list of value pairs \\\\((x_i, y_i)\\\\), based on supplied relative \\\\(r_{tol}\\\\)\n * and absolute  \\\\(a_{tol}\\\\) tolerance values. The equivalence of each pair \\\\((x_i, y_i)\\\\) is\n * determined by the equation:\n *\n * \\\\[\n *     \\|x_i - y_i\\| \\leq (a_{tol} + r_{tol} \\cdot \\|y_i\\|), \\\\; \\forall i=1,...,n.\n * \\\\]\n *\n * A list of `Bool` values is returned, where each entry indicates if the corresponding pair\n * satisfies the condition. If all conditions are satisfied, the list will contain only `True`\n * values.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/list\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let value = 99.0\n *       let reference_value = 100.0\n *       let xarr = list.repeat(value, 42)\n *       let yarr = list.repeat(reference_value, 42)\n *       let arr = list.zip(xarr, yarr)\n *       // We set 'absolute_tolerance' and 'relative_tolerance' such that\n *       // the values are equivalent if 'value' is within 1 percent of\n *       // 'reference_value' +/- 0.1\n *       let relative_tolerance = 0.01\n *       let absolute_tolerance = 0.1\n *       let assert Ok(result) =\n *         maths.all_close(arr, relative_tolerance, absolute_tolerance)\n *       result\n *       |> list.all(fn(x) { x == True })\n *       |> should.be_true()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function all_close(arr, rtol, atol) {\n  return $list.map(\n    arr,\n    (_use0) => {\n      let x;\n      let y;\n      x = _use0[0];\n      y = _use0[1];\n      return is_close(x, y, rtol, atol);\n    },\n  );\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Determine if a given value \\\\(x\\\\) is fractional, i.e., if it contains a fractional part:\n *\n * \\\\[\n *     x - \\lfloor x \\rfloor > 0\n * \\\\]\n *\n * `True` is returned if the given value is fractional (i.e., it has a non-zero decimal part),\n * otherwise `False` is returned.\n *\n * <details>\n *     <summary>Example</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.is_fractional(0.3333)\n *       |> should.equal(True)\n *\n *       maths.is_fractional(1.0)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_fractional(x) {\n  return (do_ceiling(x) - x) > 0.0;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that determines if a given integer value \\\\(x \\in \\mathbb{Z}\\\\) is a power of\n * another integer value \\\\(y \\in \\mathbb{Z}\\\\), i.e., the function evaluates whether \\\\(x\\\\) can\n * be expressed as \\\\(y^n\\\\) for some integer \\\\(n \\geq 0\\\\), by computing the base-\\\\(y\\\\)\n * logarithm of \\\\(x\\\\):\n *\n * \\\\[\n *     n = \\log_y(x)\n * \\\\]\n *\n * If \\\\(n\\\\) is an integer (i.e., it has no fractional part), then \\\\(x\\\\) is a power of \\\\(y\\\\)\n * and `True` is returned. Otherwise `False` is returned.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       // Check if 4 is a power of 2 (it is)\n *       maths.is_power(4, 2)\n *       |> should.equal(True)\n *\n *       // Check if 5 is a power of 2 (it is not)\n *       maths.is_power(5, 2)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_power(x, y) {\n  let $ = logarithm($int.to_float(x), $int.to_float(y));\n  if ($ instanceof Ok) {\n    let value = $[0];\n    let truncated = round_to_zero(value, 0);\n    let remainder = value - truncated;\n    return remainder === 0.0;\n  } else {\n    return false;\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that tests whether a given integer value \\\\(n \\in \\mathbb{Z}\\\\) is a\n * perfect number. A number is perfect if it is equal to the sum of its proper\n * positive divisors.\n *\n * <details>\n *     <summary>Details</summary>\n *\n *   For example:\n *   - \\\\(6\\\\) is a perfect number since the divisors of 6 are \\\\(1 + 2 + 3 = 6\\\\).\n *   - \\\\(28\\\\) is a perfect number since the divisors of 28 are \\\\(1 + 2 + 4 + 7 + 14 = 28\\\\).\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.is_perfect(6)\n *       |> should.equal(True)\n *\n *       maths.is_perfect(28)\n *       |> should.equal(True)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_perfect(n) {\n  return $int.sum(proper_divisors(n)) === n;\n}\n\nfunction powmod_with_check(base, exponent, modulus) {\n  let $ = (exponent % 2) === 0;\n  if (exponent === 0) {\n    return 1;\n  } else if ($) {\n    let x = powmod_with_check(\n      base,\n      globalThis.Math.trunc(exponent / 2),\n      modulus,\n    );\n    let $1 = remainderInt(x * x, modulus);\n    let $2 = (x !== 1) && (x !== (modulus - 1));\n    if ($2 && $1 === 1) {\n      return 0;\n    } else {\n      return remainderInt(x * x, modulus);\n    }\n  } else {\n    return remainderInt(\n      base * powmod_with_check(base, exponent - 1, modulus),\n      modulus\n    );\n  }\n}\n\nfunction miller_rabin_test(loop$n, loop$k) {\n  while (true) {\n    let n = loop$n;\n    let k = loop$k;\n    if (k === 0) {\n      return true;\n    } else {\n      let random_candidate = 2 + $int.random(n - 2);\n      let $ = powmod_with_check(random_candidate, n - 1, n) === 1;\n      if ($) {\n        loop$n = n;\n        loop$k = k - 1;\n      } else {\n        return $;\n      }\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that tests whether a given integer value \\\\(x \\in \\mathbb{Z}\\\\) is a\n * prime number. A prime number is a natural number greater than 1 that has no\n * positive divisors other than 1 and itself.\n *\n * The function uses the Miller-Rabin primality test to assess if \\\\(x\\\\) is prime.\n * It is a probabilistic test, so it can mistakenly identify a composite number\n * as prime. However, the probability of such errors decreases with more testing\n * iterations (the function uses 64 iterations internally, which is typically\n * more than sufficient). The Miller-Rabin test is particularly useful for large\n * numbers.\n *\n * <details>\n *     <summary>Details</summary>\n *\n *   Examples of prime numbers:\n *   - \\\\(2\\\\) is a prime number since it has only two divisors: \\\\(1\\\\) and \\\\(2\\\\).\n *   - \\\\(7\\\\) is a prime number since it has only two divisors: \\\\(1\\\\) and \\\\(7\\\\).\n *   - \\\\(4\\\\) is not a prime number since it has divisors other than \\\\(1\\\\) and itself, such\n *     as \\\\(2\\\\).\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.is_prime(2)\n *       |> should.equal(True)\n *\n *       maths.is_prime(4)\n *       |> should.equal(False)\n *\n *       // Test the 2nd Carmichael number\n *       maths.is_prime(1105)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_prime(x) {\n  let x$1 = x;\n  if (x$1 < 2) {\n    return false;\n  } else {\n    let x$1 = x;\n    if (x$1 === 2) {\n      return true;\n    } else {\n      return miller_rabin_test(x, 64);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that tests whether a given real number \\\\(x \\in \\mathbb{R}\\\\) is strictly\n * between two other real numbers, \\\\(a,b \\in \\mathbb{R}\\\\), such that \\\\(a < x < b\\\\).\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.is_between(5.5, 5.0, 6.0)\n *       |> should.equal(True)\n *\n *       maths.is_between(5.0, 5.0, 6.0)\n *       |> should.equal(False)\n *\n *       maths.is_between(6.0, 5.0, 6.0)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_between(x, lower, upper) {\n  return (lower < x) && (x < upper);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that tests whether a given integer \\\\(n \\in \\mathbb{Z}\\\\) is divisible by another\n * integer \\\\(d \\in \\mathbb{Z}\\\\), such that \\\\(n \\mod d = 0\\\\).\n *\n * <details>\n *     <summary>Details</summary>\n *\n *   For example:\n *   - \\\\(n = 10\\\\) is divisible by \\\\(d = 2\\\\) because \\\\(10 \\mod 2 = 0\\\\).\n *   - \\\\(n = 7\\\\) is not divisible by \\\\(d = 3\\\\) because \\\\(7 \\mod 3 \\neq 0\\\\).\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.is_divisible(10, 2)\n *       |> should.equal(True)\n *\n *       maths.is_divisible(7, 3)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_divisible(n, d) {\n  return (remainderInt(n, d)) === 0;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * A function that tests whether a given integer \\\\(m \\in \\mathbb{Z}\\\\) is a multiple of another\n * integer \\\\(k \\in \\mathbb{Z}\\\\), such that \\\\(m = k \\cdot q\\\\), with \\\\(q \\in \\mathbb{Z}\\\\).\n *\n * <details>\n *     <summary>Details</summary>\n *\n *   For example:\n *   - \\\\(m = 15\\\\) is a multiple of \\\\(k = 5\\\\) because \\\\(15 = 5 \\cdot 3\\\\).\n *   - \\\\(m = 14\\\\) is not a multiple of \\\\(k = 5\\\\) because \\\\(\\frac{14}{5}\\\\) does not yield an\n *     integer quotient.\n *\n * </details>\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       maths.is_multiple(15, 5)\n *       |> should.equal(True)\n *\n *       maths.is_multiple(14, 5)\n *       |> should.equal(False)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function is_multiple(m, k) {\n  return (remainderInt(m, k)) === 0;\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The error function.\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function erf(x) {\n  let a1 = 0.254829592;\n  let a2 = -0.284496736;\n  let a3 = 1.421413741;\n  let a4 = -1.453152027;\n  let a5 = 1.061405429;\n  let p = 0.3275911;\n  let sign$1 = sign(x);\n  let x$1 = $float.absolute_value(x);\n  let t = divideFloat(1.0, (1.0 + (p * x$1)));\n  let y = 1.0 - ((((((((((a5 * t) + a4) * t) + a3) * t) + a2) * t) + a1) * t) * exponential(\n    (-1.0 * x$1) * x$1,\n  ));\n  return sign$1 * y;\n}\n\nfunction incomplete_gamma_sum(loop$a, loop$x, loop$t, loop$s, loop$n) {\n  while (true) {\n    let a = loop$a;\n    let x = loop$x;\n    let t = loop$t;\n    let s = loop$s;\n    let n = loop$n;\n    if (t === 0.0) {\n      return s;\n    } else {\n      let ns = s + t;\n      let nt = t * (divideFloat(x, (a + n)));\n      loop$a = a;\n      loop$x = x;\n      loop$t = nt;\n      loop$s = ns;\n      loop$n = n + 1.0;\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The lower incomplete gamma function over the real numbers.\n *\n * The implemented incomplete gamma function is evaluated through a power series\n * expansion.\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function incomplete_gamma(a, x) {\n  let $ = (a > 0.0) && (x >= 0.0);\n  if ($) {\n    let $1 = $float.power(x, a);\n    let v;\n    if ($1 instanceof Ok) {\n      v = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6038,\n        \"incomplete_gamma\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 173749,\n          end: 173785,\n          pattern_start: 173760,\n          pattern_end: 173765\n        }\n      )\n    }\n    return new Ok(\n      (v * exponential(-1.0 * x)) * incomplete_gamma_sum(\n        a,\n        x,\n        divideFloat(1.0, a),\n        0.0,\n        1.0,\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\nfunction do_step_range(\n  loop$current,\n  loop$increment,\n  loop$remaining_steps,\n  loop$acc\n) {\n  while (true) {\n    let current = loop$current;\n    let increment = loop$increment;\n    let remaining_steps = loop$remaining_steps;\n    let acc = loop$acc;\n    if (remaining_steps === 0) {\n      return acc;\n    } else {\n      loop$current = current - increment;\n      loop$increment = increment;\n      loop$remaining_steps = remaining_steps - 1;\n      loop$acc = listPrepend(current, acc);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns a list of evenly spaced values within a specified interval\n * `[start, stop)` based on a given increment size.\n *\n * Note that if `increment > 0`, the sequence progresses from `start`  towards `stop`, while if\n * `increment < 0`, the sequence progresses from `start` towards `stop` in reverse.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       maths.step_range(1.0, 5.0, 1.0)\n *       |> should.equal([1.0, 2.0, 3.0, 4.0])\n *\n *       // No points returned since\n *       // start is smaller than stop and the step is positive\n *       maths.step_range(5.0, 1.0, 1.0)\n *       |> should.equal([])\n *\n *       // Points returned since\n *       // start smaller than stop but negative step\n *       maths.step_range(5.0, 1.0, -1.0)\n *       |> should.equal([5.0, 4.0, 3.0, 2.0])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function step_range(start, stop, increment) {\n  let $ = ((start >= stop) && (increment > 0.0)) || ((start <= stop) && (increment < 0.0));\n  if ($) {\n    return toList([]);\n  } else {\n    let _block;\n    let $1 = start <= stop;\n    if ($1) {\n      _block = 1.0;\n    } else {\n      _block = -1.0;\n    }\n    let direction = _block;\n    let increment_abs = $float.absolute_value(increment);\n    let distance = $float.absolute_value(start - stop);\n    let steps = $float.round(divideFloat(distance, increment_abs));\n    let adjusted_stop = stop - (increment_abs * direction);\n    return do_step_range(\n      adjusted_stop,\n      increment_abs * direction,\n      steps,\n      toList([]),\n    );\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function is similar to [`step_range`](#step_range) but instead returns a yielder\n * (lazily evaluated sequence of elements). This function can be used whenever there is a need\n * to generate a larger-than-usual sequence of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder.{Next, Done}\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let range = maths.yield_step_range(1.0, 2.5, 0.5)\n *\n *       let assert Next(element, rest) = yielder.step(range)\n *       should.equal(element, 1.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 1.5)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 2.0)\n *\n *       // We have generated 3 values over the interval [1.0, 2.5)\n *       // in increments of 0.5, so the 4th will be 'Done'\n *       should.equal(yielder.step(rest), Done)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function yield_step_range(start, stop, increment) {\n  let $ = ((start >= stop) && (increment > 0.0)) || ((start <= stop) && (increment < 0.0));\n  if ($) {\n    return $yielder.empty();\n  } else {\n    let _block;\n    let $1 = start <= stop;\n    if ($1) {\n      _block = 1.0;\n    } else {\n      _block = -1.0;\n    }\n    let direction = _block;\n    let increment_abs = $float.absolute_value(increment);\n    let distance = $float.absolute_value(start - stop);\n    let num = $float.round(divideFloat(distance, increment_abs));\n    return $yielder.map(\n      $yielder.range(0, num - 1),\n      (index) => {\n        return start + (($int.to_float(index) * increment_abs) * direction);\n      },\n    );\n  }\n}\n\nfunction do_linear_space(\n  loop$current,\n  loop$increment,\n  loop$remaining_steps,\n  loop$acc\n) {\n  while (true) {\n    let current = loop$current;\n    let increment = loop$increment;\n    let remaining_steps = loop$remaining_steps;\n    let acc = loop$acc;\n    if (remaining_steps === 0) {\n      return acc;\n    } else {\n      loop$current = current - increment;\n      loop$increment = increment;\n      loop$remaining_steps = remaining_steps - 1;\n      loop$acc = listPrepend(current, acc);\n    }\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns a list of linearly spaced points over a specified\n * interval. The endpoint of the interval can optionally be included/excluded. The number of\n * points and whether the endpoint is included determine the spacing between values.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(linspace) = maths.linear_space(10.0, 20.0, 5, True)\n *       let pairs = linspace |> list.zip([10.0, 12.5, 15.0, 17.5, 20.0])\n *       let assert Ok(result) = maths.all_close(pairs, 0.0, tolerance)\n *       result\n *       |> list.all(fn(x) { x == True })\n *       |> should.be_true()\n *\n *       // A negative number of points (-5) does not work\n *       maths.linear_space(10.0, 50.0, -5, True)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function linear_space(start, stop, steps, endpoint) {\n  let _block;\n  let $ = start <= stop;\n  if ($) {\n    _block = 1.0;\n  } else {\n    _block = -1.0;\n  }\n  let direction = _block;\n  let _block$1;\n  if (endpoint) {\n    _block$1 = divideFloat(\n      $float.absolute_value(start - stop),\n      $int.to_float(steps - 1)\n    );\n  } else {\n    _block$1 = divideFloat(\n      $float.absolute_value(start - stop),\n      $int.to_float(steps)\n    );\n  }\n  let increment_abs = _block$1;\n  let _block$2;\n  if (endpoint) {\n    _block$2 = stop;\n  } else {\n    _block$2 = stop - (increment_abs * direction);\n  }\n  let adjusted_stop = _block$2;\n  let $1 = steps > 0;\n  if ($1) {\n    return new Ok(\n      do_linear_space(\n        adjusted_stop,\n        increment_abs * direction,\n        steps,\n        toList([]),\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function is similar to [`linear_space`](#linear_space) but instead returns a yielder\n * (lazily evaluated sequence of elements). This function can be used whenever there is a need\n * to generate a larger-than-usual sequence of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder.{Next, Done}\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(linspace) = maths.yield_linear_space(10.0, 20.0, 5, True)\n *\n *       let assert Next(element, rest) = yielder.step(linspace)\n *       should.equal(element, 10.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 12.5)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 15.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 17.5)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 20.0)\n *\n *       // We have generated 5 values, so the 6th will be 'Done'\n *       should.equal(yielder.step(rest), Done)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function yield_linear_space(start, stop, steps, endpoint) {\n  let _block;\n  let $ = start <= stop;\n  if ($) {\n    _block = 1.0;\n  } else {\n    _block = -1.0;\n  }\n  let direction = _block;\n  let _block$1;\n  if (endpoint) {\n    _block$1 = divideFloat(\n      $float.absolute_value(start - stop),\n      $int.to_float(steps - 1)\n    );\n  } else {\n    _block$1 = divideFloat(\n      $float.absolute_value(start - stop),\n      $int.to_float(steps)\n    );\n  }\n  let increment = _block$1;\n  let $1 = steps > 0;\n  if ($1) {\n    return new Ok(\n      $yielder.map(\n        $yielder.range(0, steps - 1),\n        (index) => {\n          return start + (($int.to_float(index) * increment) * direction);\n        },\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns a list of logarithmically spaced points over a specified\n * interval. The endpoint of the interval can optionally be included/excluded.\n * The number of points, base, and whether the endpoint is included determine\n * the spacing between values.\n *\n * The values in the sequence are computed as powers of the given base, where\n * the exponents are evenly spaced between `start` and `stop`. The `base`\n * parameter must be positive, as negative bases lead to undefined behavior when\n * computing fractional exponents. Similarly, the number of points (`steps`) must\n * be positive; specifying zero or a negative value will result in an error.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(logspace) = maths.logarithmic_space(1.0, 3.0, 3, True, 10.0)\n *       let pairs = logspace |> list.zip([10.0, 100.0, 1000.0])\n *       let assert Ok(result) = maths.all_close(pairs, 0.0, tolerance)\n *       result\n *       |> list.all(fn(x) { x == True })\n *       |> should.be_true()\n *\n *       // A negative number of points (-3) does not work\n *       maths.logarithmic_space(1.0, 3.0, -3, False, 10.0)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function logarithmic_space(start, stop, steps, endpoint, base) {\n  let $ = (steps > 0) && (base > 0.0);\n  if ($) {\n    let $1 = linear_space(start, stop, steps, endpoint);\n    let linspace;\n    if ($1 instanceof Ok) {\n      linspace = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6425,\n        \"logarithmic_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 184951,\n          end: 185019,\n          pattern_start: 184962,\n          pattern_end: 184974\n        }\n      )\n    }\n    return new Ok(\n      $list.map(\n        linspace,\n        (value) => {\n          let $2 = $float.power(base, value);\n          let result;\n          if ($2 instanceof Ok) {\n            result = $2[0];\n          } else {\n            throw makeError(\n              \"let_assert\",\n              FILEPATH,\n              \"gleam_community/maths\",\n              6437,\n              \"logarithmic_space\",\n              \"Pattern match failed, no pattern matched the value.\",\n              {\n                value: $2,\n                start: 185413,\n                end: 185461,\n                pattern_start: 185424,\n                pattern_end: 185434\n              }\n            )\n          }\n          return result;\n        },\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function is similar to [`logarithmic_space`](#logarithmic_space) but instead returns a yielder\n * (lazily evaluated sequence of elements). This function can be used whenever there is a need\n * to generate a larger-than-usual sequence of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder.{Next, Done}\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(logspace) =\n *         maths.yield_logarithmic_space(1.0, 3.0, 3, True, 10.0)\n *\n *       let assert Next(element, rest) = yielder.step(logspace)\n *       should.equal(element, 10.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 100.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 1000.0)\n *\n *       // We have generated 3 values, so the 4th will be 'Done'\n *       should.equal(yielder.step(rest), Done)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function yield_logarithmic_space(start, stop, steps, endpoint, base) {\n  let $ = (steps > 0) && (base > 0.0);\n  if ($) {\n    let $1 = yield_linear_space(start, stop, steps, endpoint);\n    let linspace;\n    if ($1 instanceof Ok) {\n      linspace = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6499,\n        \"yield_logarithmic_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 187219,\n          end: 187293,\n          pattern_start: 187230,\n          pattern_end: 187242\n        }\n      )\n    }\n    return new Ok(\n      $yielder.map(\n        linspace,\n        (value) => {\n          let $2 = $float.power(base, value);\n          let result;\n          if ($2 instanceof Ok) {\n            result = $2[0];\n          } else {\n            throw makeError(\n              \"let_assert\",\n              FILEPATH,\n              \"gleam_community/maths\",\n              6511,\n              \"yield_logarithmic_space\",\n              \"Pattern match failed, no pattern matched the value.\",\n              {\n                value: $2,\n                start: 187691,\n                end: 187739,\n                pattern_start: 187702,\n                pattern_end: 187712\n              }\n            )\n          }\n          return result;\n        },\n      ),\n    );\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function returns a list of a geometric progression between two specified\n * values, where each value is a constant multiple of the previous one. Unlike\n * [`logarithmic_space`](#logarithmic_space), this function allows specifying the starting\n * and ending values (`start` and `stop`) directly, without requiring them to be transformed\n * into exponents.\n *\n * Internally, the function computes the logarithms of `start` and `stop` and generates evenly\n * spaced points in the logarithmic domain (using base 10). These points are then transformed back\n * into their original scale to create a sequence of values that grow multiplicatively.\n *\n * The `start` and `stop` values must be positive, as logarithms are undefined for non-positive\n * values. The number of points (`steps`) must also be positive; specifying zero or a negative\n * value will result in an error.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(tolerance) = float.power(10.0, -6.0)\n *       let assert Ok(logspace) = maths.geometric_space(10.0, 1000.0, 3, True)\n *       let pairs = logspace |> list.zip([10.0, 100.0, 1000.0])\n *       let assert Ok(result) = maths.all_close(pairs, 0.0, tolerance)\n *       result\n *       |> list.all(fn(x) { x == True })\n *       |> should.be_true()\n *\n *       // Input (start and stop can't be less than or equal to 0.0)\n *       maths.geometric_space(0.0, 1000.0, 3, False)\n *       |> should.be_error()\n *\n *       maths.geometric_space(-1000.0, 0.0, 3, False)\n *       |> should.be_error()\n *\n *       // A negative number of points (-3) does not work\n *       maths.geometric_space(10.0, 1000.0, -3, False)\n *       |> should.be_error()\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function geometric_space(start, stop, steps, endpoint) {\n  let $ = ((start <= 0.0) || (stop <= 0.0)) || (steps < 0);\n  if ($) {\n    return new Error(undefined);\n  } else {\n    let $1 = logarithm_10(start);\n    let log_start;\n    if ($1 instanceof Ok) {\n      log_start = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6586,\n        \"geometric_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 190380,\n          end: 190426,\n          pattern_start: 190391,\n          pattern_end: 190404\n        }\n      )\n    }\n    let $2 = logarithm_10(stop);\n    let log_stop;\n    if ($2 instanceof Ok) {\n      log_stop = $2[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6587,\n        \"geometric_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $2,\n          start: 190433,\n          end: 190477,\n          pattern_start: 190444,\n          pattern_end: 190456\n        }\n      )\n    }\n    return logarithmic_space(log_start, log_stop, steps, endpoint, 10.0);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function is similar to [`geometric_space`](#geometric_space) but instead returns a yielder\n * (lazily evaluated sequence of elements). This function can be used whenever there is a need\n * to generate a larger-than-usual sequence of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder.{Next, Done}\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example () {\n *       let assert Ok(logspace) = maths.yield_geometric_space(10.0, 1000.0, 3, True)\n *\n *       let assert Next(element, rest) = yielder.step(logspace)\n *       should.equal(element, 10.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 100.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 1000.0)\n *\n *       // We have generated 3 values, so the 4th will be 'Done'\n *       should.equal(yielder.step(rest), Done)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function yield_geometric_space(start, stop, steps, endpoint) {\n  let $ = ((start <= 0.0) || (stop <= 0.0)) || (steps < 0);\n  if ($) {\n    return new Error(undefined);\n  } else {\n    let $1 = logarithm_10(start);\n    let log_start;\n    if ($1 instanceof Ok) {\n      log_start = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6646,\n        \"yield_geometric_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 192300,\n          end: 192346,\n          pattern_start: 192311,\n          pattern_end: 192324\n        }\n      )\n    }\n    let $2 = logarithm_10(stop);\n    let log_stop;\n    if ($2 instanceof Ok) {\n      log_stop = $2[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6647,\n        \"yield_geometric_space\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $2,\n          start: 192353,\n          end: 192397,\n          pattern_start: 192364,\n          pattern_end: 192376\n        }\n      )\n    }\n    return yield_logarithmic_space(log_start, log_stop, steps, endpoint, 10.0);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * Generates evenly spaced points around a center value. The total span (around the center value)\n * is determined by the `radius` argument of the function.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(symspace) = maths.symmetric_space(0.0, 5.0, 5)\n *       symspace\n *       |> should.equal([-5.0, -2.5, 0.0, 2.5, 5.0])\n *\n *       // A negative radius reverses the order of the values\n *       let assert Ok(symspace) = maths.symmetric_space(0.0, -5.0, 5)\n *       symspace\n *       |> should.equal([5.0, 2.5, 0.0, -2.5, -5.0])\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function symmetric_space(center, radius, steps) {\n  let $ = steps > 0;\n  if ($) {\n    let start = center - radius;\n    let stop = center + radius;\n    return linear_space(start, stop, steps, true);\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The function is similar to [`symmetric_space`](#symmetric_space) but instead returns a yielder\n * (lazily evaluated sequence of elements). This function can be used whenever there is a need\n * to generate a larger-than-usual sequence of elements.\n *\n * <details>\n *     <summary>Example:</summary>\n *\n *     import gleam/yielder.{Next, Done}\n *     import gleeunit/should\n *     import gleam_community/maths\n *\n *     pub fn example() {\n *       let assert Ok(symspace) = maths.yield_symmetric_space(0.0, 5.0, 5)\n *\n *       let assert Next(element, rest) = yielder.step(symspace)\n *       should.equal(element, -5.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, -2.5)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 0.0)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 2.5)\n *\n *       let assert Next(element, rest) = yielder.step(rest)\n *       should.equal(element, 5.0)\n *\n *       // We have generated 5 values, so the 6th will be 'Done'\n *       should.equal(yielder.step(rest), Done)\n *     }\n * </details>\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function yield_symmetric_space(center, radius, steps) {\n  let $ = steps > 0;\n  if ($) {\n    let start = center - radius;\n    let stop = center + radius;\n    return yield_linear_space(start, stop, steps, true);\n  } else {\n    return new Error(undefined);\n  }\n}\n\n/**\n * Compute the Gamma function using an approximation with the same coefficients used by the GNU\n * Scientific Library. The function handles both the reflection formula for `x < 0.5` and the\n * standard Lanczos computation for `x >= 0.5`.\n * \n * @ignore\n */\nfunction gamma_lanczos(x) {\n  let $ = x < 0.5;\n  if ($) {\n    return divideFloat(pi(), (sin(pi() * x) * gamma_lanczos(1.0 - x)));\n  } else {\n    let z = x - 1.0;\n    let x$1 = $list.index_fold(\n      lanczos_p,\n      0.0,\n      (acc, v, index) => {\n        let $1 = index > 0;\n        if ($1) {\n          return acc + (divideFloat(v, (z + $int.to_float(index))));\n        } else {\n          return v;\n        }\n      },\n    );\n    let t = (z + lanczos_g) + 0.5;\n    let $1 = $float.power(2.0 * pi(), 0.5);\n    let v1;\n    if ($1 instanceof Ok) {\n      v1 = $1[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6006,\n        \"gamma_lanczos\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $1,\n          start: 172652,\n          end: 172701,\n          pattern_start: 172663,\n          pattern_end: 172669\n        }\n      )\n    }\n    let $2 = $float.power(t, z + 0.5);\n    let v2;\n    if ($2 instanceof Ok) {\n      v2 = $2[0];\n    } else {\n      throw makeError(\n        \"let_assert\",\n        FILEPATH,\n        \"gleam_community/maths\",\n        6007,\n        \"gamma_lanczos\",\n        \"Pattern match failed, no pattern matched the value.\",\n        {\n          value: $2,\n          start: 172708,\n          end: 172752,\n          pattern_start: 172719,\n          pattern_end: 172725\n        }\n      )\n    }\n    return ((v1 * v2) * exponential(-1.0 * t)) * x$1;\n  }\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The gamma function over the real numbers. The function is essentially equal to\n * the factorial for any positive integer argument: \\\\(\\Gamma(n) = (n - 1)!\\\\)\n *\n * The implemented gamma function is approximated through Lanczos approximation\n * using the same coefficients used by the GNU Scientific Library.\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function gamma(x) {\n  return gamma_lanczos(x);\n}\n\n/**\n * <div style=\"text-align: right;\">\n *     <a href=\"https://github.com/gleam-community/maths/issues\">\n *         <small>Spot a typo? Open an issue!</small>\n *     </a>\n * </div>\n *\n * The beta function over the real numbers:\n *\n * \\\\[\n * \\text{B}(x, y) = \\frac{\\Gamma(x) \\cdot \\Gamma(y)}{\\Gamma(x + y)}\n * \\\\]\n *\n * The beta function is evaluated through the use of the gamma function.\n *\n * <div style=\"text-align: right;\">\n *     <a href=\"#\">\n *         <small>Back to top </small>\n *     </a>\n * </div>\n */\nexport function beta(x, y) {\n  return divideFloat((gamma(x) * gamma(y)), gamma(x + y));\n}\n","//# sourceMappingURL=vector.mjs.map\nimport * as $maths from \"../gleam_community_maths/gleam_community/maths.mjs\";\nimport * as $float from \"../gleam_stdlib/gleam/float.mjs\";\nimport { Ok, CustomType as $CustomType, makeError, divideFloat } from \"./gleam.mjs\";\n\nconst FILEPATH = \"src/vector.gleam\";\n\nexport class Vector extends $CustomType {\n  constructor(x, y, z) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n}\nexport const Vector$Vector = (x, y, z) => new Vector(x, y, z);\nexport const Vector$isVector = (value) => value instanceof Vector;\nexport const Vector$Vector$x = (value) => value.x;\nexport const Vector$Vector$0 = (value) => value.x;\nexport const Vector$Vector$y = (value) => value.y;\nexport const Vector$Vector$1 = (value) => value.y;\nexport const Vector$Vector$z = (value) => value.z;\nexport const Vector$Vector$2 = (value) => value.z;\n\n/**\n * Adds 2 vectors together.\n */\nexport function add(v1, v2) {\n  return new Vector(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n}\n\n/**\n * Subtracts the second vector from the first vector.\n */\nexport function subtract(v1, v2) {\n  return new Vector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n}\n\n/**\n * Computes the dot product of 2 vectors.\n */\nexport function dot(v1, v2) {\n  return ((v1.x * v2.x) + (v1.y * v2.y)) + (v1.z * v2.z);\n}\n\n/**\n * Computes the cross product of 2 vectors.\n */\nexport function cross(v1, v2) {\n  let yz = (v1.y * v2.z) - (v1.z * v2.y);\n  let zx = (v1.z * v2.x) - (v1.x * v2.z);\n  let xy = (v1.x * v2.y) - (v1.y * v2.x);\n  return new Vector(yz, zx, xy);\n}\n\n/**\n * Multiplies the vector by some value.\n */\nexport function multiply(v, mult) {\n  return new Vector(v.x * mult, v.y * mult, v.z * mult);\n}\n\n/**\n * Divides the vector by some value.\n */\nexport function divide(v, mult) {\n  return new Vector(\n    divideFloat(v.x, mult),\n    divideFloat(v.y, mult),\n    divideFloat(v.z, mult),\n  );\n}\n\n/**\n * Computes the square of the magnitude of the vector.\n * Mainly used for performance when computing square roots is unnecessary.\n */\nexport function magnitude_squared(v) {\n  return ((v.x * v.x) + (v.y * v.y)) + (v.z * v.z);\n}\n\n/**\n * Computes the magnitude of the vector.\n */\nexport function magnitude(v) {\n  let $ = $float.square_root(magnitude_squared(v));\n  let mag;\n  if ($ instanceof Ok) {\n    mag = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"vector\",\n      51,\n      \"magnitude\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 1435,\n        end: 1495,\n        pattern_start: 1446,\n        pattern_end: 1453\n      }\n    )\n  }\n  return mag;\n}\n\n/**\n * Computes a vector of the same heading with a magnitude of 1.\n */\nexport function normalize(v) {\n  return divide(v, magnitude(v));\n}\n\n/**\n * Computes a vector of the same heading with maximum magnitude.\n */\nexport function limit(v, limit) {\n  let lim_squared = limit * limit;\n  let $ = magnitude_squared(v);\n  let m = $;\n  if (m <= lim_squared) {\n    return v;\n  } else {\n    return multiply(normalize(v), limit);\n  }\n}\n\n/**\n * Computes the distance between 2 vectors.\n */\nexport function distance(v1, v2) {\n  return magnitude(subtract(v1, v2));\n}\n\n/**\n * Creates a 2d version of the vector.\n */\nexport function vector_2d(v) {\n  return new Vector(v.x, v.y, 0.0);\n}\n\n/**\n * Computes the heading in radians of a vector.\n */\nexport function heading2d(v) {\n  let res = $maths.atan2(v.y, v.x);\n  let r = res;\n  if (r < 0.0) {\n    return r + (2.0 * $maths.pi());\n  } else {\n    return res;\n  }\n}\n\n/**\n * Rotates a vector around the z axis by the given amount in radians.\n */\nexport function rotate2d(v, rotation) {\n  let heading = heading2d(v) + rotation;\n  let mag = magnitude(vector_2d(v));\n  return new Vector($maths.cos(heading) * mag, $maths.sin(heading) * mag, v.z);\n}\n\n/**\n * Create a vector around the z axis by the given amount in radians.\n */\nexport function from_angle2d(rotation) {\n  return rotate2d(new Vector(1.0, 0.0, 0.0), rotation);\n}\n","//# sourceMappingURL=bullet.mjs.map\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport { CustomType as $CustomType } from \"./gleam.mjs\";\nimport * as $utils from \"./utils.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\n/**\n * Represents a fired bullet.\n */\nexport class Bullet extends $CustomType {\n  constructor(position, velocity, belongs_to_player, time_spawned) {\n    super();\n    this.position = position;\n    this.velocity = velocity;\n    this.belongs_to_player = belongs_to_player;\n    this.time_spawned = time_spawned;\n  }\n}\nexport const Bullet$Bullet = (position, velocity, belongs_to_player, time_spawned) =>\n  new Bullet(position, velocity, belongs_to_player, time_spawned);\nexport const Bullet$isBullet = (value) => value instanceof Bullet;\nexport const Bullet$Bullet$position = (value) => value.position;\nexport const Bullet$Bullet$0 = (value) => value.position;\nexport const Bullet$Bullet$velocity = (value) => value.velocity;\nexport const Bullet$Bullet$1 = (value) => value.velocity;\nexport const Bullet$Bullet$belongs_to_player = (value) =>\n  value.belongs_to_player;\nexport const Bullet$Bullet$2 = (value) => value.belongs_to_player;\nexport const Bullet$Bullet$time_spawned = (value) => value.time_spawned;\nexport const Bullet$Bullet$3 = (value) => value.time_spawned;\n\nconst time_alive = 400;\n\nconst bullet_size = 6.0;\n\nconst bullet_speed = 5.0;\n\n/**\n * The amount of damage a bullet fired by the player does.\n */\nexport const player_damage = 10;\n\n/**\n * The amount of damage a bullet fired by an enemy does.\n */\nexport const enemy_damage = 5;\n\nconst player_bullet = \"#3030ff\";\n\nconst enemy_bullet = \"#f4424b\";\n\n/**\n * Advances a bullet forward.\n */\nexport function advance_bullet(bullet) {\n  return new Bullet(\n    $vector.add(bullet.position, bullet.velocity),\n    bullet.velocity,\n    bullet.belongs_to_player,\n    bullet.time_spawned,\n  );\n}\n\n/**\n * Should the bullet be alive.\n */\nexport function is_still_alive(bullet) {\n  return (bullet.time_spawned + time_alive) > $utils.now_in_milliseconds();\n}\n\n/**\n * Checks if the object at the given position with given radius collides with the bullet.\n */\nexport function collides_with(bullet, position, size) {\n  return $vector.distance(bullet.position, position) < ((size / 2.0) + (bullet_size / 2.0));\n}\n\n/**\n * Spawns a bullet at the given position going in the given direction.\n */\nexport function spawn_bullet(position, direction, belongs_to_player) {\n  return new Bullet(\n    position,\n    $vector.multiply($vector.normalize(direction), bullet_speed),\n    belongs_to_player,\n    $utils.now_in_milliseconds(),\n  );\n}\n\n/**\n * Renders the bullet to the screen.\n */\nexport function draw(p, bullet) {\n  $p5.no_stroke(p);\n  let $ = bullet.belongs_to_player;\n  if ($) {\n    $p5.fill(p, player_bullet)\n  } else {\n    $p5.fill(p, enemy_bullet)\n  }\n  return $p5.circle(p, bullet.position.x, bullet.position.y, bullet_size);\n}\n","//# sourceMappingURL=priorityq.mjs.map\nimport * as $list from \"../gleam_stdlib/gleam/list.mjs\";\nimport * as $option from \"../gleam_stdlib/gleam/option.mjs\";\nimport { None, Some } from \"../gleam_stdlib/gleam/option.mjs\";\nimport * as $order from \"../gleam_stdlib/gleam/order.mjs\";\nimport { Gt } from \"../gleam_stdlib/gleam/order.mjs\";\nimport {\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  makeError,\n  isEqual,\n} from \"./gleam.mjs\";\n\nconst FILEPATH = \"src/priorityq.gleam\";\n\nclass PriorityQueue extends $CustomType {\n  constructor(data, cmp) {\n    super();\n    this.data = data;\n    this.cmp = cmp;\n  }\n}\n\nclass Empty extends $CustomType {}\n\nclass NonEmpty extends $CustomType {\n  constructor($0) {\n    super();\n    this[0] = $0;\n  }\n}\n\nclass PairingTree extends $CustomType {\n  constructor(val, children, size) {\n    super();\n    this.val = val;\n    this.children = children;\n    this.size = size;\n  }\n}\n\n/**\n * Creates an empty priority queue.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * new(int.compare) // -> PriorityQueue(Int)\n * ```\n */\nexport function new$(cmp) {\n  return new PriorityQueue(new Empty(), cmp);\n}\n\nfunction from_pairing_tree(tree, cmp) {\n  return new PriorityQueue(new NonEmpty(tree), cmp);\n}\n\nfunction one(val, cmp) {\n  return new PriorityQueue(\n    new NonEmpty(new PairingTree(val, toList([]), 1)),\n    cmp,\n  );\n}\n\n/**\n * Returns whether the priority queue is empty.\n *\n * Runs in constant time.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * new(int.compare) |> is_empty() // -> True\n * from_list([0], int.compare) |> is_empty() // -> False\n * ```\n */\nexport function is_empty(pq) {\n  return pq.data instanceof Empty;\n}\n\n/**\n * Returns the number of elements in the priority queue.\n *\n * Runs in constant time.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * from_list([1, 2, 3], int.compare) |> size() // -> 3\n * ```\n */\nexport function size(pq) {\n  let $ = pq.data;\n  if ($ instanceof Empty) {\n    return 0;\n  } else {\n    let tree = $[0];\n    return tree.size;\n  }\n}\n\n/**\n * Returns the maximum value in the priority queue.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * new(int.compare) |> peek() // -> None\n * from_list([1, 10, 5], int.compare) |> peek() // -> 10\n * ```\n */\nexport function peek(pq) {\n  let $ = pq.data;\n  if ($ instanceof Empty) {\n    return new None();\n  } else {\n    let tree = $[0];\n    return new Some(tree.val);\n  }\n}\n\nfunction merge(pq1, pq2) {\n  let $ = isEqual(pq1.cmp, pq2.cmp);\n  if ($) {\n    let $1 = pq1.data;\n    let $2 = pq2.data;\n    if ($1 instanceof Empty) {\n      return pq2;\n    } else if ($2 instanceof Empty) {\n      return pq1;\n    } else {\n      let tree1 = $1[0];\n      let tree2 = $2[0];\n      let new_size = tree1.size + tree2.size;\n      let $3 = pq1.cmp(tree1.val, tree2.val);\n      if ($3 instanceof Gt) {\n        return new PriorityQueue(\n          new NonEmpty(\n            new PairingTree(\n              tree1.val,\n              listPrepend(tree2, tree1.children),\n              new_size,\n            ),\n          ),\n          pq1.cmp,\n        );\n      } else {\n        return new PriorityQueue(\n          new NonEmpty(\n            new PairingTree(\n              tree2.val,\n              listPrepend(tree1, tree2.children),\n              new_size,\n            ),\n          ),\n          pq1.cmp,\n        );\n      }\n    }\n  } else {\n    throw makeError(\n      \"panic\",\n      FILEPATH,\n      \"priorityq\",\n      118,\n      \"merge\",\n      \"inconsistent cmp function\",\n      {}\n    )\n  }\n}\n\n/**\n * Pushes a value into the priority queue.\n *\n * Runs in constant time.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * new(int.compare) |> push(10) // -> PriorityQueue(Int)\n * ```\n */\nexport function push(pq, val) {\n  return merge(one(val, pq.cmp), pq);\n}\n\n/**\n * Creates a priority queue from a list.\n *\n * Runs in linear time.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * from_list([1, 10, 5], int.compare) // -> PriorityQueue(Int)\n * ```\n */\nexport function from_list(ls, cmp) {\n  let _pipe = new$(cmp);\n  return ((_capture) => { return $list.fold(ls, _capture, push); })(_pipe);\n}\n\nfunction merge_pairs(trees, cmp) {\n  if (trees instanceof $Empty) {\n    return new PriorityQueue(new Empty(), cmp);\n  } else {\n    let $ = trees.tail;\n    if ($ instanceof $Empty) {\n      let tree = trees.head;\n      return from_pairing_tree(tree, cmp);\n    } else {\n      let tree1 = trees.head;\n      let tree2 = $.head;\n      let rest = $.tail;\n      let _pipe = merge(\n        from_pairing_tree(tree1, cmp),\n        from_pairing_tree(tree2, cmp),\n      );\n      return merge(_pipe, merge_pairs(rest, cmp));\n    }\n  }\n}\n\n/**\n * Pops the maximum value from the priority queue.\n *\n * Runs in amortized logarithmic time.\n *\n * ## Examples\n *\n * ```gleam\n * import gleam/int\n *\n * from_list([0]) |> pop() // -> PriorityQueue(Int)\n * ```\n */\nexport function pop(pq) {\n  let $ = pq.data;\n  if ($ instanceof Empty) {\n    return pq;\n  } else {\n    let tree = $[0];\n    return merge_pairs(tree.children, pq.cmp);\n  }\n}\n","// A seed is just a pair [state, step]\n\nexport function new_seed(from) {\n  const [state, step] = next([0, 1_013_904_223]);\n  const new_state = (state + from) >>> 0;\n  return next([new_state, step]);\n}\n\nfunction next(seed) {\n  const [state, step] = seed;\n  const new_state = (state * 1_664_525 + step) >>> 0;\n  return [new_state, step];\n}\n\nexport function seed_to_int(seed) {\n  const [state, _step] = seed;\n  const shifted_state = state >>> ((state >>> 28) + 4);\n  const word = (state ^ shifted_state) * 277_803_737;\n  return ((word >>> 22) ^ word) >>> 0;\n}\n\nexport function random_int(seed, from, to) {\n  const range = to - from + 1;\n  const is_power_of_2 = ((range - 1) & range) === 0;\n  if (is_power_of_2) {\n    const number = ((range - 1) & seed_to_int(seed)) >>> 0;\n    return [number + from, next(seed)];\n  } else {\n    const threshold = (-range >>> 0) % range >>> 0;\n    let iteration_seed = seed;\n    let x = undefined;\n    do {\n      x = seed_to_int(iteration_seed);\n      iteration_seed = next(iteration_seed);\n    } while (x < threshold);\n    return [from + (x % range), iteration_seed];\n  }\n}\n\nexport function random_float(seed, from, to) {\n  const new_seed = next(seed);\n  const first_number = seed_to_int(seed);\n  const second_number = seed_to_int(new_seed);\n\n  const high = 0x03ffffff & first_number;\n  const low = 0x07ffffff & second_number;\n  const value = (high * 134217728.0 + low) / 9007199254740992.0;\n\n  const range = to - from;\n  const scaled = value * range + from;\n  return [scaled, next(new_seed)];\n}\n","//# sourceMappingURL=seed.mjs.map\nimport * as $int from \"../../gleam_stdlib/gleam/int.mjs\";\nimport { new_seed as new$ } from \"../prng_ffi.mjs\";\n\nexport { new$ };\n\n/**\n * Creates a new random seed. You can use it when you don't care about\n * having reproducible results and just need to get some values out of a\n * generator using the `random.step` function.\n */\nexport function random() {\n  return new$($int.random(4_294_967_296));\n}\n","//# sourceMappingURL=random.mjs.map\nimport * as $bit_array from \"../../gleam_stdlib/gleam/bit_array.mjs\";\nimport * as $bool from \"../../gleam_stdlib/gleam/bool.mjs\";\nimport * as $dict from \"../../gleam_stdlib/gleam/dict.mjs\";\nimport * as $float from \"../../gleam_stdlib/gleam/float.mjs\";\nimport * as $int from \"../../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../../gleam_stdlib/gleam/list.mjs\";\nimport * as $order from \"../../gleam_stdlib/gleam/order.mjs\";\nimport { Eq, Gt, Lt } from \"../../gleam_stdlib/gleam/order.mjs\";\nimport * as $pair from \"../../gleam_stdlib/gleam/pair.mjs\";\nimport * as $set from \"../../gleam_stdlib/gleam/set.mjs\";\nimport * as $string from \"../../gleam_stdlib/gleam/string.mjs\";\nimport * as $yielder from \"../../gleam_yielder/gleam/yielder.mjs\";\nimport {\n  Ok,\n  Error,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  makeError,\n} from \"../gleam.mjs\";\nimport * as $seed from \"../prng/seed.mjs\";\nimport { random_int, random_float } from \"../prng_ffi.mjs\";\n\nconst FILEPATH = \"src/prng/random.gleam\";\n\nclass Generator extends $CustomType {\n  constructor(step) {\n    super();\n    this.step = step;\n  }\n}\n\n/**\n * The underlying algorith will work best for integers in the inclusive range\n * going from `min_int` up to `max_int`.\n *\n * It can generate values outside of that range, but they are \"not as random\".\n */\nexport const min_int = -2_147_483_648;\n\n/**\n * The underlying algorith will work best for integers in the inclusive range\n * going from `min_int` up to `max_int`.\n *\n * It can generate values outside of that range, but they are \"not as random\".\n */\nexport const max_int = 2_147_483_647;\n\n/**\n * Steps a `Generator(a)` producing a random value of type `a` using the given\n * seed as the source of randomness.\n *\n * The stepping logic is completely deterministic. This means that, given a\n * seed and a generator, you'll always get the same result.\n *\n * This is why this function also returns a new seed that can be used to make\n * subsequent calls to `step` to get other random values.\n *\n * Stepping a generator by hand can be quite cumbersome, so I recommend you\n * try [`to_yielder`](#to_yielder),\n * [`to_random_yielder`](#to_random_yielder), or [`sample`](#sample) instead.\n *\n * ## Examples\n *\n * ```gleam\n * let initial_seed = seed.new(11)\n * let dice_roll = random.int(1, 6)\n * let #(first_roll, new_seed) = random.step(dice_roll, initial_seed)\n * let #(second_roll, _) = random.step(dice_roll, new_seed)\n *\n * #(first_roll, second_roll)\n * // -> #(3, 2)\n * ```\n */\nexport function step(generator, seed) {\n  return generator.step(seed);\n}\n\n/**\n * Generates a single value using the given generator and seed.\n *\n * This is just a shorthand for the `step` function that drops the new\n * seed. It can be useful if you just need to get a single value out of\n * a generator and need the result to be reproducible.\n */\nexport function sample(generator, seed) {\n  return step(generator, seed)[0];\n}\n\n/**\n * Turns the given generator into an infinite stream of random values generated\n * with it.\n *\n * `seed` is the seed used to get the initial random value and start the\n * infinite sequence.\n *\n * If you don't care about the initial seed and reproducibility is not your\n * goal, you can use `to_random_yielder` which works like this function and\n * randomly picks the initial seed.\n */\nexport function to_yielder(generator, seed) {\n  return $yielder.unfold(\n    seed,\n    (seed) => {\n      let $ = step(generator, seed);\n      let value;\n      let new_seed;\n      value = $[0];\n      new_seed = $[1];\n      return new $yielder.Next(value, new_seed);\n    },\n  );\n}\n\n/**\n * Turns the given generator into an infinite stream of random values generated\n * with it.\n *\n * The initial seed is chosen randomly so you won't have control over which\n * values are generated and may get different results each time you call this\n * function.\n *\n * If you want to have control over the initial seed used to get the infinite\n * sequence of values, you can use `to_yielder`.\n */\nexport function to_random_yielder(generator) {\n  return to_yielder(generator, $seed.random());\n}\n\n/**\n * Generates a single value using the given generator.\n *\n * The initial seed is chosen randomly so you won't have control over which\n * value is generated and may get different results each time you call this\n * function.\n *\n * This is useful if you want to quickly get a value out of a generator and\n * do not care about reproducibility (if you want to decide which seed is\n * used for the generation process you'll have to use `random.step`).\n *\n * ## Examples\n *\n * Imagine you want to perform some action, say only 40% of the times.\n * Your code may look like this:\n *\n * ```gleam\n * let probability = random.float(0.0, 1.0)\n * case random.random_sample(probability) <= 0.4 {\n *   True -> perform_action()\n *   False -> Nil // do nothing\n * }\n * ```\n */\nexport function random_sample(generator) {\n  let $ = $yielder.first(to_random_yielder(generator));\n  let result;\n  if ($ instanceof Ok) {\n    result = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"prng/random\",\n      196,\n      \"random_sample\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 6431,\n        end: 6498,\n        pattern_start: 6442,\n        pattern_end: 6452\n      }\n    )\n  }\n  return result;\n}\n\nfunction sort_ascending(one, other, compare) {\n  let $ = compare(one, other);\n  if ($ instanceof Lt) {\n    return [one, other];\n  } else if ($ instanceof Eq) {\n    return [one, other];\n  } else {\n    return [other, one];\n  }\n}\n\n/**\n * Generates integers in the given inclusive range.\n *\n * ## Examples\n *\n * Say you want to model the outcome of a dice, you could use `int` like this:\n *\n * ```gleam\n * let dice_roll = random.int(1, 6)\n * ```\n */\nexport function int(from, to) {\n  return new Generator(\n    (seed) => {\n      let $ = sort_ascending(from, to, $int.compare);\n      let low;\n      let high;\n      low = $[0];\n      high = $[1];\n      return random_int(seed, low, high);\n    },\n  );\n}\n\n/**\n * Generates floating point numbers in the given inclusive range.\n *\n * ## Examples\n *\n * ```gleam\n * let probability = random.float(0.0, 1.0)\n * ```\n */\nexport function float(from, to) {\n  return new Generator(\n    (seed) => {\n      let $ = sort_ascending(from, to, $float.compare);\n      let low;\n      let high;\n      low = $[0];\n      high = $[1];\n      return random_float(seed, low, high);\n    },\n  );\n}\n\n/**\n * Always generates the given value, no matter the seed used.\n *\n * ## Examples\n *\n * ```gleam\n * let always_eleven = random.constant(11)\n * random.random_sample(always_eleven)\n * // -> 11\n * ```\n */\nexport function constant(value) {\n  return new Generator((seed) => { return [value, seed]; });\n}\n\nfunction get_by_weight(loop$first, loop$others, loop$countdown) {\n  while (true) {\n    let first = loop$first;\n    let others = loop$others;\n    let countdown = loop$countdown;\n    let weight;\n    let value;\n    weight = first[0];\n    value = first[1];\n    if (others instanceof $Empty) {\n      return value;\n    } else {\n      let second = others.head;\n      let rest = others.tail;\n      let positive_weight = $float.absolute_value(weight);\n      let $ = $float.compare(countdown, positive_weight);\n      if ($ instanceof Lt) {\n        return value;\n      } else if ($ instanceof Eq) {\n        return value;\n      } else {\n        loop$first = second;\n        loop$others = rest;\n        loop$countdown = countdown - positive_weight;\n      }\n    }\n  }\n}\n\nfunction do_fixed_size_list(loop$acc, loop$seed, loop$generator, loop$length) {\n  while (true) {\n    let acc = loop$acc;\n    let seed = loop$seed;\n    let generator = loop$generator;\n    let length = loop$length;\n    let $ = length <= 0;\n    if ($) {\n      return [acc, seed];\n    } else {\n      let $1 = step(generator, seed);\n      let value;\n      let seed$1;\n      value = $1[0];\n      seed$1 = $1[1];\n      loop$acc = listPrepend(value, acc);\n      loop$seed = seed$1;\n      loop$generator = generator;\n      loop$length = length - 1;\n    }\n  }\n}\n\n/**\n * Generates a lists of a fixed size; its values are generated using the\n * given generator.\n *\n * ## Examples\n *\n * Imagine you're modelling a game of\n * [Risk](https://en.wikipedia.org/wiki/Risk_(game)); when a player \"attacks\"\n * they can roll three dice. You may model that outcome using `fixed_size_list`\n * like this:\n *\n * ```gleam\n * let dice_roll = random.int(1, 6)\n * let attack_outcome = random.fixed_size_list(dice_roll, 3)\n * ```\n */\nexport function fixed_size_list(generator, length) {\n  return new Generator(\n    (seed) => { return do_fixed_size_list(toList([]), seed, generator, length); },\n  );\n}\n\n/**\n * Transforms a generator into another one based on its generated values.\n *\n * The random value generated by the given generator is fed into the `do`\n * function and the returned generator is used as the new generator.\n *\n * ## Examples\n *\n * `then` is a really powerful function, almost all functions exposed by this\n * library could be defined in term of it!\n * Take as an example `map`, it can be implemented like this:\n *\n * ```gleam\n * fn map(generator: Generator(a), with fun: fn(a) -> b) -> Generator(b) {\n *   random.then(generator, fn(value) {\n *     random.constant(fun(value))\n *   })\n * }\n * ```\n *\n * Notice how the `do` function needs to return a `Generator(b)`, you can\n * achieve that by wrapping any constant value with the `random.constant`\n * generator.\n *\n * > Code written with `then` can gain a lot in readability if you use the\n * > `use` syntax, especially if it has some deep nesting. As an example, this\n * > is how you can rewrite the previous example taking advantage of `use`:\n * >\n * > ```gleam\n * > fn map(generator: Generator(a), with fun: fn(a) -> b) -> Generator(b) {\n * >   use value <- random.then(generator)\n * >   random.constant(fun(value))\n * > }\n * > ```\n */\nexport function then$(generator, generator_from) {\n  return new Generator(\n    (seed) => {\n      let $ = step(generator, seed);\n      let value;\n      let seed$1;\n      value = $[0];\n      seed$1 = $[1];\n      let _pipe = generator_from(value);\n      return step(_pipe, seed$1);\n    },\n  );\n}\n\n/**\n * Generates a list with a random size with at most 32 items.\n * Each item is generated using the given generator.\n *\n * This is similar to `fixed_size_list` with the difference that the size\n * is chosen randomly.\n */\nexport function list(generator) {\n  return then$(\n    int(0, 32),\n    (size) => { return fixed_size_list(generator, size); },\n  );\n}\n\n/**\n * Transforms the values produced by a generator using the given function.\n *\n * ## Examples\n *\n * Imagine you want to make a generator for boolean values that returns\n * `True` and `False` with the same probability. You could do that using `map`\n * like this:\n *\n * ```gleam\n * let bool_generator = random.int(1, 2) |> random.map(fn(n) { n == 1 })\n * ```\n *\n * Here `map` allows you to transform the values produced by the initial\n * integer generator - either 1 or 2 - into boolean values: when the original\n * generator produces a 1, `bool_generator` will produce `True`; when the\n * original generator produces a 2, `bool_generator` will produce `False`.\n */\nexport function map(generator, fun) {\n  return new Generator(\n    (seed) => {\n      let $ = step(generator, seed);\n      let value;\n      let seed$1;\n      value = $[0];\n      seed$1 = $[1];\n      return [fun(value), seed$1];\n    },\n  );\n}\n\n/**\n * Generates values from the given ones with a weighted probability.\n *\n * This generator can guarantee to produce values since it always takes at\n * least one item (as its first argument); if it were to accept just a list of\n * options, it could be called like this:\n *\n * ```gleam\n * weighted([])\n * ```\n *\n * In which case it would be impossible to actually produce any value: none was\n * provided!\n *\n * ## Examples\n *\n * Given the following type to model the outcome of a coin flip:\n *\n * ```gleam\n * pub type CoinFlip {\n *   Heads\n *   Tails\n * }\n * ```\n *\n * You could write a generator for a loaded coin that lands on head 75% of the\n * times like this:\n *\n * ```gleam\n * let loaded_coin = random.weighted(#(0.75, Heads), [#(0.25, Tails)])\n * ```\n *\n * In this example the weights add up to 1, but you could use any number: the\n * weights get added up to a `total` and the probability of each option is its\n * `weight` / `total`.\n */\nexport function weighted(first, others) {\n  let normalise = (pair) => { return $float.absolute_value($pair.first(pair)); };\n  let total = normalise(first) + $float.sum($list.map(others, normalise));\n  return map(\n    float(0.0, total),\n    (_capture) => { return get_by_weight(first, others, _capture); },\n  );\n}\n\n/**\n * This function works exactly like `weighted` but will return an `Error(Nil)`\n * if the provided argument is an empty list since the generator wouldn't be\n * able to produce any value in that case.\n *\n * It generates values from the given list with a weighted probability.\n *\n * ## Examples\n *\n * ```gleam\n * random.try_weighted([])\n * // -> Error(Nil)\n * ```\n *\n * For example if you consider the following type definition to model color:\n *\n * ```gleam\n * type CoinFlip {\n *   Heads\n *   Tails\n * }\n * ```\n *\n * This call of `try_weighted` will produce a generator wrapped in an `Ok`:\n *\n * ```gleam\n * let assert Ok(coin_1) =\n *   random.try_weighted([#(0.75, Heads), #(0.25, Tails)])\n * let coin_2 = random.uniform(#(0.75, Heads), [#(0.25, Tails)])\n * ```\n *\n * The generators `coin_1` and `coin_2` will behave exactly the same.\n */\nexport function try_weighted(options) {\n  if (options instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let first = options.head;\n    let rest = options.tail;\n    return new Ok(weighted(first, rest));\n  }\n}\n\n/**\n * Combines two generators into a single one. The resulting generator produces\n * values obtained by applying `fun` to the values generated by the given\n * generators.\n *\n * ##Examples\n *\n * Imagine you need to generate random points in a 2D space:\n *\n * ```gleam\n * pub type Point {\n *   Point(x: Float, y: Float)\n * }\n * ```\n *\n * You can compose two basic generators into a `Point` generator using `map2`:\n *\n * ```gleam\n * let x_generator = random.float(-1.0, 1.0)\n * let y_generator = random.float(-1.0, 1.0)\n * let point_generator = map2(x_generator, y_generator, Point)\n * ```\n *\n * > Notice how you could get the same result using `then`:\n * >\n * > ```gleam\n * > pub fn point_generator() -> Generator(Point) {\n * >   use x <- random.then(random.float(-1.0, 1.0))\n * >   use y <- random.then(random.float(-1.0, 1.0))\n * >   random.constant(Point(x, y))\n * > }\n * > ```\n * >\n * > the `use` syntax paired with `then` may be confusing for other people\n * > reading your code, especially Gleam newcomers.\n * >\n * > Usually `map2`/`map3`/... will be more than enough if you just need to\n * > combine simple generators into more complex ones.\n */\nexport function map2(one, other, fun) {\n  return new Generator(\n    (seed) => {\n      let $ = step(one, seed);\n      let a;\n      let seed$1;\n      a = $[0];\n      seed$1 = $[1];\n      let $1 = step(other, seed$1);\n      let b;\n      let seed$2;\n      b = $1[0];\n      seed$2 = $1[1];\n      return [fun(a, b), seed$2];\n    },\n  );\n}\n\n/**\n * Generates pairs of values obtained by combining the values produced by the\n * given generators.\n *\n * ## Examples\n *\n * ```gleam\n * let one_to_five = random.int(1, 5)\n * let probability = random.float(0.0, 1.0)\n * let ints_and_floats = random.pair(one_to_five, probability)\n *\n * random.random_sample(ints_and_floats)\n * // -> #(3, 0.22)\n * ```\n */\nexport function pair(one, other) {\n  return map2(one, other, $pair.new$);\n}\n\n/**\n * Generates values from the given ones with an equal probability.\n *\n * This generator can guarantee to produce values since it always takes at\n * least one item (as its first argument); if it were to accept just a list of\n * options, it could be called like this:\n *\n * ```gleam\n * uniform([])\n * ```\n *\n * In which case it would be impossible to actually produce any value: none was\n * provided!\n *\n * ## Examples\n *\n * Given the following type to model colors:\n *\n * ```gleam\n * pub type Color {\n *   Red\n *   Green\n *   Blue\n * }\n * ```\n *\n * You could write a generator that returns each color with an equal\n * probability (~33%) each color like this:\n *\n * ```gleam\n * let color = random.uniform(Red, [Green, Blue])\n * ```\n */\nexport function uniform(first, others) {\n  return weighted(\n    [1.0, first],\n    $list.map(others, (_capture) => { return $pair.new$(1.0, _capture); }),\n  );\n}\n\n/**\n * This function works exactly like `uniform` but will return an `Error(Nil)`\n * if the provided argument is an empty list since the generator wouldn't be\n * able to produce any value in that case.\n *\n * It generates values from the given list with equal probability.\n *\n * ## Examples\n *\n * ```gleam\n * random.try_uniform([])\n * // -> Error(Nil)\n * ```\n *\n * For example if you consider the following type definition to model color:\n *\n * ```gleam\n * type Color {\n *   Red\n *   Green\n *   Blue\n * }\n * ```\n *\n * This call of `try_uniform` will produce a generator wrapped in an `Ok`:\n *\n * ```gleam\n * let assert Ok(color_1) = random.try_uniform([Red, Green, Blue])\n * let color_2 = random.uniform(Red, [Green, Blue])\n * ```\n *\n * The generators `color_1` and `color_2` will behave exactly the same.\n */\nexport function try_uniform(options) {\n  if (options instanceof $Empty) {\n    return new Error(undefined);\n  } else {\n    let first = options.head;\n    let rest = options.tail;\n    return new Ok(uniform(first, rest));\n  }\n}\n\n/**\n * Generates two values with equal probability.\n *\n * This is a shorthand for `random.uniform(one, [other])`, but can read better\n * when there's only two choices.\n *\n * ## Examples\n *\n * Given the following type to model the outcome of a coin flip:\n *\n * ```gleam\n * pub type CoinFlip {\n *   Heads\n *   Tails\n * }\n * ```\n *\n * You can write a generator for coin flip outcomes like this:\n *\n * ```gleam\n * let flip = random.choose(Heads, Tails)\n * ```\n */\nexport function choose(one, other) {\n  return uniform(one, toList([other]));\n}\n\n/**\n * Combines three generators into a single one. The resulting generator\n * produces values obtained by applying `fun` to the values generated by the\n * given generators.\n *\n * ## Examples\n *\n * Imagine you're writing a generator for random enemies in a game you're\n * making:\n *\n * ```gleam\n * pub type Enemy {\n *   Enemy(health: Int, attack: Int, defense: Int)\n * }\n * ```\n *\n * Each enemy starts with a random health (that can go from 50 to 100) and\n * random values for the `attack` and `defense` stats (each can be in a range\n * from 1 to 5):\n *\n * ```gleam\n * let health_generator = random.int(50, 100)\n * let attack_generator = random.int(1, 5)\n * let defense_generator = random.int(1, 5)\n *\n * let enemy_generator =\n *   random.map3(\n *     health_generator,\n *     attack_generator,\n *     defense_generator,\n *     Enemy,\n *   )\n * ```\n */\nexport function map3(one, two, three, fun) {\n  return new Generator(\n    (seed) => {\n      let $ = step(one, seed);\n      let a;\n      let seed$1;\n      a = $[0];\n      seed$1 = $[1];\n      let $1 = step(two, seed$1);\n      let b;\n      let seed$2;\n      b = $1[0];\n      seed$2 = $1[1];\n      let $2 = step(three, seed$2);\n      let c;\n      let seed$3;\n      c = $2[0];\n      seed$3 = $2[1];\n      return [fun(a, b, c), seed$3];\n    },\n  );\n}\n\n/**\n * Combines four generators into a single one. The resulting generator\n * produces values obtained by applying `fun` to the values generated by the\n * given generators.\n */\nexport function map4(one, two, three, four, fun) {\n  return new Generator(\n    (seed) => {\n      let $ = step(one, seed);\n      let a;\n      let seed$1;\n      a = $[0];\n      seed$1 = $[1];\n      let $1 = step(two, seed$1);\n      let b;\n      let seed$2;\n      b = $1[0];\n      seed$2 = $1[1];\n      let $2 = step(three, seed$2);\n      let c;\n      let seed$3;\n      c = $2[0];\n      seed$3 = $2[1];\n      let $3 = step(four, seed$3);\n      let d;\n      let seed$4;\n      d = $3[0];\n      seed$4 = $3[1];\n      return [fun(a, b, c, d), seed$4];\n    },\n  );\n}\n\n/**\n * Combines five generators into a single one. The resulting generator\n * produces values obtained by applying `fun` to the values generated by the\n * given generators.\n *\n * > There's no `map6`, `map7`, and so on. If you feel like you need to compose\n * > together even more generators, you can use the `random.then` function.\n */\nexport function map5(one, two, three, four, five, fun) {\n  return new Generator(\n    (seed) => {\n      let $ = step(one, seed);\n      let a;\n      let seed$1;\n      a = $[0];\n      seed$1 = $[1];\n      let $1 = step(two, seed$1);\n      let b;\n      let seed$2;\n      b = $1[0];\n      seed$2 = $1[1];\n      let $2 = step(three, seed$2);\n      let c;\n      let seed$3;\n      c = $2[0];\n      seed$3 = $2[1];\n      let $3 = step(four, seed$3);\n      let d;\n      let seed$4;\n      d = $3[0];\n      seed$4 = $3[1];\n      let $4 = step(five, seed$4);\n      let e;\n      let seed$5;\n      e = $4[0];\n      seed$5 = $4[1];\n      return [fun(a, b, c, d, e), seed$5];\n    },\n  );\n}\n\n/**\n * Generates Strings with the given number number of UTF code points.\n *\n * >  The generated codepoints will be in the range from 0 (inclusive) to\n * > 1023 (inclusive). If you feel like these strings are not enough for your\n * > needs, please open an issue! I'd love to hear your use case and improve\n * > the package.\n */\nexport function fixed_size_string(size) {\n  let _pipe = fixed_size_list(utf_codepoint_in_range(0, 1023), size);\n  return map(_pipe, $string.from_utf_codepoints);\n}\n\n/**\n * I'm not exposing this function because, if one is not careful with the range,\n * it might lead to a nasty infinite loop.\n * When I come up with a better alternative I might make a similar API public,\n * for now, if someone wants to do something unsafe they will have to\n * manually reimplement it.\n * \n * @ignore\n */\nfunction utf_codepoint_in_range(lower, upper) {\n  return then$(\n    int(lower, upper),\n    (raw_codepoint) => {\n      let $ = $string.utf_codepoint(raw_codepoint);\n      if ($ instanceof Ok) {\n        let codepoint = $[0];\n        return constant(codepoint);\n      } else {\n        return utf_codepoint_in_range(lower, upper);\n      }\n    },\n  );\n}\n\n/**\n * Generates Strings with a random number of UTF code points, between\n * 0 (included) and 32 (included).\n *\n * This is similar to `fixed_size_string`, with the difference that the\n * size is randomly generated as well.\n */\nexport function string() {\n  return then$(int(0, 32), (size) => { return fixed_size_string(size); });\n}\n\n/**\n * Generates `BitArray`s with a random size.\n */\nexport function bit_array() {\n  return map(string(), $bit_array.from_string);\n}\n\n/**\n * Generates a `Set(a)` where each item is generated using the provided\n * generator.\n *\n * This is similar to `fixed_size_set` with the difference that the set is\n * going to have a random size between 0 (inclusive) and 32 (inclusive).\n */\nexport function set(generator) {\n  return then$(\n    int(0, 32),\n    (size) => { return fixed_size_set(generator, size); },\n  );\n}\n\n/**\n * Generates a `Set(a)` where each item is generated using the provided\n * generator.\n *\n * >  This function makes a best effort at generating a set with exactly the\n * > specified number of items, but beware that it may contain less items if\n * > the given generator cannot generate enough distinct values.\n */\nexport function fixed_size_set(generator, size) {\n  let _pipe = $int.max(size, 0);\n  return ((_capture) => {\n    return do_fixed_size_set(generator, _capture, 0, 0, $set.new$());\n  })(_pipe);\n}\n\nfunction do_fixed_size_set(\n  generator,\n  size,\n  unique_items,\n  consecutive_attempts,\n  acc\n) {\n  let has_required_size = unique_items === size;\n  return $bool.guard(\n    has_required_size,\n    constant(acc),\n    () => {\n      let has_reached_maximum_attempts = consecutive_attempts >= 10;\n      return $bool.guard(\n        has_reached_maximum_attempts,\n        constant(acc),\n        () => {\n          return then$(\n            generator,\n            (item) => {\n              let $ = $set.contains(acc, item);\n              if ($) {\n                let _pipe = (consecutive_attempts + 1);\n                return ((_capture) => {\n                  return do_fixed_size_set(\n                    generator,\n                    size,\n                    unique_items,\n                    _capture,\n                    acc,\n                  );\n                })(_pipe);\n              } else {\n                let _pipe = $set.insert(acc, item);\n                return ((_capture) => {\n                  return do_fixed_size_set(\n                    generator,\n                    size,\n                    unique_items + 1,\n                    0,\n                    _capture,\n                  );\n                })(_pipe);\n              }\n            },\n          );\n        },\n      );\n    },\n  );\n}\n\n/**\n * Generates a `Map(k, v)` where each key value pair is generated using the\n * provided generators.\n *\n * This is similar to `fixed_size_dict` with the difference that the map is\n * going to have a random number of key-value pairs between 0 (inclusive) and\n * 32 (inclusive).\n */\nexport function dict(keys, values) {\n  return then$(\n    int(0, 32),\n    (size) => { return fixed_size_dict(keys, values, size); },\n  );\n}\n\n/**\n * Generates a `Dict(k, v)` where each key value pair is generated using the\n * provided generators.\n *\n * >  This function makes a best effort at generating a map with exactly the\n * > specified number of keys, but beware that it may contain less items if\n * > the keys generator cannot generate enough distinct keys.\n */\nexport function fixed_size_dict(keys, values, size) {\n  let _pipe = $int.max(size, 0);\n  return ((_capture) => {\n    return do_fixed_size_dict(keys, values, _capture, 0, 0, $dict.new$());\n  })(_pipe);\n}\n\nfunction do_fixed_size_dict(\n  keys,\n  values,\n  size,\n  unique_keys,\n  consecutive_attempts,\n  acc\n) {\n  let has_required_size = unique_keys === size;\n  return $bool.guard(\n    has_required_size,\n    constant(acc),\n    () => {\n      let has_reached_maximum_attempts = consecutive_attempts >= 10;\n      return $bool.guard(\n        has_reached_maximum_attempts,\n        constant(acc),\n        () => {\n          return then$(\n            keys,\n            (key) => {\n              let $ = $dict.has_key(acc, key);\n              if ($) {\n                let _pipe = (consecutive_attempts + 1);\n                return ((_capture) => {\n                  return do_fixed_size_dict(\n                    keys,\n                    values,\n                    size,\n                    unique_keys,\n                    _capture,\n                    acc,\n                  );\n                })(_pipe);\n              } else {\n                return then$(\n                  values,\n                  (value) => {\n                    let _pipe = $dict.insert(acc, key, value);\n                    return ((_capture) => {\n                      return do_fixed_size_dict(\n                        keys,\n                        values,\n                        size,\n                        unique_keys + 1,\n                        0,\n                        _capture,\n                      );\n                    })(_pipe);\n                  },\n                );\n              }\n            },\n          );\n        },\n      );\n    },\n  );\n}\n","//# sourceMappingURL=obstacle.mjs.map\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport { CustomType as $CustomType } from \"./gleam.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\n/**\n * Represents an obstacle that the player must avoid.\n */\nexport class Obstacle extends $CustomType {\n  constructor(position) {\n    super();\n    this.position = position;\n  }\n}\nexport const Obstacle$Obstacle = (position) => new Obstacle(position);\nexport const Obstacle$isObstacle = (value) => value instanceof Obstacle;\nexport const Obstacle$Obstacle$position = (value) => value.position;\nexport const Obstacle$Obstacle$0 = (value) => value.position;\n\nexport const size = 6.0;\n\nexport const damage = 10;\n\n/**\n * Checks if the object at the given position with given radius collides with the bullet.\n */\nexport function collides_with(obstacle, position, object_size) {\n  return $vector.distance(obstacle.position, position) < ((size / 2.0) + (object_size / 2.0));\n}\n\n/**\n * Renders the obstacle to the screen\n */\nexport function draw(p, obstacle) {\n  let position = obstacle.position;\n  let spike1 = 4.0;\n  let spike2 = 5.0;\n  let _pipe = $p5.stroke(p, \"#f4424b\");\n  let _pipe$1 = $p5.fill(_pipe, \"#f4424b\");\n  let _pipe$2 = $p5.circle(_pipe$1, position.x, position.y, size);\n  let _pipe$3 = $p5.line(\n    _pipe$2,\n    position.x - spike1,\n    position.y - spike1,\n    position.x + spike1,\n    position.y + spike1,\n  );\n  let _pipe$4 = $p5.line(\n    _pipe$3,\n    position.x - spike1,\n    position.y + spike1,\n    position.x + spike1,\n    position.y - spike1,\n  );\n  let _pipe$5 = $p5.line(\n    _pipe$4,\n    position.x,\n    position.y - spike2,\n    position.x,\n    position.y + spike2,\n  );\n  return $p5.line(\n    _pipe$5,\n    position.x - spike2,\n    position.y,\n    position.x + spike2,\n    position.y,\n  );\n}\n","//# sourceMappingURL=pit.mjs.map\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport { CustomType as $CustomType } from \"./gleam.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\n/**\n * Represents a hole in the ground that things can fall into.\n */\nexport class Pit extends $CustomType {\n  constructor(position, size) {\n    super();\n    this.position = position;\n    this.size = size;\n  }\n}\nexport const Pit$Pit = (position, size) => new Pit(position, size);\nexport const Pit$isPit = (value) => value instanceof Pit;\nexport const Pit$Pit$position = (value) => value.position;\nexport const Pit$Pit$0 = (value) => value.position;\nexport const Pit$Pit$size = (value) => value.size;\nexport const Pit$Pit$1 = (value) => value.size;\n\n/**\n * Renders the pit to the screen\n */\nexport function draw(p, pit) {\n  let _pipe = $p5.no_stroke(p);\n  let _pipe$1 = $p5.fill(_pipe, \"#969696\");\n  let _pipe$2 = $p5.circle(\n    _pipe$1,\n    pit.position.x - 2.0,\n    pit.position.y - 2.0,\n    pit.size + 1.0,\n  );\n  let _pipe$3 = $p5.fill(_pipe$2, \"#3C3C3C\");\n  let _pipe$4 = $p5.circle(\n    _pipe$3,\n    pit.position.x - 1.0,\n    pit.position.y - 1.0,\n    pit.size + 1.0,\n  );\n  let _pipe$5 = $p5.fill(_pipe$4, \"#000000\");\n  return $p5.circle(_pipe$5, pit.position.x, pit.position.y, pit.size * 2.0);\n}\n","//# sourceMappingURL=room.mjs.map\nimport * as $int from \"../gleam_stdlib/gleam/int.mjs\";\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport { CustomType as $CustomType } from \"./gleam.mjs\";\n\nexport class Left extends $CustomType {}\nexport const Direction$Left = () => new Left();\nexport const Direction$isLeft = (value) => value instanceof Left;\n\nexport class Right extends $CustomType {}\nexport const Direction$Right = () => new Right();\nexport const Direction$isRight = (value) => value instanceof Right;\n\nexport class Top extends $CustomType {}\nexport const Direction$Top = () => new Top();\nexport const Direction$isTop = (value) => value instanceof Top;\n\nexport class Bottom extends $CustomType {}\nexport const Direction$Bottom = () => new Bottom();\nexport const Direction$isBottom = (value) => value instanceof Bottom;\n\nexport class TopLeft extends $CustomType {}\nexport const Direction$TopLeft = () => new TopLeft();\nexport const Direction$isTopLeft = (value) => value instanceof TopLeft;\n\nexport class TopRight extends $CustomType {}\nexport const Direction$TopRight = () => new TopRight();\nexport const Direction$isTopRight = (value) => value instanceof TopRight;\n\nexport class BottomLeft extends $CustomType {}\nexport const Direction$BottomLeft = () => new BottomLeft();\nexport const Direction$isBottomLeft = (value) => value instanceof BottomLeft;\n\nexport class BottomRight extends $CustomType {}\nexport const Direction$BottomRight = () => new BottomRight();\nexport const Direction$isBottomRight = (value) => value instanceof BottomRight;\n\n/**\n * Represents a room and its walls.\n * For each direction, True means that direction is navigable (no wall).\n */\nexport class Room extends $CustomType {\n  constructor(left, right, top, bottom, top_left, top_right, bottom_left, bottom_right) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.top_left = top_left;\n    this.top_right = top_right;\n    this.bottom_left = bottom_left;\n    this.bottom_right = bottom_right;\n  }\n}\nexport const Room$Room = (left, right, top, bottom, top_left, top_right, bottom_left, bottom_right) =>\n  new Room(left,\n  right,\n  top,\n  bottom,\n  top_left,\n  top_right,\n  bottom_left,\n  bottom_right);\nexport const Room$isRoom = (value) => value instanceof Room;\nexport const Room$Room$left = (value) => value.left;\nexport const Room$Room$0 = (value) => value.left;\nexport const Room$Room$right = (value) => value.right;\nexport const Room$Room$1 = (value) => value.right;\nexport const Room$Room$top = (value) => value.top;\nexport const Room$Room$2 = (value) => value.top;\nexport const Room$Room$bottom = (value) => value.bottom;\nexport const Room$Room$3 = (value) => value.bottom;\nexport const Room$Room$top_left = (value) => value.top_left;\nexport const Room$Room$4 = (value) => value.top_left;\nexport const Room$Room$top_right = (value) => value.top_right;\nexport const Room$Room$5 = (value) => value.top_right;\nexport const Room$Room$bottom_left = (value) => value.bottom_left;\nexport const Room$Room$6 = (value) => value.bottom_left;\nexport const Room$Room$bottom_right = (value) => value.bottom_right;\nexport const Room$Room$7 = (value) => value.bottom_right;\n\nconst room_color = \"#cbe3ed\";\n\nconst wall_color = \"#42aad6\";\n\nconst wall_shadow_color = \"#3c3c3c\";\n\nconst wall_shadow_color2 = \"#646464\";\n\n/**\n * Finds the opposite direction of the one passed in.\n */\nexport function inverse_direction(direction) {\n  if (direction instanceof Left) {\n    return new Right();\n  } else if (direction instanceof Right) {\n    return new Left();\n  } else if (direction instanceof Top) {\n    return new Bottom();\n  } else if (direction instanceof Bottom) {\n    return new Top();\n  } else if (direction instanceof TopLeft) {\n    return new BottomRight();\n  } else if (direction instanceof TopRight) {\n    return new BottomLeft();\n  } else if (direction instanceof BottomLeft) {\n    return new TopRight();\n  } else {\n    return new TopLeft();\n  }\n}\n\n/**\n * Creates a room with only walls.\n */\nexport function initialize_unbounded_room() {\n  return new Room(false, false, false, false, false, false, false, false);\n}\n\n/**\n * Creates a room with the wall to a given direction set to the passed value.\n */\nexport function set_navigable(room, direction, navigable_value) {\n  if (direction instanceof Left) {\n    return new Room(\n      navigable_value,\n      room.right,\n      room.top,\n      room.bottom,\n      room.top_left,\n      room.top_right,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof Right) {\n    return new Room(\n      room.left,\n      navigable_value,\n      room.top,\n      room.bottom,\n      room.top_left,\n      room.top_right,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof Top) {\n    return new Room(\n      room.left,\n      room.right,\n      navigable_value,\n      room.bottom,\n      room.top_left,\n      room.top_right,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof Bottom) {\n    return new Room(\n      room.left,\n      room.right,\n      room.top,\n      navigable_value,\n      room.top_left,\n      room.top_right,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof TopLeft) {\n    return new Room(\n      room.left,\n      room.right,\n      room.top,\n      room.bottom,\n      navigable_value,\n      room.top_right,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof TopRight) {\n    return new Room(\n      room.left,\n      room.right,\n      room.top,\n      room.bottom,\n      room.top_left,\n      navigable_value,\n      room.bottom_left,\n      room.bottom_right,\n    );\n  } else if (direction instanceof BottomLeft) {\n    return new Room(\n      room.left,\n      room.right,\n      room.top,\n      room.bottom,\n      room.top_left,\n      room.top_right,\n      navigable_value,\n      room.bottom_right,\n    );\n  } else {\n    return new Room(\n      room.left,\n      room.right,\n      room.top,\n      room.bottom,\n      room.top_left,\n      room.top_right,\n      room.bottom_left,\n      navigable_value,\n    );\n  }\n}\n\n/**\n * Checks if a direction is navigable from the given room.\n */\nexport function is_navigable(room, direction) {\n  if (direction instanceof Left) {\n    return room.left;\n  } else if (direction instanceof Right) {\n    return room.right;\n  } else if (direction instanceof Top) {\n    return room.top;\n  } else if (direction instanceof Bottom) {\n    return room.bottom;\n  } else if (direction instanceof TopLeft) {\n    return room.top_left;\n  } else if (direction instanceof TopRight) {\n    return room.top_right;\n  } else if (direction instanceof BottomLeft) {\n    return room.bottom_left;\n  } else {\n    return room.bottom_right;\n  }\n}\n\n/**\n * Draws a room onto the screen at the given row and column.\n */\nexport function draw(p, room, room_column, room_row, room_size) {\n  let top = $int.to_float(room_row * room_size);\n  let bot = $int.to_float((room_row + 1) * room_size);\n  let left = $int.to_float(room_column * room_size);\n  let right = $int.to_float((room_column + 1) * room_size);\n  $p5.stroke_weight(p, 1);\n  $p5.fill(p, room_color);\n  $p5.stroke(p, room_color);\n  $p5.rect(p, left, top, $int.to_float(room_size), $int.to_float(room_size));\n  $p5.stroke_weight(p, 4);\n  $p5.stroke(p, wall_shadow_color);\n  $p5.line(p, right + 2.0, top, right + 2.0, bot);\n  $p5.line(p, left + 3.0, bot + 2.0, right + 2.0, bot + 2.0);\n  $p5.stroke_weight(p, 3);\n  $p5.stroke(p, wall_shadow_color2);\n  $p5.line(p, right + 1.0, top, right + 1.0, bot);\n  $p5.line(p, left + 2.0, bot + 1.0, right + 1.0, bot + 1.0);\n  $p5.stroke(p, wall_color);\n  $p5.stroke_weight(p, 2);\n  let $ = room.left;\n  if ($) {\n    p\n  } else {\n    $p5.line(p, left, top, left, bot)\n  }\n  let $1 = room.right;\n  if ($1) {\n    p\n  } else {\n    $p5.line(p, right, top, right, bot)\n  }\n  let $2 = room.top;\n  if ($2) {\n    p\n  } else {\n    $p5.line(p, left, top, right, top)\n  }\n  let $3 = room.bottom;\n  if ($3) {\n    return p;\n  } else {\n    return $p5.line(p, left, bot, right, bot);\n  }\n}\n","//# sourceMappingURL=dungeon.mjs.map\nimport * as $bool from \"../gleam_stdlib/gleam/bool.mjs\";\nimport * as $dict from \"../gleam_stdlib/gleam/dict.mjs\";\nimport * as $float from \"../gleam_stdlib/gleam/float.mjs\";\nimport * as $int from \"../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../gleam_stdlib/gleam/list.mjs\";\nimport * as $option from \"../gleam_stdlib/gleam/option.mjs\";\nimport * as $result from \"../gleam_stdlib/gleam/result.mjs\";\nimport * as $yielder from \"../gleam_yielder/gleam/yielder.mjs\";\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $priorityq from \"../priorityq/priorityq.mjs\";\nimport * as $random from \"../prng/prng/random.mjs\";\nimport {\n  Ok,\n  Error,\n  toList,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  makeError,\n  divideFloat,\n  isEqual,\n} from \"./gleam.mjs\";\nimport * as $obstacle from \"./obstacle.mjs\";\nimport * as $pit from \"./pit.mjs\";\nimport * as $room from \"./room.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\nconst FILEPATH = \"src/dungeon.gleam\";\n\nexport class Dungeon extends $CustomType {\n  constructor(rooms, pits, obstacles) {\n    super();\n    this.rooms = rooms;\n    this.pits = pits;\n    this.obstacles = obstacles;\n  }\n}\nexport const Dungeon$Dungeon = (rooms, pits, obstacles) =>\n  new Dungeon(rooms, pits, obstacles);\nexport const Dungeon$isDungeon = (value) => value instanceof Dungeon;\nexport const Dungeon$Dungeon$rooms = (value) => value.rooms;\nexport const Dungeon$Dungeon$0 = (value) => value.rooms;\nexport const Dungeon$Dungeon$pits = (value) => value.pits;\nexport const Dungeon$Dungeon$1 = (value) => value.pits;\nexport const Dungeon$Dungeon$obstacles = (value) => value.obstacles;\nexport const Dungeon$Dungeon$2 = (value) => value.obstacles;\n\nconst dungeon_size = 7;\n\nconst max_depth = dungeon_size;\n\nconst room_rate = 0.8;\n\nconst break_rate = 0.3;\n\n/**\n * The size of each room in pixels.\n */\nexport const room_size = 100;\n\nconst pit_count = 5;\n\nconst pit_size = 20.0;\n\nconst minimum_pit_distance = 80.0;\n\nconst obstacle_rate = 0.5;\n\nconst obstacle_limit = 3;\n\n/**\n * Gets the indices of the room that would be in the given direction from the given indices.\n */\nexport function next_room_indices(column, row, direction) {\n  if (direction instanceof $room.Left) {\n    return [column - 1, row];\n  } else if (direction instanceof $room.Right) {\n    return [column + 1, row];\n  } else if (direction instanceof $room.Top) {\n    return [column, row - 1];\n  } else if (direction instanceof $room.Bottom) {\n    return [column, row + 1];\n  } else if (direction instanceof $room.TopLeft) {\n    return [column - 1, row - 1];\n  } else if (direction instanceof $room.TopRight) {\n    return [column + 1, row - 1];\n  } else if (direction instanceof $room.BottomLeft) {\n    return [column - 1, row + 1];\n  } else {\n    return [column + 1, row + 1];\n  }\n}\n\nfunction coordinate_direction(from, to) {\n  let fc = from[0];\n  let fr = from[1];\n  let tc = to[0];\n  let tr = to[1];\n  if ((fc === tc) && (fr < tr)) {\n    return new Ok(new $room.Bottom());\n  } else {\n    let fc = from[0];\n    let fr = from[1];\n    let tc = to[0];\n    let tr = to[1];\n    if ((fc < tc) && (fr < tr)) {\n      return new Ok(new $room.BottomRight());\n    } else {\n      let fc = from[0];\n      let fr = from[1];\n      let tc = to[0];\n      let tr = to[1];\n      if ((fc === tc) && (fr > tr)) {\n        return new Ok(new $room.Top());\n      } else {\n        let fc = from[0];\n        let fr = from[1];\n        let tc = to[0];\n        let tr = to[1];\n        if ((fc > tc) && (fr > tr)) {\n          return new Ok(new $room.TopLeft());\n        } else {\n          let fc = from[0];\n          let fr = from[1];\n          let tc = to[0];\n          let tr = to[1];\n          if ((fc < tc) && (fr === tr)) {\n            return new Ok(new $room.Right());\n          } else {\n            let fc = from[0];\n            let fr = from[1];\n            let tc = to[0];\n            let tr = to[1];\n            if ((fc < tc) && (fr > tr)) {\n              return new Ok(new $room.TopRight());\n            } else {\n              let fc = from[0];\n              let fr = from[1];\n              let tc = to[0];\n              let tr = to[1];\n              if ((fc > tc) && (fr === tr)) {\n                return new Ok(new $room.Left());\n              } else {\n                let fc = from[0];\n                let fr = from[1];\n                let tc = to[0];\n                let tr = to[1];\n                if ((fc > tc) && (fr < tr)) {\n                  return new Ok(new $room.BottomLeft());\n                } else {\n                  return new Error(undefined);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Checks if a point is on top of a pit.\n */\nexport function is_over_pit(dungeon, position) {\n  return $list.any(\n    dungeon.pits,\n    (pit) => { return $vector.distance(pit.position, position) < pit.size; },\n  );\n}\n\nfunction center() {\n  return globalThis.Math.trunc(dungeon_size / 2);\n}\n\nfunction coordinate_out_of_bounds(column, row) {\n  return (((column < 0) || (column >= dungeon_size)) || (row < 0)) || (row >= dungeon_size);\n}\n\nfunction compute_corner_walls(rooms) {\n  return $dict.fold(\n    rooms,\n    rooms,\n    (rooms, _use1, r) => {\n      let column;\n      let row;\n      column = _use1[0];\n      row = _use1[1];\n      let open_corner = (room, dir1, dir2, out_dir) => {\n        let can_go_in_dir = $room.is_navigable(room, dir1) && $room.is_navigable(\n          room,\n          dir2,\n        );\n        return $bool.guard(\n          !can_go_in_dir,\n          room,\n          () => {\n            let $ = next_room_indices(column, row, out_dir);\n            let next_column;\n            let next_row;\n            next_column = $[0];\n            next_row = $[1];\n            return $bool.guard(\n              coordinate_out_of_bounds(next_column, next_row),\n              room,\n              () => {\n                let next_room = $dict.get(rooms, [next_column, next_row]);\n                if (next_room instanceof Ok) {\n                  let next_room$1 = next_room[0];\n                  let can_go_in_dir$1 = $room.is_navigable(\n                    next_room$1,\n                    $room.inverse_direction(dir1),\n                  ) && $room.is_navigable(\n                    next_room$1,\n                    $room.inverse_direction(dir2),\n                  );\n                  if (can_go_in_dir$1) {\n                    return $room.set_navigable(room, out_dir, true);\n                  } else {\n                    return room;\n                  }\n                } else {\n                  return room;\n                }\n              },\n            );\n          },\n        );\n      };\n      let _block;\n      let _pipe = r;\n      let _pipe$1 = open_corner(\n        _pipe,\n        new $room.Right(),\n        new $room.Bottom(),\n        new $room.BottomRight(),\n      );\n      let _pipe$2 = open_corner(\n        _pipe$1,\n        new $room.Left(),\n        new $room.Bottom(),\n        new $room.BottomLeft(),\n      );\n      let _pipe$3 = open_corner(\n        _pipe$2,\n        new $room.Right(),\n        new $room.Top(),\n        new $room.TopRight(),\n      );\n      _block = open_corner(\n        _pipe$3,\n        new $room.Left(),\n        new $room.Top(),\n        new $room.TopLeft(),\n      );\n      let r$1 = _block;\n      return $dict.insert(rooms, [column, row], r$1);\n    },\n  );\n}\n\nfunction generate_rooms(rooms, column, row, recursion_depth, previous_direction) {\n  let r = $room.initialize_unbounded_room();\n  let _block;\n  if (recursion_depth === 0) {\n    _block = r;\n  } else {\n    _block = $room.set_navigable(r, previous_direction, true);\n  }\n  let r$1 = _block;\n  let rooms$1 = $dict.insert(rooms, [column, row], r$1);\n  return $bool.guard(\n    recursion_depth > max_depth,\n    rooms$1,\n    () => {\n      let advance_direction = (rooms, direction) => {\n        return $bool.guard(\n          (isEqual(direction, previous_direction)) && (recursion_depth !== 0),\n          rooms,\n          () => {\n            let $ = next_room_indices(column, row, direction);\n            let next_column;\n            let next_row;\n            next_column = $[0];\n            next_row = $[1];\n            return $bool.guard(\n              coordinate_out_of_bounds(next_column, next_row),\n              rooms,\n              () => {\n                return $bool.guard(\n                  $dict.has_key(rooms, [next_column, next_row]),\n                  rooms,\n                  () => {\n                    let _block$1;\n                    let _pipe = $random.float(0.0, 1.0);\n                    _block$1 = $random.random_sample(_pipe);\n                    let room_roll = _block$1;\n                    return $bool.guard(\n                      room_roll > room_rate,\n                      rooms,\n                      () => {\n                        let $1 = $dict.get(rooms, [column, row]);\n                        let r$2;\n                        if ($1 instanceof Ok) {\n                          r$2 = $1[0];\n                        } else {\n                          throw makeError(\n                            \"let_assert\",\n                            FILEPATH,\n                            \"dungeon\",\n                            122,\n                            \"generate_rooms\",\n                            \"Pattern match failed, no pattern matched the value.\",\n                            {\n                              value: $1,\n                              start: 3091,\n                              end: 3141,\n                              pattern_start: 3102,\n                              pattern_end: 3107\n                            }\n                          )\n                        }\n                        let r$3 = $room.set_navigable(r$2, direction, true);\n                        let rooms$1 = $dict.insert(rooms, [column, row], r$3);\n                        return generate_rooms(\n                          rooms$1,\n                          next_column,\n                          next_row,\n                          recursion_depth + 1,\n                          $room.inverse_direction(direction),\n                        );\n                      },\n                    );\n                  },\n                );\n              },\n            );\n          },\n        );\n      };\n      let _pipe = rooms$1;\n      let _pipe$1 = advance_direction(_pipe, new $room.Left());\n      let _pipe$2 = advance_direction(_pipe$1, new $room.Right());\n      let _pipe$3 = advance_direction(_pipe$2, new $room.Top());\n      return advance_direction(_pipe$3, new $room.Bottom());\n    },\n  );\n}\n\nfunction break_walls(rooms) {\n  return $dict.fold(\n    rooms,\n    rooms,\n    (rooms, _use1, _) => {\n      let column;\n      let row;\n      column = _use1[0];\n      row = _use1[1];\n      let break_in_direction = (rooms, dir) => {\n        let $ = next_room_indices(column, row, dir);\n        let next_column;\n        let next_row;\n        next_column = $[0];\n        next_row = $[1];\n        return $bool.guard(\n          coordinate_out_of_bounds(next_column, next_row),\n          rooms,\n          () => {\n            let next_room = $dict.get(rooms, [next_column, next_row]);\n            if (next_room instanceof Ok) {\n              let next_room$1 = next_room[0];\n              let _block;\n              let _pipe = $random.float(0.0, 1.0);\n              _block = $random.random_sample(_pipe);\n              let break_roll = _block;\n              return $bool.guard(\n                break_roll > break_rate,\n                rooms,\n                () => {\n                  let $1 = $dict.get(rooms, [column, row]);\n                  let room;\n                  if ($1 instanceof Ok) {\n                    room = $1[0];\n                  } else {\n                    throw makeError(\n                      \"let_assert\",\n                      FILEPATH,\n                      \"dungeon\",\n                      194,\n                      \"break_walls\",\n                      \"Pattern match failed, no pattern matched the value.\",\n                      {\n                        value: $1,\n                        start: 5388,\n                        end: 5441,\n                        pattern_start: 5399,\n                        pattern_end: 5407\n                      }\n                    )\n                  }\n                  let room$1 = $room.set_navigable(room, dir, true);\n                  let rooms$1 = $dict.insert(rooms, [column, row], room$1);\n                  let next_room$2 = $room.set_navigable(\n                    next_room$1,\n                    $room.inverse_direction(dir),\n                    true,\n                  );\n                  return $dict.insert(\n                    rooms$1,\n                    [next_column, next_row],\n                    next_room$2,\n                  );\n                },\n              );\n            } else {\n              return rooms;\n            }\n          },\n        );\n      };\n      let _pipe = rooms;\n      let _pipe$1 = break_in_direction(_pipe, new $room.Right());\n      return break_in_direction(_pipe$1, new $room.Bottom());\n    },\n  );\n}\n\n/**\n * The total size of the dungeon in pixels.\n */\nexport function total_size() {\n  return $int.to_float(dungeon_size * room_size);\n}\n\nfunction point_out_of_bounds(position) {\n  let size = total_size();\n  return (((position.x < 0.0) || (position.x >= size)) || (position.y < 0.0)) || (position.y >= size);\n}\n\n/**\n * Given a coordinate find the center point of the room.\n */\nexport function coordinate_to_point(coordinate) {\n  let x = $int.to_float(coordinate[0] * room_size) + ($int.to_float(room_size) / 2.0);\n  let y = $int.to_float(coordinate[1] * room_size) + ($int.to_float(room_size) / 2.0);\n  return new $vector.Vector(x, y, 0.0);\n}\n\nfunction get_random_point_in_room(loop$rooms) {\n  while (true) {\n    let rooms = loop$rooms;\n    let _block;\n    let _pipe = $random.int(0, dungeon_size);\n    _block = $random.random_sample(_pipe);\n    let random_x = _block;\n    let _block$1;\n    let _pipe$1 = $random.int(0, dungeon_size);\n    _block$1 = $random.random_sample(_pipe$1);\n    let random_y = _block$1;\n    let coordinate = [random_x, random_y];\n    let $ = $dict.get(rooms, coordinate);\n    if ($ instanceof Ok) {\n      return coordinate_to_point(coordinate);\n    } else {\n      loop$rooms = rooms;\n    }\n  }\n}\n\n/**\n * Renders the dungeon to the screen.\n */\nexport function draw(p, dungeon) {\n  $yielder.each(\n    $yielder.range(0, dungeon_size),\n    (col) => {\n      return $yielder.each(\n        $yielder.range(0, dungeon_size),\n        (row) => {\n          return $result.map(\n            $dict.get(dungeon.rooms, [col, row]),\n            (r) => { return $room.draw(p, r, col, row, room_size); },\n          );\n        },\n      );\n    },\n  );\n  $list.each(dungeon.pits, (pit) => { return $pit.draw(p, pit); });\n  return $list.each(\n    dungeon.obstacles,\n    (obstacle) => { return $obstacle.draw(p, obstacle); },\n  );\n}\n\n/**\n * Get the coordinate that the given point is in.\n */\nexport function point_to_coordinate(point) {\n  let column = $float.truncate(divideFloat(point.x, $int.to_float(room_size)));\n  let row = $float.truncate(divideFloat(point.y, $int.to_float(room_size)));\n  return [column, row];\n}\n\n/**\n * Checks if it is possible to move from one position to another.\n */\nexport function can_move(dungeon, from, to) {\n  return $bool.guard(\n    point_out_of_bounds(to),\n    false,\n    () => {\n      let from_coordinate = point_to_coordinate(from);\n      let to_coordinate = point_to_coordinate(to);\n      let from_room = $dict.get(dungeon.rooms, from_coordinate);\n      let to_room = $dict.get(dungeon.rooms, to_coordinate);\n      if (from_room instanceof Ok && to_room instanceof Ok) {\n        let from$1 = from_room[0];\n        let dir = coordinate_direction(from_coordinate, to_coordinate);\n        if (dir instanceof Ok) {\n          let dir$1 = dir[0];\n          return $room.is_navigable(from$1, dir$1);\n        } else {\n          return true;\n        }\n      } else {\n        return false;\n      }\n    },\n  );\n}\n\n/**\n * Checks if going from 1 point to another hits a wall. If it does then return the direction away from the wall.\n */\nexport function get_reflecting_point(dungeon, from, to) {\n  return $bool.guard(\n    point_out_of_bounds(to),\n    new Error(undefined),\n    () => {\n      let from_coordinate = point_to_coordinate(from);\n      let to_coordinate = point_to_coordinate(to);\n      let from_room = $dict.get(dungeon.rooms, from_coordinate);\n      let to_room = $dict.get(dungeon.rooms, to_coordinate);\n      if (from_room instanceof Ok && to_room instanceof Ok) {\n        let from$1 = from_room[0];\n        return $result.try$(\n          coordinate_direction(from_coordinate, to_coordinate),\n          (dir) => {\n            return $bool.guard(\n              $room.is_navigable(from$1, dir),\n              new Error(undefined),\n              () => { return new Ok($room.inverse_direction(dir)); },\n            );\n          },\n        );\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\nfunction path_from_costs(seen_so_far, end) {\n  let $ = $dict.get(seen_so_far, end);\n  let prev;\n  if ($ instanceof Ok) {\n    prev = $[0][2];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"dungeon\",\n      589,\n      \"path_from_costs\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 17813,\n        end: 17870,\n        pattern_start: 17824,\n        pattern_end: 17841\n      }\n    )\n  }\n  if (prev instanceof $option.Some) {\n    let prev$1 = prev[0];\n    return listPrepend(\n      coordinate_to_point(end),\n      path_from_costs(seen_so_far, prev$1),\n    );\n  } else {\n    return toList([]);\n  }\n}\n\nfunction path_to_helper(dungeon, to, worklist, seen_so_far) {\n  return $bool.guard(\n    $priorityq.is_empty(worklist),\n    toList([]),\n    () => {\n      let $ = $priorityq.peek(worklist);\n      let t;\n      let cost;\n      if ($ instanceof $option.Some) {\n        t = $[0][0];\n        cost = $[0][1];\n      } else {\n        throw makeError(\n          \"let_assert\",\n          FILEPATH,\n          \"dungeon\",\n          532,\n          \"path_to_helper\",\n          \"Pattern match failed, no pattern matched the value.\",\n          {\n            value: $,\n            start: 16007,\n            end: 16071,\n            pattern_start: 16018,\n            pattern_end: 16044\n          }\n        )\n      }\n      let worklist$1 = $priorityq.pop(worklist);\n      let $1 = isEqual(t, to);\n      if ($1) {\n        return $list.reverse(path_from_costs(seen_so_far, to));\n      } else {\n        let _block;\n        let _pipe = toList([\n          new $room.Left(),\n          new $room.Right(),\n          new $room.Top(),\n          new $room.Bottom(),\n          new $room.TopLeft(),\n          new $room.TopRight(),\n          new $room.BottomLeft(),\n          new $room.BottomRight(),\n        ]);\n        _block = $list.fold(\n          _pipe,\n          [worklist$1, seen_so_far],\n          (acc, dir) => {\n            let worklist$2;\n            let seen_so_far$1;\n            worklist$2 = acc[0];\n            seen_so_far$1 = acc[1];\n            let $3 = $dict.get(dungeon.rooms, t);\n            let to_room;\n            if ($3 instanceof Ok) {\n              to_room = $3[0];\n            } else {\n              throw makeError(\n                \"let_assert\",\n                FILEPATH,\n                \"dungeon\",\n                551,\n                \"path_to_helper\",\n                \"Pattern match failed, no pattern matched the value.\",\n                {\n                  value: $3,\n                  start: 16569,\n                  end: 16620,\n                  pattern_start: 16580,\n                  pattern_end: 16591\n                }\n              )\n            }\n            let $4 = $room.is_navigable(to_room, dir);\n            if ($4) {\n              let next = next_room_indices(t[0], t[1], dir);\n              let next_cost = cost + $vector.distance(\n                new $vector.Vector(\n                  $int.to_float(next[0]),\n                  $int.to_float(next[1]),\n                  0.0,\n                ),\n                new $vector.Vector(\n                  $int.to_float(to[0]),\n                  $int.to_float(to[1]),\n                  0.0,\n                ),\n              );\n              let $5 = $dict.get(seen_so_far$1, next);\n              if ($5 instanceof Ok) {\n                let old_best = $5[0][1];\n                if (old_best < next_cost) {\n                  return [worklist$2, seen_so_far$1];\n                } else {\n                  return [\n                    (() => {\n                      let _pipe$1 = worklist$2;\n                      return $priorityq.push(\n                        _pipe$1,\n                        [next, next_cost, new $option.Some(t)],\n                      );\n                    })(),\n                    (() => {\n                      let _pipe$1 = seen_so_far$1;\n                      return $dict.insert(\n                        _pipe$1,\n                        next,\n                        [next, next_cost, new $option.Some(t)],\n                      );\n                    })(),\n                  ];\n                }\n              } else {\n                return [\n                  (() => {\n                    let _pipe$1 = worklist$2;\n                    return $priorityq.push(\n                      _pipe$1,\n                      [next, next_cost, new $option.Some(t)],\n                    );\n                  })(),\n                  (() => {\n                    let _pipe$1 = seen_so_far$1;\n                    return $dict.insert(\n                      _pipe$1,\n                      next,\n                      [next, next_cost, new $option.Some(t)],\n                    );\n                  })(),\n                ];\n              }\n            } else {\n              return [worklist$2, seen_so_far$1];\n            }\n          },\n        );\n        let $2 = _block;\n        let worklist$2;\n        let seen_so_far$1;\n        worklist$2 = $2[0];\n        seen_so_far$1 = $2[1];\n        return path_to_helper(dungeon, to, worklist$2, seen_so_far$1);\n      }\n    },\n  );\n}\n\n/**\n * Gets a path from 1 point to another in a dungeon\n */\nexport function path_to(dungeon, from, to) {\n  let start = point_to_coordinate(from);\n  let initial_entry = [start, 0.0, new $option.None()];\n  return path_to_helper(\n    dungeon,\n    point_to_coordinate(to),\n    (() => {\n      let _pipe = $priorityq.new$(\n        (a, b) => { return $float.compare(b[1], a[1]); },\n      );\n      return $priorityq.push(_pipe, initial_entry);\n    })(),\n    $dict.from_list(toList([[start, initial_entry]])),\n  );\n}\n\nfunction too_close_to_existing_pit(pits, position) {\n  return $list.any(\n    pits,\n    (pit) => {\n      let distance = $vector.distance(pit.position, position);\n      return distance < minimum_pit_distance;\n    },\n  );\n}\n\nfunction attempt_place_obstacle(point, pits, tries) {\n  return $bool.guard(\n    tries > 3,\n    new Error(undefined),\n    () => {\n      let max_offset = ($int.to_float(room_size) - $obstacle.size) / 2.0;\n      let _block;\n      let _pipe = $random.float(max_offset * -1.0, max_offset);\n      _block = $random.random_sample(_pipe);\n      let offset_x = _block;\n      let _block$1;\n      let _pipe$1 = $random.float(max_offset * -1.0, max_offset);\n      _block$1 = $random.random_sample(_pipe$1);\n      let offset_y = _block$1;\n      let position = $vector.add(\n        point,\n        new $vector.Vector(offset_x, offset_y, 0.0),\n      );\n      let $ = too_close_to_existing_pit(pits, position);\n      if ($) {\n        return attempt_place_obstacle(point, pits, tries + 1);\n      } else {\n        return new Ok(new $obstacle.Obstacle(position));\n      }\n    },\n  );\n}\n\nfunction too_close_to_player_spawn(position) {\n  let c = center();\n  return $vector.distance(coordinate_to_point([c, c]), position) < minimum_pit_distance;\n}\n\n/**\n * Get a random location to place an object.\n * Objects should not be too close to existing pits and should not be too close to where the player starts.\n */\nexport function get_location_to_place_object(loop$rooms, loop$pits) {\n  while (true) {\n    let rooms = loop$rooms;\n    let pits = loop$pits;\n    let point = get_random_point_in_room(rooms);\n    let _block;\n    let _pipe = $random.float(-30.0, 30.0);\n    _block = $random.random_sample(_pipe);\n    let offset_x = _block;\n    let _block$1;\n    let _pipe$1 = $random.float(-30.0, 30.0);\n    _block$1 = $random.random_sample(_pipe$1);\n    let offset_y = _block$1;\n    let position = $vector.add(\n      point,\n      new $vector.Vector(offset_x, offset_y, 0.0),\n    );\n    let $ = too_close_to_existing_pit(pits, position) || too_close_to_player_spawn(\n      position,\n    );\n    if ($) {\n      loop$rooms = rooms;\n      loop$pits = pits;\n    } else {\n      return position;\n    }\n  }\n}\n\nfunction generate_pits(rooms) {\n  let _pipe = $list.range(1, pit_count);\n  return $list.fold(\n    _pipe,\n    toList([]),\n    (pits, _) => {\n      let position = get_location_to_place_object(rooms, pits);\n      return listPrepend(new $pit.Pit(position, pit_size), pits);\n    },\n  );\n}\n\nfunction generate_obstacles(rooms, pits) {\n  return $dict.fold(\n    rooms,\n    toList([]),\n    (obstacles, coordinate, _) => {\n      let _block;\n      let _pipe = $random.float(0.0, 1.0);\n      _block = $random.random_sample(_pipe);\n      let obstacle_roll = _block;\n      return $bool.guard(\n        obstacle_roll > obstacle_rate,\n        obstacles,\n        () => {\n          let point = coordinate_to_point(coordinate);\n          let _block$1;\n          let _pipe$1 = $random.int(0, obstacle_limit);\n          _block$1 = $random.random_sample(_pipe$1);\n          let obstacle_count = _block$1;\n          return $list.fold(\n            $list.range(1, obstacle_count),\n            obstacles,\n            (obstacles, _) => {\n              let $ = attempt_place_obstacle(point, pits, 0);\n              if ($ instanceof Ok) {\n                let obstacle = $[0];\n                return listPrepend(obstacle, obstacles);\n              } else {\n                return obstacles;\n              }\n            },\n          );\n        },\n      );\n    },\n  );\n}\n\n/**\n * Creates the initial game dungeon.\n */\nexport function generate_dungeon() {\n  let center$1 = center();\n  let _block;\n  let _pipe = $dict.new$();\n  let _pipe$1 = generate_rooms(_pipe, center$1, center$1, 0, new $room.Left());\n  let _pipe$2 = break_walls(_pipe$1);\n  _block = compute_corner_walls(_pipe$2);\n  let rooms = _block;\n  let pits = generate_pits(rooms);\n  let obstacles = generate_obstacles(rooms, pits);\n  return new Dungeon(rooms, pits, obstacles);\n}\n","//# sourceMappingURL=player.mjs.map\nimport * as $float from \"../gleam_stdlib/gleam/float.mjs\";\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport { Ok, CustomType as $CustomType, makeError } from \"./gleam.mjs\";\nimport * as $utils from \"./utils.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\nconst FILEPATH = \"src/player.gleam\";\n\n/**\n * Represents the player character.\n */\nexport class Player extends $CustomType {\n  constructor(position, velocity, acceleration, last_fire_time, last_hit_time, current_health, max_health) {\n    super();\n    this.position = position;\n    this.velocity = velocity;\n    this.acceleration = acceleration;\n    this.last_fire_time = last_fire_time;\n    this.last_hit_time = last_hit_time;\n    this.current_health = current_health;\n    this.max_health = max_health;\n  }\n}\nexport const Player$Player = (position, velocity, acceleration, last_fire_time, last_hit_time, current_health, max_health) =>\n  new Player(position,\n  velocity,\n  acceleration,\n  last_fire_time,\n  last_hit_time,\n  current_health,\n  max_health);\nexport const Player$isPlayer = (value) => value instanceof Player;\nexport const Player$Player$position = (value) => value.position;\nexport const Player$Player$0 = (value) => value.position;\nexport const Player$Player$velocity = (value) => value.velocity;\nexport const Player$Player$1 = (value) => value.velocity;\nexport const Player$Player$acceleration = (value) => value.acceleration;\nexport const Player$Player$2 = (value) => value.acceleration;\nexport const Player$Player$last_fire_time = (value) => value.last_fire_time;\nexport const Player$Player$3 = (value) => value.last_fire_time;\nexport const Player$Player$last_hit_time = (value) => value.last_hit_time;\nexport const Player$Player$4 = (value) => value.last_hit_time;\nexport const Player$Player$current_health = (value) => value.current_health;\nexport const Player$Player$5 = (value) => value.current_health;\nexport const Player$Player$max_health = (value) => value.max_health;\nexport const Player$Player$6 = (value) => value.max_health;\n\n/**\n * The size of the player character in pixels.\n */\nexport const player_size = 10.0;\n\nconst max_speed = 4.0;\n\nconst jump_power = 0.2;\n\nconst time_between_fire = 120;\n\nconst invulnerability_time = 500;\n\nconst base_max_health = 100;\n\nconst player_gravity_strength = 0.02;\n\nconst dead_fill_color = \"#000000\";\n\nconst invulnerable_fill_color = \"#4c4cff\";\n\nconst player_fill_color = \"#0000ff\";\n\nconst player_stroke_color = \"#000000\";\n\nfunction acceleration() {\n  return 2.0 / 3.0;\n}\n\n/**\n * Advances the player forward assuming they can.\n */\nexport function move(player) {\n  return new Player(\n    $vector.add(player.position, player.velocity),\n    player.velocity,\n    player.acceleration,\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Accelerates the player in the x direction.\n */\nexport function accelerate_x(player, forward) {\n  let _block;\n  if (forward) {\n    _block = acceleration();\n  } else {\n    _block = -1.0 * acceleration();\n  }\n  let acc = _block;\n  return new Player(\n    player.position,\n    player.velocity,\n    new $vector.Vector(acc, player.acceleration.y, player.acceleration.z),\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Accelerates the player in the y direction.\n */\nexport function accelerate_y(player, forward) {\n  let _block;\n  if (forward) {\n    _block = acceleration();\n  } else {\n    _block = -1.0 * acceleration();\n  }\n  let acc = _block;\n  return new Player(\n    player.position,\n    player.velocity,\n    new $vector.Vector(player.acceleration.x, acc, player.acceleration.z),\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Stops the player in the x direction.\n */\nexport function stop_x(player) {\n  return new Player(\n    player.position,\n    new $vector.Vector(0.0, player.velocity.y, player.velocity.z),\n    new $vector.Vector(0.0, player.acceleration.y, player.acceleration.z),\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Stops the player in the y direction.\n */\nexport function stop_y(player) {\n  return new Player(\n    player.position,\n    new $vector.Vector(player.velocity.x, 0.0, player.velocity.z),\n    new $vector.Vector(player.acceleration.x, 0.0, player.acceleration.z),\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Applies damage to the player.\n */\nexport function apply_damage(player, damage) {\n  return new Player(\n    player.position,\n    player.velocity,\n    player.acceleration,\n    player.last_fire_time,\n    $utils.now_in_milliseconds(),\n    player.current_health - damage,\n    player.max_health,\n  );\n}\n\n/**\n * Is the player currently dead.\n */\nexport function is_player_dead(player) {\n  return player.current_health <= 0;\n}\n\n/**\n * Accelerates the player's velocity.\n */\nexport function update_velocity(player) {\n  let vel = $vector.add(player.velocity, player.acceleration);\n  let _block;\n  let _pipe = $vector.vector_2d(vel);\n  _block = $vector.limit(_pipe, max_speed);\n  let limited = _block;\n  return new Player(\n    player.position,\n    new $vector.Vector(limited.x, limited.y, vel.z),\n    player.acceleration,\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Let's the player jump if they are on the ground.\n */\nexport function jump(player) {\n  let $ = player.position.z;\n  let $1 = player.velocity.z;\n  let p = $;\n  let v = $1;\n  if ((p === 0.0) && (v <= 0.0)) {\n    return new Player(\n      player.position,\n      new $vector.Vector(player.velocity.x, player.velocity.y, jump_power),\n      player.acceleration,\n      player.last_fire_time,\n      player.last_hit_time,\n      player.current_health,\n      player.max_health,\n    );\n  } else {\n    return player;\n  }\n}\n\n/**\n * Can the player fire a bullet at the moment.\n */\nexport function can_player_fire(player) {\n  return (player.last_fire_time + time_between_fire) <= $utils.now_in_milliseconds();\n}\n\n/**\n * Is the player currently invulnerable.\n */\nexport function is_player_invulnerable(player) {\n  return (player.last_hit_time + invulnerability_time) >= $utils.now_in_milliseconds();\n}\n\n/**\n * Makes the starting player at the given position.\n */\nexport function new_player(initial_position) {\n  return new Player(\n    initial_position,\n    new $vector.Vector(0.0, 0.0, 0.0),\n    new $vector.Vector(0.0, 0.0, 0.0),\n    0,\n    0,\n    base_max_health,\n    base_max_health,\n  );\n}\n\n/**\n * Applies gravity to the velocity and resets z position to floor when appropriate.\n */\nexport function apply_gravity(player) {\n  let _block;\n  let $ = player.position.z;\n  let z = $;\n  if (z < 0.0) {\n    _block = new $vector.Vector(player.position.x, player.position.y, 0.0);\n  } else {\n    _block = player.position;\n  }\n  let position = _block;\n  return new Player(\n    position,\n    new $vector.Vector(\n      player.velocity.x,\n      player.velocity.y,\n      player.velocity.z - player_gravity_strength,\n    ),\n    player.acceleration,\n    player.last_fire_time,\n    player.last_hit_time,\n    player.current_health,\n    player.max_health,\n  );\n}\n\n/**\n * Renders the player to the screen.\n */\nexport function draw(p, player) {\n  let $ = is_player_dead(player);\n  let $1 = is_player_invulnerable(player);\n  if ($) {\n    $p5.fill(p, dead_fill_color)\n  } else if ($1) {\n    $p5.fill(p, invulnerable_fill_color)\n  } else {\n    $p5.fill(p, player_fill_color)\n  }\n  $p5.stroke(p, player_stroke_color);\n  let $2 = $float.power(player_size, 1.0 + (player.position.z / 4.0));\n  let size_to_draw;\n  if ($2 instanceof Ok) {\n    size_to_draw = $2[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"player\",\n      209,\n      \"draw\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $2,\n        start: 5171,\n        end: 5262,\n        pattern_start: 5182,\n        pattern_end: 5198\n      }\n    )\n  }\n  let size_to_draw$1 = $float.max(size_to_draw, player_size / 2.0);\n  return $p5.ellipse(\n    p,\n    player.position.x,\n    player.position.y,\n    size_to_draw$1,\n    size_to_draw$1,\n  );\n}\n","//# sourceMappingURL=enemy.mjs.map\nimport * as $maths from \"../gleam_community_maths/gleam_community/maths.mjs\";\nimport * as $bool from \"../gleam_stdlib/gleam/bool.mjs\";\nimport * as $float from \"../gleam_stdlib/gleam/float.mjs\";\nimport * as $int from \"../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../gleam_stdlib/gleam/list.mjs\";\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport * as $random from \"../prng/prng/random.mjs\";\nimport * as $behavior_tree from \"./behavior_tree/behavior_tree.mjs\";\nimport * as $bullet from \"./bullet.mjs\";\nimport * as $dungeon from \"./dungeon.mjs\";\nimport {\n  Ok,\n  toList,\n  Empty as $Empty,\n  CustomType as $CustomType,\n  makeError,\n  divideFloat,\n  isEqual,\n} from \"./gleam.mjs\";\nimport * as $obstacle from \"./obstacle.mjs\";\nimport * as $pit from \"./pit.mjs\";\nimport * as $player from \"./player.mjs\";\nimport * as $room from \"./room.mjs\";\nimport * as $utils from \"./utils.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\nconst FILEPATH = \"src/enemy.gleam\";\n\n/**\n * Represents the input data needed for an enemy to update.\n */\nexport class Inputs extends $CustomType {\n  constructor(enemies, dungeon, player) {\n    super();\n    this.enemies = enemies;\n    this.dungeon = dungeon;\n    this.player = player;\n  }\n}\nexport const Inputs$Inputs = (enemies, dungeon, player) =>\n  new Inputs(enemies, dungeon, player);\nexport const Inputs$isInputs = (value) => value instanceof Inputs;\nexport const Inputs$Inputs$enemies = (value) => value.enemies;\nexport const Inputs$Inputs$0 = (value) => value.enemies;\nexport const Inputs$Inputs$dungeon = (value) => value.dungeon;\nexport const Inputs$Inputs$1 = (value) => value.dungeon;\nexport const Inputs$Inputs$player = (value) => value.player;\nexport const Inputs$Inputs$2 = (value) => value.player;\n\n/**\n * Represents the additional outputs from updating an enemy.\n */\nexport class AdditionalOutputs extends $CustomType {\n  constructor(bullets) {\n    super();\n    this.bullets = bullets;\n  }\n}\nexport const AdditionalOutputs$AdditionalOutputs = (bullets) =>\n  new AdditionalOutputs(bullets);\nexport const AdditionalOutputs$isAdditionalOutputs = (value) =>\n  value instanceof AdditionalOutputs;\nexport const AdditionalOutputs$AdditionalOutputs$bullets = (value) =>\n  value.bullets;\nexport const AdditionalOutputs$AdditionalOutputs$0 = (value) => value.bullets;\n\n/**\n * Represents an enemy to defeat.\n */\nexport class Enemy extends $CustomType {\n  constructor(position, rotation, velocity, rotational_velocity, current_health, max_health, path, last_path_updated, spotted_player, last_bullet_fired, btree) {\n    super();\n    this.position = position;\n    this.rotation = rotation;\n    this.velocity = velocity;\n    this.rotational_velocity = rotational_velocity;\n    this.current_health = current_health;\n    this.max_health = max_health;\n    this.path = path;\n    this.last_path_updated = last_path_updated;\n    this.spotted_player = spotted_player;\n    this.last_bullet_fired = last_bullet_fired;\n    this.btree = btree;\n  }\n}\nexport const Enemy$Enemy = (position, rotation, velocity, rotational_velocity, current_health, max_health, path, last_path_updated, spotted_player, last_bullet_fired, btree) =>\n  new Enemy(position,\n  rotation,\n  velocity,\n  rotational_velocity,\n  current_health,\n  max_health,\n  path,\n  last_path_updated,\n  spotted_player,\n  last_bullet_fired,\n  btree);\nexport const Enemy$isEnemy = (value) => value instanceof Enemy;\nexport const Enemy$Enemy$position = (value) => value.position;\nexport const Enemy$Enemy$0 = (value) => value.position;\nexport const Enemy$Enemy$rotation = (value) => value.rotation;\nexport const Enemy$Enemy$1 = (value) => value.rotation;\nexport const Enemy$Enemy$velocity = (value) => value.velocity;\nexport const Enemy$Enemy$2 = (value) => value.velocity;\nexport const Enemy$Enemy$rotational_velocity = (value) =>\n  value.rotational_velocity;\nexport const Enemy$Enemy$3 = (value) => value.rotational_velocity;\nexport const Enemy$Enemy$current_health = (value) => value.current_health;\nexport const Enemy$Enemy$4 = (value) => value.current_health;\nexport const Enemy$Enemy$max_health = (value) => value.max_health;\nexport const Enemy$Enemy$5 = (value) => value.max_health;\nexport const Enemy$Enemy$path = (value) => value.path;\nexport const Enemy$Enemy$6 = (value) => value.path;\nexport const Enemy$Enemy$last_path_updated = (value) => value.last_path_updated;\nexport const Enemy$Enemy$7 = (value) => value.last_path_updated;\nexport const Enemy$Enemy$spotted_player = (value) => value.spotted_player;\nexport const Enemy$Enemy$8 = (value) => value.spotted_player;\nexport const Enemy$Enemy$last_bullet_fired = (value) => value.last_bullet_fired;\nexport const Enemy$Enemy$9 = (value) => value.last_bullet_fired;\nexport const Enemy$Enemy$btree = (value) => value.btree;\nexport const Enemy$Enemy$10 = (value) => value.btree;\n\n/**\n * The size of an enemy in pixels.\n */\nexport const enemy_size = 10.0;\n\n/**\n * The amount of damage an enemy does.\n */\nexport const damage = 5;\n\n/**\n * The score reward for killing an enemy.\n */\nexport const value = 100;\n\nconst max_enemy_health = 80;\n\nconst bullet_wait_time = 200;\n\nconst enemy_gravity_strength = 0.02;\n\nconst whisker_length = 20.0;\n\nconst target_radius = 10.0;\n\nconst slow_radius = 40.0;\n\nconst max_speed = 3.0;\n\nconst max_acceleration = 3.0;\n\nconst wall_avoid_force = max_acceleration;\n\nconst jump_power = 0.3;\n\nconst pit_avoid_force = 1000.0;\n\nconst pit_avoid_radius = 30.0;\n\nconst avoid_force = 200.0;\n\nconst avoid_radius = 50.0;\n\nconst cluster_force = 100.0;\n\nconst cluster_radius = 20.0;\n\nconst dead_fill_color = \"#000000\";\n\nconst enemy_fill_color = \"#ff7b00\";\n\nconst enemy_stroke_color = \"#000000\";\n\nfunction random_direction(loop$position, loop$dungeon) {\n  while (true) {\n    let position = loop$position;\n    let dungeon = loop$dungeon;\n    let _block;\n    let _pipe = $random.int(0, 8);\n    _block = $random.random_sample(_pipe);\n    let dir = _block;\n    let _block$1;\n    if (dir === 0) {\n      _block$1 = new $room.Left();\n    } else if (dir === 1) {\n      _block$1 = new $room.Right();\n    } else if (dir === 2) {\n      _block$1 = new $room.Top();\n    } else if (dir === 3) {\n      _block$1 = new $room.Bottom();\n    } else if (dir === 4) {\n      _block$1 = new $room.TopLeft();\n    } else if (dir === 5) {\n      _block$1 = new $room.TopRight();\n    } else if (dir === 6) {\n      _block$1 = new $room.BottomLeft();\n    } else {\n      _block$1 = new $room.BottomRight();\n    }\n    let dir$1 = _block$1;\n    let $ = $dungeon.point_to_coordinate(position);\n    let col;\n    let row;\n    col = $[0];\n    row = $[1];\n    let _block$2;\n    let _pipe$1 = $dungeon.next_room_indices(col, row, dir$1);\n    _block$2 = $dungeon.coordinate_to_point(_pipe$1);\n    let new_position = _block$2;\n    let $1 = $dungeon.can_move(dungeon, position, new_position);\n    if ($1) {\n      return new_position;\n    } else {\n      loop$position = position;\n      loop$dungeon = dungeon;\n    }\n  }\n}\n\nexport function has_path_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  return new $behavior_tree.BehaviorResult(\n    !isEqual(enemy.path, toList([])),\n    enemy,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function path_is_stale_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  return new $behavior_tree.BehaviorResult(\n    (enemy.last_path_updated + 1000) < $utils.now_in_milliseconds(),\n    enemy,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function random_path_behavior(inputs) {\n  let enemy;\n  let inputs$1;\n  enemy = inputs.entity;\n  inputs$1 = inputs.additional_inputs;\n  let path = toList([\n    (() => {\n      let _pipe = enemy.position;\n      return random_direction(_pipe, inputs$1.dungeon);\n    })(),\n  ]);\n  let enemy$1 = new Enemy(\n    enemy.position,\n    enemy.rotation,\n    enemy.velocity,\n    enemy.rotational_velocity,\n    enemy.current_health,\n    enemy.max_health,\n    path,\n    $utils.now_in_milliseconds(),\n    enemy.spotted_player,\n    enemy.last_bullet_fired,\n    enemy.btree,\n  );\n  return new $behavior_tree.BehaviorResult(\n    true,\n    enemy$1,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function in_range_of_player_behavior(inputs) {\n  let enemy;\n  let dungeon;\n  let player;\n  enemy = inputs.entity;\n  dungeon = inputs.additional_inputs.dungeon;\n  player = inputs.additional_inputs.player;\n  return $bool.guard(\n    $vector.distance(enemy.position, player.position) > $int.to_float(\n      globalThis.Math.trunc($dungeon.room_size / 2),\n    ),\n    new $behavior_tree.BehaviorResult(\n      false,\n      enemy,\n      new AdditionalOutputs(toList([])),\n    ),\n    () => {\n      return new $behavior_tree.BehaviorResult(\n        $dungeon.can_move(dungeon, enemy.position, player.position),\n        enemy,\n        new AdditionalOutputs(toList([])),\n      );\n    },\n  );\n}\n\nexport function spot_player_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  return new $behavior_tree.BehaviorResult(\n    true,\n    new Enemy(\n      enemy.position,\n      enemy.rotation,\n      enemy.velocity,\n      enemy.rotational_velocity,\n      enemy.current_health,\n      enemy.max_health,\n      enemy.path,\n      enemy.last_path_updated,\n      true,\n      enemy.last_bullet_fired,\n      enemy.btree,\n    ),\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function spotted_player_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  return new $behavior_tree.BehaviorResult(\n    enemy.spotted_player,\n    enemy,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function path_to_player_behavior(inputs) {\n  let enemy;\n  let dungeon;\n  let player;\n  enemy = inputs.entity;\n  dungeon = inputs.additional_inputs.dungeon;\n  player = inputs.additional_inputs.player;\n  let path = $dungeon.path_to(dungeon, enemy.position, player.position);\n  let _block;\n  let _pipe = path;\n  _block = $list.take(_pipe, $list.length(path) - 1);\n  let path$1 = _block;\n  let enemy$1 = new Enemy(\n    enemy.position,\n    enemy.rotation,\n    enemy.velocity,\n    enemy.rotational_velocity,\n    enemy.current_health,\n    enemy.max_health,\n    path$1,\n    $utils.now_in_milliseconds(),\n    enemy.spotted_player,\n    enemy.last_bullet_fired,\n    enemy.btree,\n  );\n  return new $behavior_tree.BehaviorResult(\n    true,\n    enemy$1,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function in_air_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  return new $behavior_tree.BehaviorResult(\n    enemy.position.z > 0.0,\n    enemy,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function move_in_air_behavior(inputs) {\n  let enemy;\n  let dungeon;\n  enemy = inputs.entity;\n  dungeon = inputs.additional_inputs.dungeon;\n  let _block;\n  let _pipe = enemy.position;\n  _block = $vector.add(_pipe, enemy.velocity);\n  let new_position = _block;\n  let _block$1;\n  let $ = $dungeon.can_move(dungeon, enemy.position, new_position);\n  if ($) {\n    _block$1 = new_position;\n  } else {\n    _block$1 = new $vector.Vector(\n      enemy.position.x,\n      enemy.position.y,\n      enemy.position.z + enemy.velocity.z,\n    );\n  }\n  let new_position$1 = _block$1;\n  return new $behavior_tree.BehaviorResult(\n    true,\n    new Enemy(\n      new_position$1,\n      enemy.rotation,\n      enemy.velocity,\n      enemy.rotational_velocity,\n      enemy.current_health,\n      enemy.max_health,\n      enemy.path,\n      enemy.last_path_updated,\n      enemy.spotted_player,\n      enemy.last_bullet_fired,\n      enemy.btree,\n    ),\n    new AdditionalOutputs(toList([])),\n  );\n}\n\nexport function is_facing_player_behavior(inputs) {\n  let enemy;\n  let player;\n  enemy = inputs.entity;\n  player = inputs.additional_inputs.player;\n  let player2d = $vector.vector_2d(player.position);\n  let enemy2d = $vector.vector_2d(enemy.position);\n  let target = $vector.subtract(player2d, enemy2d);\n  let target$1 = $vector.multiply(\n    target,\n    divideFloat(\n      $vector.dot($vector.from_angle2d(enemy.rotation), target),\n      $vector.magnitude(target)\n    ),\n  );\n  let target$2 = $vector.add(target$1, enemy2d);\n  return new $behavior_tree.BehaviorResult(\n    $vector.distance(target$2, player2d) < ($player.player_size / 2.0),\n    enemy,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\n/**\n * Applies damage to the enemy.\n */\nexport function apply_damage(enemy, damage) {\n  return new Enemy(\n    enemy.position,\n    enemy.rotation,\n    enemy.velocity,\n    enemy.rotational_velocity,\n    enemy.current_health - damage,\n    enemy.max_health,\n    enemy.path,\n    enemy.last_path_updated,\n    enemy.spotted_player,\n    enemy.last_bullet_fired,\n    enemy.btree,\n  );\n}\n\n/**\n * Is the enemy currently dead.\n */\nexport function is_enemy_dead(enemy) {\n  return enemy.current_health <= 0;\n}\n\nfunction connection_crosses(start, end, center, radius) {\n  let diff = $vector.subtract(end, start);\n  let t = (divideFloat(\n    ((((-1.0 * diff.x) * (start.x - center.x)) - (diff.y * (start.y - center.y))) - (diff.z * (start.z - center.z))),\n    $vector.dot(diff, diff)\n  ));\n  let $ = (t > 1.0) || (t < 0.0);\n  if ($) {\n    let z = $vector.distance(\n      $vector.add(start, $vector.multiply(diff, 0.0)),\n      center,\n    );\n    let o = $vector.distance(\n      $vector.add(start, $vector.multiply(diff, 1.0)),\n      center,\n    );\n    return (z < radius) || (o < radius);\n  } else {\n    return $vector.distance(\n      $vector.add(start, $vector.multiply(diff, t)),\n      center,\n    ) < radius;\n  }\n}\n\nfunction clamp_radians(loop$input_radians) {\n  while (true) {\n    let input_radians = loop$input_radians;\n    let pi = $maths.pi();\n    let _block;\n    let $ = input_radians < (-1.0 * pi);\n    if ($) {\n      _block = clamp_radians(input_radians + (pi * 2.0));\n    } else {\n      _block = input_radians;\n    }\n    let input_radians$1 = _block;\n    let $1 = input_radians$1 > pi;\n    if ($1) {\n      loop$input_radians = input_radians$1 - (pi * 2.0);\n    } else {\n      return input_radians$1;\n    }\n  }\n}\n\nfunction target_rotation_range() {\n  return $maths.pi() / 30.0;\n}\n\nfunction slow_rotation_range() {\n  return $maths.pi() / 15.0;\n}\n\nfunction max_angular_speed() {\n  return $maths.pi() / 20.0;\n}\n\nfunction max_angular_acceleration() {\n  return $maths.pi() / 40.0;\n}\n\n/**\n * Checks if the object at the given position with given radius collides with the enemy.\n */\nexport function collides_with(enemy, position, size) {\n  return $vector.distance(enemy.position, position) < ((size / 2.0) + (enemy_size / 2.0));\n}\n\nexport function fire_bullet_behavior(inputs) {\n  let enemy;\n  enemy = inputs.entity;\n  let now = $utils.now_in_milliseconds();\n  let $ = (enemy.last_bullet_fired + bullet_wait_time) > now;\n  if ($) {\n    return new $behavior_tree.BehaviorResult(\n      false,\n      enemy,\n      new AdditionalOutputs(toList([])),\n    );\n  } else {\n    return new $behavior_tree.BehaviorResult(\n      true,\n      new Enemy(\n        enemy.position,\n        enemy.rotation,\n        enemy.velocity,\n        enemy.rotational_velocity,\n        enemy.current_health,\n        enemy.max_health,\n        enemy.path,\n        enemy.last_path_updated,\n        enemy.spotted_player,\n        now,\n        enemy.btree,\n      ),\n      new AdditionalOutputs(\n        toList([\n          $bullet.spawn_bullet(\n            enemy.position,\n            $vector.from_angle2d(enemy.rotation),\n            false,\n          ),\n        ]),\n      ),\n    );\n  }\n}\n\n/**\n * Applies gravity to the velocity and resets z position to floor when appropriate.\n */\nexport function apply_gravity(enemy) {\n  let _block;\n  let $ = enemy.position.z;\n  let z = $;\n  if (z < 0.0) {\n    _block = new $vector.Vector(enemy.position.x, enemy.position.y, 0.0);\n  } else {\n    _block = enemy.position;\n  }\n  let position = _block;\n  return new Enemy(\n    position,\n    enemy.rotation,\n    new $vector.Vector(\n      enemy.velocity.x,\n      enemy.velocity.y,\n      enemy.velocity.z - enemy_gravity_strength,\n    ),\n    enemy.rotational_velocity,\n    enemy.current_health,\n    enemy.max_health,\n    enemy.path,\n    enemy.last_path_updated,\n    enemy.spotted_player,\n    enemy.last_bullet_fired,\n    enemy.btree,\n  );\n}\n\nfunction create_whisker_points(enemy) {\n  let _block;\n  let _pipe = enemy.velocity;\n  let _pipe$1 = $vector.normalize(_pipe);\n  _block = $vector.multiply(_pipe$1, whisker_length);\n  let whisker_dist = _block;\n  let pi_div_4 = $maths.pi() / 4.0;\n  return toList([\n    (() => {\n      let _pipe$2 = whisker_dist;\n      let _pipe$3 = $vector.rotate2d(_pipe$2, pi_div_4);\n      return $vector.add(_pipe$3, enemy.position);\n    })(),\n    (() => {\n      let _pipe$2 = whisker_dist;\n      let _pipe$3 = $vector.rotate2d(_pipe$2, pi_div_4 * -1.0);\n      return $vector.add(_pipe$3, enemy.position);\n    })(),\n  ]);\n}\n\nfunction steer_enemy(enemy, target) {\n  let dir = $vector.subtract(target, enemy.position);\n  let _block;\n  let _pipe = dir;\n  _block = $vector.magnitude(_pipe);\n  let dist = _block;\n  let _block$1;\n  let _block$2;\n  let $ = dist < target_radius;\n  if ($) {\n    _block$2 = dir;\n  } else {\n    _block$2 = enemy.velocity;\n  }\n  let _pipe$1 = _block$2;\n  _block$1 = $vector.heading2d(_pipe$1);\n  let target_rotation = _block$1;\n  let rotation_diff = clamp_radians(target_rotation - enemy.rotation);\n  let rotation_mag = $float.absolute_value(rotation_diff);\n  return $bool.guard(\n    rotation_mag < target_rotation_range(),\n    enemy,\n    () => {\n      let target_rotation_velocity = divideFloat(\n        ((() => {\n          let $1 = rotation_mag > slow_rotation_range();\n          if ($1) {\n            return max_angular_speed();\n          } else {\n            return divideFloat(\n              (max_angular_speed() * rotation_mag),\n              slow_rotation_range()\n            );\n          }\n        })() * rotation_diff),\n        rotation_mag\n      );\n      let rotational_acceleration = target_rotation_velocity - enemy.rotational_velocity;\n      let rotational_acc_mag = $float.absolute_value(rotational_acceleration);\n      let _block$3;\n      let $1 = rotational_acc_mag > max_angular_acceleration();\n      if ($1) {\n        _block$3 = divideFloat(\n          (rotational_acceleration * max_angular_acceleration()),\n          rotational_acc_mag\n        );\n      } else {\n        _block$3 = rotational_acceleration;\n      }\n      let rotational_acceleration$1 = _block$3;\n      let rotational_velocity = enemy.rotational_velocity + rotational_acceleration$1;\n      return new Enemy(\n        enemy.position,\n        enemy.rotation + rotational_velocity,\n        enemy.velocity,\n        rotational_velocity,\n        enemy.current_health,\n        enemy.max_health,\n        enemy.path,\n        enemy.last_path_updated,\n        enemy.spotted_player,\n        enemy.last_bullet_fired,\n        enemy.btree,\n      );\n    },\n  );\n}\n\nfunction avoid_thing_at_position(enemy, position, acceleration, force, radius) {\n  let dir = $vector.subtract(enemy.position, position);\n  let dist = $vector.magnitude_squared(dir);\n  let $ = dist < (radius * radius);\n  if ($) {\n    let repulsion = $float.min(divideFloat(force, dist), max_acceleration);\n    let _pipe = dir;\n    let _pipe$1 = $vector.normalize(_pipe);\n    let _pipe$2 = $vector.multiply(_pipe$1, repulsion);\n    return $vector.add(_pipe$2, acceleration);\n  } else {\n    return acceleration;\n  }\n}\n\nfunction landing_position_if_jumped(position, velocity) {\n  let time_in_air = divideFloat(jump_power, enemy_gravity_strength);\n  return $vector.add(position, $vector.multiply(velocity, time_in_air));\n}\n\nfunction move_enemy(enemy, target, obstacles, pits, enemies, whisker_points) {\n  let dir = $vector.subtract(target, enemy.position);\n  let _block;\n  let _pipe = dir;\n  _block = $vector.magnitude(_pipe);\n  let dist = _block;\n  return $bool.guard(\n    dist < target_radius,\n    [enemy, enemy.position],\n    () => {\n      let _block$1;\n      let $ = dist > slow_radius;\n      if ($) {\n        _block$1 = max_speed;\n      } else {\n        _block$1 = divideFloat((max_speed * dist), slow_radius);\n      }\n      let target_speed = _block$1;\n      let _block$2;\n      let _pipe$1 = dir;\n      let _pipe$2 = $vector.normalize(_pipe$1);\n      _block$2 = $vector.multiply(_pipe$2, target_speed);\n      let target_velocity = _block$2;\n      let acceleration = $vector.subtract(target_velocity, enemy.velocity);\n      let $1 = $list.fold(\n        pits,\n        [acceleration, false],\n        (acc, p) => {\n          let is_jumping = acc[1];\n          let dir$1 = $vector.subtract(enemy.position, p.position);\n          let dist$1 = $vector.magnitude(dir$1);\n          let $2 = (dist$1 < pit_avoid_radius) && !is_jumping;\n          if ($2) {\n            let landing_position = landing_position_if_jumped(\n              enemy.position,\n              enemy.velocity,\n            );\n            let $3 = connection_crosses(\n              enemy.position,\n              landing_position,\n              p.position,\n              p.size / 2.0,\n            ) && ($vector.distance(landing_position, p.position) > (p.size / 2.0));\n            if ($3) {\n              return [\n                new $vector.Vector(\n                  0.0,\n                  0.0,\n                  (-1.0 * enemy.velocity.z) + jump_power,\n                ),\n                true,\n              ];\n            } else {\n              return [\n                avoid_thing_at_position(\n                  enemy,\n                  p.position,\n                  acc[0],\n                  pit_avoid_force,\n                  pit_avoid_radius,\n                ),\n                false,\n              ];\n            }\n          } else {\n            return acc;\n          }\n        },\n      );\n      let acceleration$1;\n      let is_jumping;\n      acceleration$1 = $1[0];\n      is_jumping = $1[1];\n      let acceleration$2 = $bool.guard(\n        is_jumping,\n        acceleration$1,\n        () => {\n          let _pipe$3 = acceleration$1;\n          let _pipe$4 = ((_capture) => {\n            return $list.fold(\n              obstacles,\n              _capture,\n              (acc, o) => {\n                return avoid_thing_at_position(\n                  enemy,\n                  o.position,\n                  acc,\n                  avoid_force,\n                  avoid_radius,\n                );\n              },\n            );\n          })(_pipe$3);\n          let _pipe$5 = ((_capture) => {\n            return $list.fold(\n              enemies,\n              _capture,\n              (acc, e) => {\n                let $2 = isEqual(e.position, enemy.position);\n                if ($2) {\n                  return acc;\n                } else {\n                  return avoid_thing_at_position(\n                    enemy,\n                    e.position,\n                    acc,\n                    cluster_force,\n                    cluster_radius,\n                  );\n                }\n              },\n            );\n          })(_pipe$4);\n          let _pipe$6 = $vector.limit(_pipe$5, max_acceleration);\n          let _pipe$7 = ((_capture) => {\n            return $list.fold(\n              whisker_points,\n              _capture,\n              (acc, w) => {\n                let _block$3;\n                if (w instanceof $room.Left) {\n                  _block$3 = new $vector.Vector(\n                    -1.0 * wall_avoid_force,\n                    0.0,\n                    0.0,\n                  );\n                } else if (w instanceof $room.Right) {\n                  _block$3 = new $vector.Vector(wall_avoid_force, 0.0, 0.0);\n                } else if (w instanceof $room.Top) {\n                  _block$3 = new $vector.Vector(\n                    0.0,\n                    -1.0 * wall_avoid_force,\n                    0.0,\n                  );\n                } else if (w instanceof $room.Bottom) {\n                  _block$3 = new $vector.Vector(0.0, wall_avoid_force, 0.0);\n                } else if (w instanceof $room.TopLeft) {\n                  _block$3 = new $vector.Vector(\n                    -1.0 * wall_avoid_force,\n                    -1.0 * wall_avoid_force,\n                    0.0,\n                  );\n                } else if (w instanceof $room.TopRight) {\n                  _block$3 = new $vector.Vector(\n                    wall_avoid_force,\n                    -1.0 * wall_avoid_force,\n                    0.0,\n                  );\n                } else if (w instanceof $room.BottomLeft) {\n                  _block$3 = new $vector.Vector(\n                    -1.0 * wall_avoid_force,\n                    wall_avoid_force,\n                    0.0,\n                  );\n                } else {\n                  _block$3 = new $vector.Vector(\n                    wall_avoid_force,\n                    wall_avoid_force,\n                    0.0,\n                  );\n                }\n                let add = _block$3;\n                return $vector.add(add, acc);\n              },\n            );\n          })(_pipe$6);\n          return $vector.limit(_pipe$7, max_acceleration);\n        },\n      );\n      let velocity = $vector.add(enemy.velocity, acceleration$2);\n      return [\n        new Enemy(\n          enemy.position,\n          enemy.rotation,\n          velocity,\n          enemy.rotational_velocity,\n          enemy.current_health,\n          enemy.max_health,\n          enemy.path,\n          enemy.last_path_updated,\n          enemy.spotted_player,\n          enemy.last_bullet_fired,\n          enemy.btree,\n        ),\n        $vector.add(velocity, enemy.position),\n      ];\n    },\n  );\n}\n\nexport function follow_path_behavior(inputs) {\n  let enemy;\n  let inputs$1;\n  enemy = inputs.entity;\n  inputs$1 = inputs.additional_inputs;\n  let enemies;\n  let dungeon;\n  enemies = inputs$1.enemies;\n  dungeon = inputs$1.dungeon;\n  let $ = enemy.path;\n  if ($ instanceof $Empty) {\n    return new $behavior_tree.BehaviorResult(\n      false,\n      enemy,\n      new AdditionalOutputs(toList([])),\n    );\n  } else {\n    let next = $.head;\n    let rest = $.tail;\n    let $1 = $vector.distance(next, enemy.position) < ($int.to_float(\n      $dungeon.room_size,\n    ) / 10.0);\n    if ($1) {\n      return new $behavior_tree.BehaviorResult(\n        true,\n        new Enemy(\n          enemy.position,\n          enemy.rotation,\n          enemy.velocity,\n          enemy.rotational_velocity,\n          enemy.current_health,\n          enemy.max_health,\n          rest,\n          enemy.last_path_updated,\n          enemy.spotted_player,\n          enemy.last_bullet_fired,\n          enemy.btree,\n        ),\n        new AdditionalOutputs(toList([])),\n      );\n    } else {\n      let _block;\n      let _pipe = create_whisker_points(enemy);\n      _block = $list.filter_map(\n        _pipe,\n        (_capture) => {\n          return $dungeon.get_reflecting_point(\n            dungeon,\n            enemy.position,\n            _capture,\n          );\n        },\n      );\n      let whiskers = _block;\n      let $2 = move_enemy(\n        enemy,\n        next,\n        dungeon.obstacles,\n        dungeon.pits,\n        enemies,\n        whiskers,\n      );\n      let enemy$1;\n      let new_position;\n      enemy$1 = $2[0];\n      new_position = $2[1];\n      let _block$1;\n      let $3 = $dungeon.can_move(dungeon, enemy$1.position, new_position);\n      if ($3) {\n        _block$1 = new_position;\n      } else {\n        _block$1 = new $vector.Vector(\n          enemy$1.position.x,\n          enemy$1.position.y,\n          enemy$1.position.z + enemy$1.velocity.z,\n        );\n      }\n      let new_position$1 = _block$1;\n      let _block$2;\n      let _pipe$1 = new Enemy(\n        new_position$1,\n        enemy$1.rotation,\n        enemy$1.velocity,\n        enemy$1.rotational_velocity,\n        enemy$1.current_health,\n        enemy$1.max_health,\n        enemy$1.path,\n        enemy$1.last_path_updated,\n        enemy$1.spotted_player,\n        enemy$1.last_bullet_fired,\n        enemy$1.btree,\n      );\n      _block$2 = steer_enemy(_pipe$1, next);\n      let enemy$2 = _block$2;\n      return new $behavior_tree.BehaviorResult(\n        true,\n        enemy$2,\n        new AdditionalOutputs(toList([])),\n      );\n    }\n  }\n}\n\nexport function follow_player_behavior(inputs) {\n  let enemy;\n  let enemies;\n  let dungeon;\n  let player;\n  enemy = inputs.entity;\n  enemies = inputs.additional_inputs.enemies;\n  dungeon = inputs.additional_inputs.dungeon;\n  player = inputs.additional_inputs.player;\n  let target = $vector.vector_2d(player.position);\n  let _block;\n  let _pipe = create_whisker_points(enemy);\n  _block = $list.filter_map(\n    _pipe,\n    (_capture) => {\n      return $dungeon.get_reflecting_point(dungeon, enemy.position, _capture);\n    },\n  );\n  let whiskers = _block;\n  let $ = move_enemy(\n    enemy,\n    target,\n    dungeon.obstacles,\n    dungeon.pits,\n    enemies,\n    whiskers,\n  );\n  let enemy$1;\n  let new_position;\n  enemy$1 = $[0];\n  new_position = $[1];\n  let _block$1;\n  let $1 = $dungeon.can_move(dungeon, enemy$1.position, new_position);\n  if ($1) {\n    _block$1 = new_position;\n  } else {\n    _block$1 = new $vector.Vector(\n      enemy$1.position.x,\n      enemy$1.position.y,\n      enemy$1.position.z + enemy$1.velocity.z,\n    );\n  }\n  let new_position$1 = _block$1;\n  let _block$2;\n  let _pipe$1 = new Enemy(\n    new_position$1,\n    enemy$1.rotation,\n    enemy$1.velocity,\n    enemy$1.rotational_velocity,\n    enemy$1.current_health,\n    enemy$1.max_health,\n    enemy$1.path,\n    enemy$1.last_path_updated,\n    enemy$1.spotted_player,\n    enemy$1.last_bullet_fired,\n    enemy$1.btree,\n  );\n  _block$2 = steer_enemy(_pipe$1, target);\n  let enemy$2 = _block$2;\n  return new $behavior_tree.BehaviorResult(\n    true,\n    enemy$2,\n    new AdditionalOutputs(toList([])),\n  );\n}\n\n/**\n * Makes a new enemy.\n */\nexport function new_enemy(initial_position) {\n  let default_output = new AdditionalOutputs(toList([]));\n  let output_to_input = (i, _) => { return i; };\n  let output_merge = (old, new$) => {\n    return new AdditionalOutputs($list.append(old.bullets, new$.bullets));\n  };\n  let sequence = (_capture) => {\n    return $behavior_tree.sequence(\n      _capture,\n      default_output,\n      output_to_input,\n      output_merge,\n    );\n  };\n  let selector = (_capture) => {\n    return $behavior_tree.selector(\n      _capture,\n      default_output,\n      output_to_input,\n      output_merge,\n    );\n  };\n  return new Enemy(\n    initial_position,\n    0.0,\n    new $vector.Vector(0.0, 0.0, 0.0),\n    0.0,\n    max_enemy_health,\n    max_enemy_health,\n    toList([]),\n    0,\n    false,\n    0,\n    $behavior_tree.all(\n      toList([\n        sequence(toList([in_range_of_player_behavior, spot_player_behavior])),\n        selector(\n          toList([\n            sequence(toList([spotted_player_behavior, path_to_player_behavior])),\n            sequence(\n              toList([\n                selector(\n                  toList([\n                    $behavior_tree.not(has_path_behavior),\n                    path_is_stale_behavior,\n                  ]),\n                ),\n                random_path_behavior,\n              ]),\n            ),\n          ]),\n        ),\n        selector(\n          toList([\n            sequence(toList([in_air_behavior, move_in_air_behavior])),\n            sequence(toList([has_path_behavior, follow_path_behavior])),\n            sequence(toList([spotted_player_behavior, follow_player_behavior])),\n          ]),\n        ),\n        sequence(\n          toList([\n            in_range_of_player_behavior,\n            is_facing_player_behavior,\n            fire_bullet_behavior,\n          ]),\n        ),\n      ]),\n      default_output,\n      output_to_input,\n      output_merge,\n    ),\n  );\n}\n\n/**\n * Renders the player to the screen.\n */\nexport function draw(p, enemy) {\n  let $ = is_enemy_dead(enemy);\n  if ($) {\n    $p5.fill(p, dead_fill_color)\n  } else {\n    $p5.fill(p, enemy_fill_color)\n  }\n  let $1 = $float.power(enemy_size, 1.0 + (enemy.position.z / 4.0));\n  let size_to_draw;\n  if ($1 instanceof Ok) {\n    size_to_draw = $1[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"enemy\",\n      811,\n      \"draw\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $1,\n        start: 23633,\n        end: 23722,\n        pattern_start: 23644,\n        pattern_end: 23660\n      }\n    )\n  }\n  let size_to_draw$1 = $float.max(size_to_draw, enemy_size / 2.0);\n  let _pipe = p;\n  let _pipe$1 = $p5.stroke(_pipe, enemy_stroke_color);\n  let _pipe$2 = $p5.circle(\n    _pipe$1,\n    enemy.position.x,\n    enemy.position.y,\n    size_to_draw$1,\n  );\n  return $p5.line(\n    _pipe$2,\n    enemy.position.x,\n    enemy.position.y,\n    enemy.position.x + ((($maths.cos(enemy.rotation) * size_to_draw$1)) / 2.0),\n    enemy.position.y + ((($maths.sin(enemy.rotation) * size_to_draw$1)) / 2.0),\n  );\n}\n","//# sourceMappingURL=bullet_heck_gleam.mjs.map\nimport * as $bool from \"../gleam_stdlib/gleam/bool.mjs\";\nimport * as $int from \"../gleam_stdlib/gleam/int.mjs\";\nimport * as $list from \"../gleam_stdlib/gleam/list.mjs\";\nimport * as $p5js_gleam from \"../p5js_gleam/p5js_gleam.mjs\";\nimport * as $p5 from \"../p5js_gleam/p5js_gleam/bindings.mjs\";\nimport * as $behavior_tree from \"./behavior_tree/behavior_tree.mjs\";\nimport * as $bullet from \"./bullet.mjs\";\nimport * as $dungeon from \"./dungeon.mjs\";\nimport * as $enemy from \"./enemy.mjs\";\nimport {\n  Ok,\n  toList,\n  Empty as $Empty,\n  prepend as listPrepend,\n  CustomType as $CustomType,\n  makeError,\n} from \"./gleam.mjs\";\nimport * as $obstacle from \"./obstacle.mjs\";\nimport * as $player from \"./player.mjs\";\nimport * as $utils from \"./utils.mjs\";\nimport * as $vector from \"./vector.mjs\";\n\nconst FILEPATH = \"src/bullet_heck_gleam.gleam\";\n\nclass StartScreen extends $CustomType {}\n\n/**\n * State of the world when the game is active.\n * \n * @ignore\n */\nclass GameRunning extends $CustomType {\n  constructor(dungeon, player, bullets, enemies, score) {\n    super();\n    this.dungeon = dungeon;\n    this.player = player;\n    this.bullets = bullets;\n    this.enemies = enemies;\n    this.score = score;\n  }\n}\n\n/**\n * The game over screen when the player has lost.\n * \n * @ignore\n */\nclass GameOver extends $CustomType {\n  constructor(fell_in_pit, score) {\n    super();\n    this.fell_in_pit = fell_in_pit;\n    this.score = score;\n  }\n}\n\nfunction preload(p) {\n  let minecraftia = $p5.load_font(p, \"./fonts/Minecraftia-Regular.ttf\");\n  let worksans = $p5.load_font(p, \"./fonts/WorkSans-Medium.ttf\");\n  let _pipe = $p5js_gleam.initialize_assets();\n  let _pipe$1 = $p5js_gleam.insert_font(_pipe, \"minecraftia\", minecraftia);\n  return $p5js_gleam.insert_font(_pipe$1, \"worksans\", worksans);\n}\n\nfunction setup(p) {\n  let canvas_size = $dungeon.total_size();\n  $p5.create_canvas(p, canvas_size, canvas_size);\n  return new StartScreen();\n}\n\nfunction draw(p, state, assets) {\n  let center_text = (txt) => {\n    let canvas_size = $dungeon.total_size();\n    return (canvas_size / 2.0) - ($p5.text_width(p, txt) / 2.0);\n  };\n  let h1 = 40;\n  let h2 = 30;\n  let h3 = 22;\n  let h4 = 18;\n  let par = 14;\n  let $ = $p5js_gleam.get_font(assets, \"minecraftia\");\n  let minecraftia;\n  if ($ instanceof Ok) {\n    minecraftia = $[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"bullet_heck_gleam\",\n      56,\n      \"draw\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $,\n        start: 1385,\n        end: 1456,\n        pattern_start: 1396,\n        pattern_end: 1411\n      }\n    )\n  }\n  let $1 = $p5js_gleam.get_font(assets, \"worksans\");\n  let worksans;\n  if ($1 instanceof Ok) {\n    worksans = $1[0];\n  } else {\n    throw makeError(\n      \"let_assert\",\n      FILEPATH,\n      \"bullet_heck_gleam\",\n      57,\n      \"draw\",\n      \"Pattern match failed, no pattern matched the value.\",\n      {\n        value: $1,\n        start: 1459,\n        end: 1524,\n        pattern_start: 1470,\n        pattern_end: 1482\n      }\n    )\n  }\n  let canvas_size = $dungeon.total_size();\n  $p5.background(p, \"#000000\");\n  if (state instanceof StartScreen) {\n    let title = \"BULLET HECK\";\n    let start = \"Press 'SPACE' to start\";\n    let ctrl = \"Controls\";\n    let ctrl_move = \"Use arrow keys or WASD to move\";\n    let ctrl_jump = \"Press SPACE to jump\";\n    let ctrl_shoot = \"Use mouse to aim, click to shoot\";\n    let _pipe = p;\n    let _pipe$1 = $p5.fill(_pipe, \"#0f0f0f\");\n    let _pipe$2 = $p5.rect(_pipe$1, 0.0, 0.0, canvas_size, canvas_size);\n    let _pipe$3 = $p5.text_size(_pipe$2, h1);\n    let _pipe$4 = $p5.fill(_pipe$3, \"#ffffff\");\n    let _pipe$5 = $p5.text_font(_pipe$4, minecraftia);\n    let _pipe$6 = $p5.text(\n      _pipe$5,\n      title,\n      center_text(title),\n      (canvas_size / 2.0) + 5.0,\n    );\n    let _pipe$7 = $p5.text_font(_pipe$6, worksans);\n    let _pipe$8 = $p5.text_size(_pipe$7, h4);\n    let _pipe$9 = $p5.text(\n      _pipe$8,\n      start,\n      center_text(start),\n      (canvas_size / 2.0) + 20.0,\n    );\n    let _pipe$10 = $p5.fill(_pipe$9, \"#969696\");\n    let _pipe$11 = $p5.text(\n      _pipe$10,\n      ctrl,\n      center_text(ctrl),\n      (canvas_size / 2.0) + 200.0,\n    );\n    let _pipe$12 = $p5.text_size(_pipe$11, par);\n    let _pipe$13 = $p5.text(\n      _pipe$12,\n      ctrl_move,\n      center_text(ctrl_move),\n      (canvas_size / 2.0) + 225.0,\n    );\n    let _pipe$14 = $p5.text(\n      _pipe$13,\n      ctrl_jump,\n      center_text(ctrl_jump),\n      (canvas_size / 2.0) + 245.0,\n    );\n    return $p5.text(\n      _pipe$14,\n      ctrl_shoot,\n      center_text(ctrl_shoot),\n      (canvas_size / 2.0) + 265.0,\n    );\n  } else if (state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    $dungeon.draw(p, dungeon);\n    $list.each(enemies, (_capture) => { return $enemy.draw(p, _capture); });\n    $list.each(bullets, (_capture) => { return $bullet.draw(p, _capture); });\n    $player.draw(p, player);\n    let hp_x = 22.0;\n    let score_x = canvas_size - 100.0;\n    let _pipe = p;\n    let _pipe$1 = $p5.no_stroke(_pipe);\n    let _pipe$2 = $p5.fill(_pipe$1, \"#660000\");\n    let _pipe$3 = $p5.rect(_pipe$2, 0.0, 0.0, canvas_size, 36.0);\n    let _pipe$4 = $p5.fill(_pipe$3, \"#28e200\");\n    let _pipe$5 = $p5.rect(\n      _pipe$4,\n      hp_x + 15.0,\n      12.0,\n      $int.to_float(player.current_health),\n      10.0,\n    );\n    let _pipe$6 = $p5.fill(_pipe$5, \"#ffffff\");\n    let _pipe$7 = $p5.text_size(_pipe$6, par);\n    let _pipe$8 = $p5.text(_pipe$7, \"HP:\", 10.0, hp_x);\n    let _pipe$9 = $p5.text(_pipe$8, \"Score:\", score_x, 22.0);\n    return $p5.text(_pipe$9, $int.to_string(score), score_x + 45.0, 22.0);\n  } else {\n    let fell_in_pit = state.fell_in_pit;\n    let score = state.score;\n    let canvas_size$1 = $dungeon.total_size();\n    let game_over = \"GAME OVER\";\n    let final_score = \"Final Score: \";\n    let restart = \"Press 'R' to play again\";\n    let score_text = final_score + $int.to_string(score);\n    let _block;\n    if (fell_in_pit) {\n      _block = \"You fell to your death.\";\n    } else {\n      _block = \"Turns out, red things hurt.\";\n    }\n    let cause_of_death = _block;\n    let _pipe = p;\n    let _pipe$1 = $p5.fill(_pipe, \"#0f0f0f\");\n    let _pipe$2 = $p5.rect(_pipe$1, 0.0, 0.0, canvas_size$1, canvas_size$1);\n    let _pipe$3 = $p5.fill(_pipe$2, \"#e20000\");\n    let _pipe$4 = $p5.text_size(_pipe$3, h2);\n    let _pipe$5 = $p5.text_font(_pipe$4, minecraftia);\n    let _pipe$6 = $p5.text(\n      _pipe$5,\n      game_over,\n      center_text(game_over),\n      (canvas_size$1 / 2.0) - 25.0,\n    );\n    let _pipe$7 = $p5.text_size(_pipe$6, h3);\n    let _pipe$8 = $p5.text_font(_pipe$7, worksans);\n    let _pipe$9 = $p5.text(\n      _pipe$8,\n      cause_of_death,\n      center_text(cause_of_death),\n      (canvas_size$1 / 2.0) - 15.0,\n    );\n    let _pipe$10 = $p5.fill(_pipe$9, \"#ffffff\");\n    let _pipe$11 = $p5.text(\n      _pipe$10,\n      score_text,\n      center_text(score_text),\n      (canvas_size$1 / 2.0) + 45.0,\n    );\n    let _pipe$12 = $p5.text_size(_pipe$11, h4);\n    return $p5.text(\n      _pipe$12,\n      restart,\n      center_text(restart),\n      (canvas_size$1 / 2.0) + 70.0,\n    );\n  }\n}\n\nfunction spawn_enemies(dungeon) {\n  let enemies_to_spawn = 4;\n  return $list.map(\n    $list.range(0, enemies_to_spawn - 1),\n    (_) => {\n      let position = $dungeon.get_location_to_place_object(\n        dungeon.rooms,\n        dungeon.pits,\n      );\n      return $enemy.new_enemy(position);\n    },\n  );\n}\n\nfunction on_key_pressed(key, _, state) {\n  if (key === \"r\") {\n    return new StartScreen();\n  } else if (key === \" \") {\n    if (state instanceof StartScreen) {\n      let canvas_size = $dungeon.total_size();\n      let dungeon = $dungeon.generate_dungeon();\n      return new GameRunning(\n        dungeon,\n        $player.new_player(\n          new $vector.Vector(canvas_size / 2.0, canvas_size / 2.0, 0.0),\n        ),\n        toList([]),\n        spawn_enemies(dungeon),\n        0,\n      );\n    } else if (state instanceof GameRunning) {\n      let dungeon = state.dungeon;\n      let player = state.player;\n      let bullets = state.bullets;\n      let enemies = state.enemies;\n      let score = state.score;\n      return new GameRunning(\n        dungeon,\n        $player.jump(player),\n        bullets,\n        enemies,\n        score,\n      );\n    } else {\n      return state;\n    }\n  } else if (key === \"w\" && state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    return new GameRunning(\n      dungeon,\n      $player.accelerate_y(player, false),\n      bullets,\n      enemies,\n      score,\n    );\n  } else if (key === \"s\" && state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    return new GameRunning(\n      dungeon,\n      $player.accelerate_y(player, true),\n      bullets,\n      enemies,\n      score,\n    );\n  } else if (key === \"a\" && state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    return new GameRunning(\n      dungeon,\n      $player.accelerate_x(player, false),\n      bullets,\n      enemies,\n      score,\n    );\n  } else if (key === \"d\" && state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    return new GameRunning(\n      dungeon,\n      $player.accelerate_x(player, true),\n      bullets,\n      enemies,\n      score,\n    );\n  } else {\n    return state;\n  }\n}\n\nfunction on_key_released(key, _, state) {\n  if (state instanceof GameRunning) {\n    if (key === \"w\") {\n      let dungeon = state.dungeon;\n      let player = state.player;\n      let bullets = state.bullets;\n      let enemies = state.enemies;\n      let score = state.score;\n      return new GameRunning(\n        dungeon,\n        $player.stop_y(player),\n        bullets,\n        enemies,\n        score,\n      );\n    } else if (key === \"s\") {\n      let dungeon = state.dungeon;\n      let player = state.player;\n      let bullets = state.bullets;\n      let enemies = state.enemies;\n      let score = state.score;\n      return new GameRunning(\n        dungeon,\n        $player.stop_y(player),\n        bullets,\n        enemies,\n        score,\n      );\n    } else if (key === \"a\") {\n      let dungeon = state.dungeon;\n      let player = state.player;\n      let bullets = state.bullets;\n      let enemies = state.enemies;\n      let score = state.score;\n      return new GameRunning(\n        dungeon,\n        $player.stop_x(player),\n        bullets,\n        enemies,\n        score,\n      );\n    } else if (key === \"d\") {\n      let dungeon = state.dungeon;\n      let player = state.player;\n      let bullets = state.bullets;\n      let enemies = state.enemies;\n      let score = state.score;\n      return new GameRunning(\n        dungeon,\n        $player.stop_x(player),\n        bullets,\n        enemies,\n        score,\n      );\n    } else {\n      return state;\n    }\n  } else {\n    return state;\n  }\n}\n\nfunction on_mouse_clicked(x, y, state) {\n  if (state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    return $bool.guard(\n      !$player.can_player_fire(player),\n      state,\n      () => {\n        let firing_direction = $vector.vector_2d(\n          $vector.subtract(new $vector.Vector(x, y, 0.0), player.position),\n        );\n        let p;\n        p = player.position;\n        return new GameRunning(\n          dungeon,\n          new $player.Player(\n            player.position,\n            player.velocity,\n            player.acceleration,\n            $utils.now_in_milliseconds(),\n            player.last_hit_time,\n            player.current_health,\n            player.max_health,\n          ),\n          listPrepend(\n            $bullet.spawn_bullet(\n              new $vector.Vector(p.x, p.y, 0.0),\n              firing_direction,\n              true,\n            ),\n            bullets,\n          ),\n          enemies,\n          score,\n        );\n      },\n    );\n  } else {\n    return state;\n  }\n}\n\nfunction on_tick(state) {\n  if (state instanceof GameRunning) {\n    let dungeon = state.dungeon;\n    let player = state.player;\n    let bullets = state.bullets;\n    let enemies = state.enemies;\n    let score = state.score;\n    let old_position = player.position;\n    let moved = $player.move(player);\n    let _block;\n    let $ = $dungeon.can_move(dungeon, old_position, moved.position);\n    if ($) {\n      _block = moved;\n    } else {\n      _block = new $player.Player(\n        new $vector.Vector(\n          old_position.x,\n          old_position.y,\n          old_position.z + player.velocity.z,\n        ),\n        player.velocity,\n        player.acceleration,\n        player.last_fire_time,\n        player.last_hit_time,\n        player.current_health,\n        player.max_health,\n      );\n    }\n    let player$1 = _block;\n    return $bool.guard(\n      (player$1.position.z <= 0.0) && $dungeon.is_over_pit(\n        dungeon,\n        player$1.position,\n      ),\n      new GameOver(true, score),\n      () => {\n        let player$2 = $player.update_velocity(player$1);\n        let player$3 = $player.apply_gravity(player$2);\n        let player$4 = $list.fold(\n          dungeon.obstacles,\n          player$3,\n          (player, o) => {\n            let $1 = $obstacle.collides_with(\n              o,\n              player.position,\n              $player.player_size,\n            ) && !$player.is_player_invulnerable(player);\n            if ($1) {\n              return $player.apply_damage(player, $obstacle.damage);\n            } else {\n              return player;\n            }\n          },\n        );\n        let $1 = $list.fold(\n          enemies,\n          [toList([]), bullets, player$4, score],\n          (acc, e) => {\n            let enemies$1;\n            let bullets$1;\n            let player$5;\n            let score$1;\n            enemies$1 = acc[0];\n            bullets$1 = acc[1];\n            player$5 = acc[2];\n            score$1 = acc[3];\n            let $2 = e.btree(\n              new $behavior_tree.BehaviorInput(\n                e,\n                new $enemy.Inputs(enemies$1, dungeon, player$5),\n              ),\n            );\n            let enemy;\n            let new_bullets;\n            enemy = $2.entity;\n            new_bullets = $2.additional_outputs.bullets;\n            let enemy$1 = $enemy.apply_gravity(enemy);\n            let bullets$2 = $list.append(new_bullets, bullets$1);\n            return $bool.guard(\n              (enemy$1.position.z <= 0.0) && $dungeon.is_over_pit(\n                dungeon,\n                enemy$1.position,\n              ),\n              [enemies$1, bullets$2, player$5, score$1 + $enemy.value],\n              () => {\n                let _block$1;\n                let $3 = $enemy.collides_with(\n                  enemy$1,\n                  player$5.position,\n                  $player.player_size,\n                ) && !$player.is_player_invulnerable(player$5);\n                if ($3) {\n                  _block$1 = $player.apply_damage(player$5, $enemy.damage);\n                } else {\n                  _block$1 = player$5;\n                }\n                let player$6 = _block$1;\n                let enemy$2 = $list.fold(\n                  dungeon.obstacles,\n                  enemy$1,\n                  (enemy, o) => {\n                    let $4 = $obstacle.collides_with(\n                      o,\n                      enemy.position,\n                      $enemy.enemy_size,\n                    );\n                    if ($4) {\n                      return $enemy.apply_damage(enemy, $obstacle.damage);\n                    } else {\n                      return enemy;\n                    }\n                  },\n                );\n                return $bool.guard(\n                  $enemy.is_enemy_dead(enemy$2),\n                  [enemies$1, bullets$2, player$6, score$1 + $enemy.value],\n                  () => {\n                    return [\n                      listPrepend(enemy$2, enemies$1),\n                      bullets$2,\n                      player$6,\n                      score$1,\n                    ];\n                  },\n                );\n              },\n            );\n          },\n        );\n        let enemies$1;\n        let bullets$1;\n        let player$5;\n        let score$1;\n        enemies$1 = $1[0];\n        bullets$1 = $1[1];\n        player$5 = $1[2];\n        score$1 = $1[3];\n        let _block$1;\n        let _pipe = bullets$1;\n        _block$1 = $list.filter(_pipe, $bullet.is_still_alive);\n        let bullets$2 = _block$1;\n        let $2 = $list.fold(\n          bullets$2,\n          [toList([]), player$5, enemies$1, score$1],\n          (acc, b) => {\n            return $bool.guard(\n              !$dungeon.can_move(\n                dungeon,\n                b.position,\n                $bullet.advance_bullet(b).position,\n              ),\n              acc,\n              () => {\n                let bullets$3;\n                let player$6;\n                let enemies$2;\n                let score$2;\n                bullets$3 = acc[0];\n                player$6 = acc[1];\n                enemies$2 = acc[2];\n                score$2 = acc[3];\n                return $bool.guard(\n                  (!b.belongs_to_player && $bullet.collides_with(\n                    b,\n                    player$6.position,\n                    $player.player_size,\n                  )) && !$player.is_player_invulnerable(player$6),\n                  [\n                    bullets$3,\n                    $player.apply_damage(player$6, $bullet.enemy_damage),\n                    enemies$2,\n                    score$2,\n                  ],\n                  () => {\n                    let $3 = $list.fold(\n                      enemies$2,\n                      [toList([]), score$2, false],\n                      (acc, e) => {\n                        let enemies$3;\n                        let score$3;\n                        let any_hit;\n                        enemies$3 = acc[0];\n                        score$3 = acc[1];\n                        any_hit = acc[2];\n                        let _block$2;\n                        let $5 = b.belongs_to_player && $bullet.collides_with(\n                          b,\n                          e.position,\n                          $enemy.enemy_size,\n                        );\n                        if ($5) {\n                          _block$2 = [\n                            $enemy.apply_damage(e, $bullet.player_damage),\n                            true,\n                          ];\n                        } else {\n                          _block$2 = [e, any_hit];\n                        }\n                        let $4 = _block$2;\n                        let e$1;\n                        let any_hit$1;\n                        e$1 = $4[0];\n                        any_hit$1 = $4[1];\n                        return $bool.guard(\n                          $enemy.is_enemy_dead(e$1),\n                          [enemies$3, score$3 + $enemy.value, any_hit$1],\n                          () => {\n                            return [\n                              listPrepend(e$1, enemies$3),\n                              score$3,\n                              any_hit$1,\n                            ];\n                          },\n                        );\n                      },\n                    );\n                    let enemies$3;\n                    let score$3;\n                    let any_hit;\n                    enemies$3 = $3[0];\n                    score$3 = $3[1];\n                    any_hit = $3[2];\n                    if (any_hit) {\n                      return [bullets$3, player$6, enemies$3, score$3];\n                    } else {\n                      return [\n                        listPrepend($bullet.advance_bullet(b), bullets$3),\n                        player$6,\n                        enemies$3,\n                        score$3,\n                      ];\n                    }\n                  },\n                );\n              },\n            );\n          },\n        );\n        let bullets$3;\n        let player$6;\n        let enemies$2;\n        let score$2;\n        bullets$3 = $2[0];\n        player$6 = $2[1];\n        enemies$2 = $2[2];\n        score$2 = $2[3];\n        return $bool.guard(\n          $player.is_player_dead(player$6),\n          new GameOver(false, score$2),\n          () => {\n            if (enemies$2 instanceof $Empty) {\n              let canvas_size = $dungeon.total_size();\n              let dungeon$1 = $dungeon.generate_dungeon();\n              return new GameRunning(\n                dungeon$1,\n                $player.new_player(\n                  new $vector.Vector(canvas_size / 2.0, canvas_size / 2.0, 0.0),\n                ),\n                toList([]),\n                spawn_enemies(dungeon$1),\n                score$2,\n              );\n            } else {\n              return new GameRunning(\n                dungeon,\n                player$6,\n                bullets$3,\n                enemies$2,\n                score$2,\n              );\n            }\n          },\n        );\n      },\n    );\n  } else {\n    return state;\n  }\n}\n\nexport function main() {\n  let _pipe = $p5js_gleam.create_sketch_with_preloading(preload, setup, draw);\n  let _pipe$1 = $p5js_gleam.set_on_key_pressed(_pipe, on_key_pressed);\n  let _pipe$2 = $p5js_gleam.set_on_key_released(_pipe$1, on_key_released);\n  let _pipe$3 = $p5js_gleam.set_on_mouse_clicked(_pipe$2, on_mouse_clicked);\n  let _pipe$4 = $p5js_gleam.set_on_tick(_pipe$3, on_tick);\n  return $p5.start_sketch(_pipe$4);\n}\n","\n      import {main} from './build/dev/javascript/bullet_heck_gleam/bullet_heck_gleam.mjs'\n      main();\n    "],"mappings":"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"}